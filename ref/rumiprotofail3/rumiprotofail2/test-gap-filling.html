<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap Filling Test - Genre Channel</title>
    <style>
        body {
            font-family: 'SF Mono', monospace;
            background: #0a0a0a;
            color: #00ff41;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00ff41;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .test-section {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .test-section h2 {
            color: #00ff41;
            margin-top: 0;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #444;
        }

        .control-group h3 {
            margin-top: 0;
            color: #00ff41;
            font-size: 14px;
        }

        button {
            background: #333;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            margin: 5px;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
        }

        button.active {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .status {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #444;
            margin-bottom: 20px;
        }

        .status h3 {
            margin-top: 0;
            color: #00ff41;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .status-label {
            font-weight: bold;
        }

        .status-value {
            color: #ffffff;
        }

        .status-value.enabled {
            color: #00ff41;
        }

        .status-value.disabled {
            color: #ff4444;
        }

        .test-results {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #444;
            margin-top: 20px;
        }

        .test-results h3 {
            margin-top: 0;
            color: #00ff41;
        }

        .log {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            color: #00ff41;
        }

        .iframe-container {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .iframe-container h3 {
            margin-top: 0;
            color: #00ff41;
        }

        iframe {
            width: 100%;
            height: 400px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #000;
        }

        .instructions {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #444;
            margin-bottom: 20px;
        }

        .instructions h3 {
            margin-top: 0;
            color: #00ff41;
        }

        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }

        .warning {
            background: #3a2a2a;
            border: 1px solid #ff4444;
            color: #ff6666;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Gap Filling Test - Genre Channel</h1>

        <div class="instructions">
            <h3>üìã Test Instructions</h3>
            <ol>
                <li><strong>Auto Gap Filling</strong>: When enabled, blocks automatically slide to fill gaps when content is removed</li>
                <li><strong>Time Position Preservation</strong>: When enabled, blocks maintain their original time-based positions (creates gaps with + buttons)</li>
                <li><strong>Test Scenarios</strong>: Use the buttons below to test different gap filling behaviors</li>
                <li><strong>Monitor Results</strong>: Watch the status panel and log for real-time feedback</li>
            </ol>
        </div>

        <div class="status">
            <h3>üìä System Status</h3>
            <div id="status-content">
                <div class="status-item">
                    <span class="status-label">Overlap Fix:</span>
                    <span class="status-value" id="overlap-status">Checking...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Auto Gap Filling:</span>
                    <span class="status-value" id="gap-filling-status">Checking...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Time Position Preservation:</span>
                    <span class="status-value" id="time-positions-status">Checking...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Block Count:</span>
                    <span class="status-value" id="block-count">Checking...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Gap Count:</span>
                    <span class="status-value" id="gap-count">Checking...</span>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üéõÔ∏è Gap Filling Controls</h2>
            
            <div class="controls">
                <div class="control-group">
                    <h3>Auto Gap Filling</h3>
                    <button id="toggle-gap-filling">Toggle Auto Gap Filling</button>
                    <button id="fill-gaps-now">Fill Gaps Now</button>
                </div>

                <div class="control-group">
                    <h3>Time Position Preservation</h3>
                    <button id="toggle-time-positions">Toggle Time Positions</button>
                    <button id="preserve-positions">Preserve Positions</button>
                </div>

                <div class="control-group">
                    <h3>Test Actions</h3>
                    <button id="test-overlap-fix">Test Overlap Fix</button>
                    <button id="refresh-status">Refresh Status</button>
                    <button id="clear-log">Clear Log</button>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üß™ Test Scenarios</h2>
            
            <div class="controls">
                <div class="control-group">
                    <h3>Gap Creation Tests</h3>
                    <button id="test-remove-middle">Remove Middle Block</button>
                    <button id="test-remove-first">Remove First Block</button>
                    <button id="test-remove-last">Remove Last Block</button>
                </div>

                <div class="control-group">
                    <h3>Gap Filling Tests</h3>
                    <button id="test-auto-fill">Test Auto Fill</button>
                    <button id="test-manual-fill">Test Manual Fill</button>
                    <button id="test-multiple-gaps">Test Multiple Gaps</button>
                </div>

                <div class="control-group">
                    <h3>Behavior Tests</h3>
                    <button id="test-time-preservation">Test Time Preservation</button>
                    <button id="test-gap-indicators">Test Gap Indicators</button>
                    <button id="test-overlap-prevention">Test Overlap Prevention</button>
                </div>
            </div>
        </div>

        <div class="test-results">
            <h3>üìù Test Log</h3>
            <div class="log" id="test-log"></div>
        </div>

        <div class="iframe-container">
            <h3>üé¨ Genre Channel Test Environment</h3>
            <iframe id="test-frame" src="Genre-channel_v2.html"></iframe>
        </div>
    </div>

    <script>
        let frameWindow = null;
        let statusUpdateInterval = null;

        // Initialize the test environment
        document.addEventListener('DOMContentLoaded', () => {
            log('üöÄ Gap Filling Test initialized');
            
            // Wait for iframe to load
            const iframe = document.getElementById('test-frame');
            iframe.onload = () => {
                frameWindow = iframe.contentWindow;
                log('‚úÖ Test frame loaded');
                
                // Start status monitoring
                startStatusMonitoring();
                
                // Initial status check
                updateStatus();
            };

            // Setup event listeners
            setupEventListeners();
        });

        function setupEventListeners() {
            // Gap filling controls
            document.getElementById('toggle-gap-filling').onclick = toggleGapFilling;
            document.getElementById('fill-gaps-now').onclick = fillGapsNow;
            document.getElementById('toggle-time-positions').onclick = toggleTimePositions;
            document.getElementById('preserve-positions').onclick = preservePositions;
            
            // Test actions
            document.getElementById('test-overlap-fix').onclick = testOverlapFix;
            document.getElementById('refresh-status').onclick = updateStatus;
            document.getElementById('clear-log').onclick = clearLog;
            
            // Test scenarios
            document.getElementById('test-remove-middle').onclick = () => testRemoveBlock('middle');
            document.getElementById('test-remove-first').onclick = () => testRemoveBlock('first');
            document.getElementById('test-remove-last').onclick = () => testRemoveBlock('last');
            document.getElementById('test-auto-fill').onclick = testAutoFill;
            document.getElementById('test-manual-fill').onclick = testManualFill;
            document.getElementById('test-multiple-gaps').onclick = testMultipleGaps;
            document.getElementById('test-time-preservation').onclick = testTimePreservation;
            document.getElementById('test-gap-indicators').onclick = testGapIndicators;
            document.getElementById('test-overlap-prevention').onclick = testOverlapPrevention;
        }

        function log(message) {
            const logElement = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('test-log').innerHTML = '';
            log('üßπ Log cleared');
        }

        function startStatusMonitoring() {
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
            
            statusUpdateInterval = setInterval(updateStatus, 2000);
            log('üìä Status monitoring started');
        }

        function updateStatus() {
            if (!frameWindow) return;

            try {
                // Check if overlap fix is available
                if (frameWindow.genreChannelOverlapFix) {
                    const status = frameWindow.genreChannelOverlapFix.getStatus();
                    
                    document.getElementById('overlap-status').textContent = status.isEnabled ? 'Enabled' : 'Disabled';
                    document.getElementById('overlap-status').className = status.isEnabled ? 'status-value enabled' : 'status-value disabled';
                    
                    document.getElementById('gap-filling-status').textContent = status.autoFillGaps ? 'Enabled' : 'Disabled';
                    document.getElementById('gap-filling-status').className = status.autoFillGaps ? 'status-value enabled' : 'status-value disabled';
                    
                    document.getElementById('time-positions-status').textContent = status.preserveTimePositions ? 'Enabled' : 'Disabled';
                    document.getElementById('time-positions-status').className = status.preserveTimePositions ? 'status-value enabled' : 'status-value disabled';
                    
                    document.getElementById('block-count').textContent = status.blockCount;
                    document.getElementById('gap-count').textContent = status.gapCount;
                } else {
                    document.getElementById('overlap-status').textContent = 'Not Found';
                    document.getElementById('overlap-status').className = 'status-value disabled';
                }
            } catch (error) {
                log(`‚ùå Status update error: ${error.message}`);
            }
        }

        function toggleGapFilling() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                frameWindow.genreChannelOverlapFix.toggleGapFilling();
                log('üîÑ Toggled auto gap filling');
                updateStatus();
            } catch (error) {
                log(`‚ùå Toggle gap filling error: ${error.message}`);
            }
        }

        function fillGapsNow() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                frameWindow.genreChannelOverlapFix.fillGapsIfEnabled();
                log('üîß Manual gap filling triggered');
                updateStatus();
            } catch (error) {
                log(`‚ùå Fill gaps error: ${error.message}`);
            }
        }

        function toggleTimePositions() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                frameWindow.genreChannelOverlapFix.toggleTimePositions();
                log('üîÑ Toggled time position preservation');
                updateStatus();
            } catch (error) {
                log(`‚ùå Toggle time positions error: ${error.message}`);
            }
        }

        function preservePositions() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                frameWindow.genreChannelOverlapFix.preserveTimePositions = true;
                frameWindow.genreChannelOverlapFix.autoFillGaps = false;
                log('‚è∞ Time position preservation enabled, auto gap filling disabled');
                updateStatus();
            } catch (error) {
                log(`‚ùå Preserve positions error: ${error.message}`);
            }
        }

        function testOverlapFix() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                const result = frameWindow.genreChannelOverlapFix.test();
                log(`üß™ Overlap fix test result: ${JSON.stringify(result, null, 2)}`);
                updateStatus();
            } catch (error) {
                log(`‚ùå Test overlap fix error: ${error.message}`);
            }
        }

        function testRemoveBlock(position) {
            if (!frameWindow) {
                log('‚ùå Frame window not available');
                return;
            }

            try {
                const blocks = frameWindow.document.querySelectorAll('.program-slot:not(.empty)');
                if (blocks.length === 0) {
                    log('‚ùå No blocks to remove');
                    return;
                }

                let blockIndex = 0;
                if (position === 'middle' && blocks.length > 2) {
                    blockIndex = Math.floor(blocks.length / 2);
                } else if (position === 'last') {
                    blockIndex = blocks.length - 1;
                }

                const block = blocks[blockIndex];
                const title = block.querySelector('.program-title')?.textContent || `Block ${blockIndex + 1}`;
                
                log(`üóëÔ∏è Removing ${position} block: "${title}"`);
                
                // Find the index in currentContent
                if (frameWindow.currentContent && frameWindow.removeContent) {
                    const contentIndex = frameWindow.currentContent.findIndex(item => 
                        item.title === title || item.title.includes(title)
                    );
                    
                    if (contentIndex !== -1) {
                        frameWindow.removeContent(contentIndex);
                        log(`‚úÖ Removed block at index ${contentIndex}`);
                    } else {
                        log('‚ùå Could not find block in currentContent');
                    }
                } else {
                    log('‚ùå currentContent or removeContent not available');
                }
                
                updateStatus();
            } catch (error) {
                log(`‚ùå Test remove block error: ${error.message}`);
            }
        }

        function testAutoFill() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                // Enable auto gap filling
                frameWindow.genreChannelOverlapFix.autoFillGaps = true;
                frameWindow.genreChannelOverlapFix.preserveTimePositions = false;
                
                log('üîß Auto gap filling test: enabled auto fill, disabled time preservation');
                
                // Trigger gap filling
                frameWindow.genreChannelOverlapFix.fillGapsIfEnabled();
                
                log('‚úÖ Auto fill test completed');
                updateStatus();
            } catch (error) {
                log(`‚ùå Auto fill test error: ${error.message}`);
            }
        }

        function testManualFill() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                // Disable auto gap filling
                frameWindow.genreChannelOverlapFix.autoFillGaps = false;
                frameWindow.genreChannelOverlapFix.preserveTimePositions = false;
                
                log('üîß Manual gap filling test: disabled auto fill, disabled time preservation');
                
                // Trigger manual gap filling
                frameWindow.genreChannelOverlapFix.fillGapsIfEnabled();
                
                log('‚úÖ Manual fill test completed');
                updateStatus();
            } catch (error) {
                log(`‚ùå Manual fill test error: ${error.message}`);
            }
        }

        function testMultipleGaps() {
            if (!frameWindow) {
                log('‚ùå Frame window not available');
                return;
            }

            try {
                log('üîß Testing multiple gap creation...');
                
                // Remove multiple blocks to create gaps
                const blocks = frameWindow.document.querySelectorAll('.program-slot:not(.empty)');
                if (blocks.length < 3) {
                    log('‚ùå Need at least 3 blocks for multiple gap test');
                    return;
                }

                // Remove first and last blocks
                testRemoveBlock('first');
                setTimeout(() => {
                    testRemoveBlock('last');
                    log('‚úÖ Multiple gap test completed');
                }, 500);
                
            } catch (error) {
                log(`‚ùå Multiple gaps test error: ${error.message}`);
            }
        }

        function testTimePreservation() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                // Enable time position preservation
                frameWindow.genreChannelOverlapFix.preserveTimePositions = true;
                frameWindow.genreChannelOverlapFix.autoFillGaps = false;
                
                log('‚è∞ Time preservation test: enabled time preservation, disabled auto fill');
                
                // Remove a block to test behavior
                setTimeout(() => {
                    testRemoveBlock('middle');
                    log('‚úÖ Time preservation test completed');
                }, 500);
                
                updateStatus();
            } catch (error) {
                log(`‚ùå Time preservation test error: ${error.message}`);
            }
        }

        function testGapIndicators() {
            if (!frameWindow) {
                log('‚ùå Frame window not available');
                return;
            }

            try {
                const gapIndicators = frameWindow.document.querySelectorAll('.program-slot.empty');
                const plusButtons = Array.from(gapIndicators).filter(slot => slot.textContent === '+');
                
                log(`üîç Found ${plusButtons.length} gap indicators (+ buttons)`);
                
                plusButtons.forEach((button, index) => {
                    const left = parseFloat(button.style.left) || 0;
                    const width = parseFloat(button.style.width) || 0;
                    log(`  Gap ${index + 1}: left=${left.toFixed(2)}%, width=${width.toFixed(2)}%`);
                });
                
                log('‚úÖ Gap indicators test completed');
            } catch (error) {
                log(`‚ùå Gap indicators test error: ${error.message}`);
            }
        }

        function testOverlapPrevention() {
            if (!frameWindow || !frameWindow.genreChannelOverlapFix) {
                log('‚ùå Overlap fix not available');
                return;
            }

            try {
                log('üîß Testing overlap prevention...');
                
                const result = frameWindow.genreChannelOverlapFix.test();
                log(`üìä Current state: ${result.blockCount} blocks, ${result.overlapCount} overlaps`);
                
                if (result.overlapCount > 0) {
                    log('üîß Overlaps detected, applying fixes...');
                    frameWindow.genreChannelOverlapFix.checkAndFixOverlaps();
                    log('‚úÖ Overlap fixes applied');
                } else {
                    log('‚úÖ No overlaps detected');
                }
                
                updateStatus();
            } catch (error) {
                log(`‚ùå Overlap prevention test error: ${error.message}`);
            }
        }
    </script>
</body>
</html> 