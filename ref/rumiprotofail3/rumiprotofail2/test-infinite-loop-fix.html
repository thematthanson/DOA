<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Loop Fix Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-danger { background: #dc3545; color: white; }
        
        button:hover {
            opacity: 0.8;
        }
        
        .iframe-container {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        iframe {
            width: 100%;
            height: 400px;
            border: none;
        }
        
        .log-container {
            background: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .status-display {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            margin: 10px 0;
        }
        
        .test-instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üîÑ Infinite Loop Fix Test</h1>
        <p>Testing that the infinite loop fix prevents overlap detection and fix systems from running during edit mode.</p>
        
        <div class="test-section">
            <h3>üéØ Test Controls</h3>
            <div class="controls">
                <button class="btn-primary" onclick="testEditGenreFlow()">üé≠ Test Edit Genre Flow</button>
                <button class="btn-success" onclick="checkOverlapSystems()">üîç Check Overlap Systems</button>
                <button class="btn-warning" onclick="monitorConsole()">üìä Monitor Console</button>
                <button class="btn-danger" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
            </div>
        </div>
        
        <div class="test-section">
            <h3>üì∫ Genre Channel Test</h3>
            <div class="iframe-container">
                <iframe id="genreChannelFrame" src="Genre-channel_v2.html"></iframe>
            </div>
        </div>
        
        <div class="test-section">
            <h3>üìä Status Display</h3>
            <div class="status-display" id="statusDisplay">
                Waiting for test...
            </div>
        </div>
        
        <div class="test-section">
            <h3>üìù Test Logs</h3>
            <div class="log-container" id="logContainer">
                <div>üîÑ Infinite Loop Fix Test initialized...</div>
            </div>
        </div>
        
        <div class="test-section">
            <h3>üí° Test Instructions</h3>
            <div class="test-instructions">
                <strong>How to test the infinite loop fix:</strong><br>
                1. Click "Test Edit Genre Flow" to simulate the edit genre button workflow<br>
                2. Click "Check Overlap Systems" to verify overlap systems are disabled during edit mode<br>
                3. Click "Monitor Console" to watch for any infinite loop indicators<br>
                4. The edit genre flow should complete without any overlap fix loops<br>
                5. Overlap systems should be disabled during edit mode and re-enabled after
            </div>
        </div>
        
        <div class="test-section">
            <h3>‚úÖ Expected Behavior</h3>
            <div class="success">
                <strong>What should happen:</strong><br>
                ‚Ä¢ Edit mode should disable overlap detector and overlap fix systems<br>
                ‚Ä¢ No "üîß Applied overlap fix" messages during edit mode<br>
                ‚Ä¢ Edit genre flow should complete successfully<br>
                ‚Ä¢ Overlap systems should be re-enabled after edit mode completes<br>
                ‚Ä¢ No infinite loops or browser hanging
            </div>
        </div>
        
        <div class="test-section">
            <h3>‚ö†Ô∏è What to Watch For</h3>
            <div class="warning">
                <strong>Infinite loop indicators:</strong><br>
                ‚Ä¢ Repeated "üîß Applied overlap fix" messages in quick succession<br>
                ‚Ä¢ Browser becoming unresponsive<br>
                ‚Ä¢ Console errors about maximum call stack size<br>
                ‚Ä¢ Overlap systems not being disabled during edit mode<br>
                ‚Ä¢ Edit mode not completing properly
            </div>
        </div>
    </div>

    <script>
        let frameWindow;
        let logContainer;
        let statusDisplay;
        let consoleMonitorInterval;
        let lastConsoleLength = 0;
        let overlapFixCount = 0;
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            logContainer = document.getElementById('logContainer');
            statusDisplay = document.getElementById('statusDisplay');
            
            // Wait for iframe to load
            const iframe = document.getElementById('genreChannelFrame');
            iframe.onload = () => {
                frameWindow = iframe.contentWindow;
                log('‚úÖ Genre Channel iframe loaded');
                
                // Wait a bit for the channel to initialize
                setTimeout(() => {
                    testEditGenreFlow();
                }, 2000);
            };
            
            log('üîÑ Infinite Loop Fix Test initialized');
        });
        
        // Logging function
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Test the edit genre flow
        function testEditGenreFlow() {
            if (!frameWindow) {
                log('‚ùå Frame not available');
                return;
            }
            
            log('üé≠ Testing edit genre flow...');
            
            // Check overlap systems before edit mode
            checkOverlapSystems();
            
            // Simulate clicking the edit genre button
            const editLink = frameWindow.document.querySelector('.edit-link');
            if (editLink) {
                log('‚úÖ Found edit genre button, clicking it...');
                editLink.click();
                
                // Wait for edit mode to open
                setTimeout(() => {
                    log('üìã Edit mode should be open now');
                    
                    // Check if edit mode is active and overlap systems are disabled
                    const isEditMode = frameWindow.window.isInEditMode;
                    log(`üé≠ Edit mode flag: ${isEditMode}`);
                    
                    // Check overlap systems during edit mode
                    setTimeout(() => {
                        checkOverlapSystems();
                        
                        // Simulate selecting a genre and auto-populating
                        setTimeout(() => {
                            simulateGenreSelection();
                        }, 1000);
                    }, 1000);
                    
                }, 1000);
            } else {
                log('‚ùå Edit genre button not found');
            }
        }
        
        // Simulate genre selection and auto-population
        function simulateGenreSelection() {
            if (!frameWindow) {
                log('‚ùå Frame not available');
                return;
            }
            
            log('üé≠ Simulating genre selection...');
            
            // Find the genre select dropdown in edit mode
            const genreSelect = frameWindow.document.getElementById('genre-select-submenu');
            if (genreSelect) {
                log('‚úÖ Found genre select dropdown');
                
                // Select a genre
                genreSelect.value = 'Action';
                log('üé¨ Selected Action genre');
                
                // Trigger the change event
                const changeEvent = new Event('change', { bubbles: true });
                genreSelect.dispatchEvent(changeEvent);
                
                // Wait a bit, then trigger auto-populate
                setTimeout(() => {
                    log('üì∫ Triggering auto-populate...');
                    
                    // Find and click the auto-populate button
                    const autoPopulateBtn = frameWindow.document.querySelector('button[onclick*="autoPopulate"]');
                    if (autoPopulateBtn) {
                        autoPopulateBtn.click();
                        log('‚úÖ Clicked auto-populate button');
                        
                        // Monitor for completion
                        setTimeout(() => {
                            checkEditGenreCompletion();
                        }, 3000);
                    } else {
                        log('‚ùå Auto-populate button not found');
                    }
                }, 1000);
            } else {
                log('‚ùå Genre select dropdown not found');
            }
        }
        
        // Check if edit genre flow completed successfully
        function checkEditGenreCompletion() {
            if (!frameWindow) {
                log('‚ùå Frame not available');
                return;
            }
            
            log('üîç Checking edit genre completion...');
            
            // Check if edit mode is closed
            const isEditMode = frameWindow.window.isInEditMode;
            const editModeActive = frameWindow.document.querySelector('.edit-mode');
            const blocks = frameWindow.document.querySelectorAll('.program-slot:not(.empty)');
            
            log(`üé≠ Edit mode flag: ${isEditMode}`);
            log(`üìã Edit mode active: ${!!editModeActive}`);
            log(`üì¶ Blocks created: ${blocks.length}`);
            
            // Check overlap systems after edit mode
            setTimeout(() => {
                checkOverlapSystems();
                
                if (!isEditMode && !editModeActive && blocks.length > 0) {
                    log('‚úÖ Edit genre flow completed successfully!');
                    statusDisplay.innerHTML = '<strong style="color: green;">‚úÖ Edit genre flow completed successfully!</strong><br>No infinite loops detected.';
                } else {
                    log('‚ö†Ô∏è Edit genre flow may not have completed properly');
                    statusDisplay.innerHTML = '<strong style="color: orange;">‚ö†Ô∏è Edit genre flow may not have completed properly</strong>';
                }
            }, 1000);
        }
        
        // Check overlap systems status
        function checkOverlapSystems() {
            if (!frameWindow) {
                log('‚ùå Frame not available');
                return;
            }
            
            log('üîç Checking overlap systems status...');
            
            // Check overlap detector
            const overlapDetector = frameWindow.window.overlapDetector;
            if (overlapDetector) {
                log(`üîç Overlap Detector active: ${overlapDetector.isActive}`);
                log(`üîç Overlap Detector permanently disabled: ${overlapDetector.permanentlyDisabled}`);
            } else {
                log('‚ùå Overlap Detector not found');
            }
            
            // Check overlap fix
            const overlapFix = frameWindow.window.overlapFix;
            if (overlapFix) {
                log(`üîß Overlap Fix enabled: ${overlapFix.isEnabled}`);
            } else {
                log('‚ùå Overlap Fix not found');
            }
            
            // Check edit mode flag
            const isEditMode = frameWindow.window.isInEditMode;
            log(`üé≠ Edit mode flag: ${isEditMode}`);
            
            // Determine if systems should be disabled
            if (isEditMode) {
                if ((overlapDetector && !overlapDetector.isActive) || overlapDetector?.permanentlyDisabled) {
                    log('‚úÖ Overlap Detector properly disabled during edit mode');
                } else {
                    log('‚ö†Ô∏è Overlap Detector should be disabled during edit mode');
                }
                
                if (overlapFix && !overlapFix.isEnabled) {
                    log('‚úÖ Overlap Fix properly disabled during edit mode');
                } else {
                    log('‚ö†Ô∏è Overlap Fix should be disabled during edit mode');
                }
            } else {
                if (overlapDetector && overlapDetector.isActive && !overlapDetector.permanentlyDisabled) {
                    log('‚úÖ Overlap Detector properly enabled after edit mode');
                } else {
                    log('‚ö†Ô∏è Overlap Detector should be enabled after edit mode');
                }
                
                if (overlapFix && overlapFix.isEnabled) {
                    log('‚úÖ Overlap Fix properly enabled after edit mode');
                } else {
                    log('‚ö†Ô∏è Overlap Fix should be enabled after edit mode');
                }
            }
        }
        
        // Monitor console for overlap fix messages
        function monitorConsole() {
            if (!frameWindow) {
                log('‚ùå Frame not available');
                return;
            }
            
            log('üìä Starting console monitoring...');
            
            // Override console.log to capture messages
            const originalLog = frameWindow.console.log;
            frameWindow.console.log = function(...args) {
                const message = args.join(' ');
                if (message.includes('üîß Applied overlap fix')) {
                    overlapFixCount++;
                    log(`‚ö†Ô∏è Overlap fix applied (count: ${overlapFixCount}): ${message}`);
                }
                originalLog.apply(frameWindow.console, args);
            };
            
            // Monitor for 10 seconds
            setTimeout(() => {
                log(`üìä Console monitoring complete. Overlap fixes detected: ${overlapFixCount}`);
                if (overlapFixCount > 10) {
                    log('‚ö†Ô∏è WARNING: High number of overlap fixes detected - possible infinite loop!');
                    statusDisplay.innerHTML = '<strong style="color: red;">‚ö†Ô∏è WARNING: Possible infinite loop detected!</strong>';
                } else if (overlapFixCount === 0) {
                    log('‚úÖ No overlap fixes detected - good!');
                    statusDisplay.innerHTML = '<strong style="color: green;">‚úÖ No overlap fixes detected - good!</strong>';
                } else {
                    log('‚ö†Ô∏è Some overlap fixes detected - monitor for patterns');
                    statusDisplay.innerHTML = '<strong style="color: orange;">‚ö†Ô∏è Some overlap fixes detected - monitor for patterns</strong>';
                }
                
                // Restore original console.log
                frameWindow.console.log = originalLog;
            }, 10000);
        }
        
        // Clear logs
        function clearLogs() {
            logContainer.innerHTML = '<div>üîÑ Infinite Loop Fix Test initialized...</div>';
            statusDisplay.innerHTML = 'Waiting for test...';
            overlapFixCount = 0;
            log('üóëÔ∏è Logs cleared');
        }
    </script>
</body>
</html> 