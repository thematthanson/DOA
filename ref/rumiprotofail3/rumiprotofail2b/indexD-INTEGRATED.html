<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumi Extension - Beta V0</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=SF+Mono:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #111;
            color: #fff;
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 50px;
            min-height: 100vh;
        }

        .simulation-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .entry-point-panel {
            width: 220px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .entry-point-header {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }

        .stream-detector {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stream-detector:hover {
            border-color: #00ff41;
            background: #2a2a2a;
        }

        .stream-detector .status {
            font-size: 14px;
            color: #00ff41;
            font-weight: bold;
        }

        .stream-detector .subtext {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .automode-button {
            background: linear-gradient(135deg, #a985ff, #8e6ee6);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .automode-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(169, 133, 255, 0.3);
        }

        .holistic-panel {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .holistic-section {
            width: 100%;
        }

        #holistic-show-info {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        #holistic-animation pre {
            margin: 0;
            padding: 0;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
        }

        #holistic-animation pre.automode {
            color: #ffff00 !important;
        }

        #holistic-progress {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
        }

        .settings-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .message-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 8px;
            transition: all 0.2s ease;
        }

        .message-button:hover {
            background: #333;
            border-color: #666;
            color: #fff;
        }

        .message-button.primary {
            background: #00ff41;
            border-color: #00ff41;
            color: #000;
        }

        .message-button.primary:hover {
            background: #00cc33;
            border-color: #00cc33;
        }

        .inline-resume-button {
            background: #2a2a2a;
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-resume-button:hover {
            background: #333;
            border-color: #00cc33;
            color: #00cc33;
        }

        .inline-end-session-button {
            background: #2a2a2a;
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-end-session-button:hover {
            background: #333;
            border-color: #ff6666;
            color: #ff6666;
        }

        .channel-switcher {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .channel-switcher:hover {
            border-color: #00ff41;
            color: #00ff41;
        }

        .channel-switcher.active {
            background: #00ff41;
            color: #000;
            border-color: #00ff41;
        }

        .popup-balance {
            font-size: 11px;
            color: #666;
        }

        /* Message Area */
        .message-area {
            background: #2a2a2a; /* Darker grey background */
            color: #cccccc; /* Light grey text */
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            max-height: 46px;
            overflow: hidden;
            transition: all 0.3s ease;
            border-radius: 8px; /* Rounded corners to match extension */
        }

        .message-area.error {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff0000; /* Red text for terminal errors */
        }

        .message-area.warning {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff6600; /* Orange text for non-terminal warnings */
        }

        .message-area.info {
            background: #2a2a2a; /* Same darker grey as default */
            color: #8b5cf6; /* Purple text for settings */
        }

        .message-area.collapsed {
            padding: 6px 18px;
            font-size: 12px;
        }

        .message-area.expanded {
            max-height: none;
            padding: 14px 18px;
            font-size: 14px;
        }

        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }

        .collapsed .collapse-icon {
            transform: rotate(180deg);
        }

        /* Popup Body */
        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        /* Points Section */
        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: none;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .primary-cta.automode {
            background: linear-gradient(135deg, #ffff00, #ffaa00);
            color: #000;
            border-color: #ffaa00;
        }

        .primary-cta.automode:hover {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            color: #000;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        .cta-subtitle {
            font-size: 12px;
            color: #888;
            margin-bottom: 16px;
            text-align: center;
        }

        /* Queue Section */
        .queue-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .queue-header {
            padding: 8px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .queue-item {
            padding: 6px 12px;
            border-bottom: 1px solid #333;
            font-size: 10px;
        }

        .queue-item:last-child {
            border-bottom: none;
        }

        .queue-item.next {
            background: #1a1000;
            border-left: 3px solid #ffaa00;
        }

        /* Responsive Breakpoints */
        @media (max-height: 600px) {
            .extension-popup {
                height: 450px;
            }
        }

        @media (max-height: 450px) {
            .extension-popup {
                height: 350px;
            }
        }

        @media (max-height: 350px) {
            .extension-popup {
                height: 250px;
            }
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00ff41;
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 10000;
            min-width: 200px;
            display: none; /* Hidden by default */
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-trigger {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            color: #666;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 8px;
            cursor: pointer;
            z-index: 9999;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .debug-trigger:hover {
            border-color: #00ff41;
            color: #00ff41;
            opacity: 1;
        }

        .debug-panel-header {
            color: #00ff41;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .debug-panel-toggle {
            background: none;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-panel-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section {
            margin-bottom: 8px;
            border-top: 1px solid #333;
            padding-top: 8px;
        }

        .debug-section:first-child {
            border-top: none;
            padding-top: 0;
        }

        .debug-section-header {
            color: #888;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-section-toggle {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 10px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .debug-section-content.collapsed {
            max-height: 0;
        }

        .debug-button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 2px;
            font-size: 9px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
        }

        .debug-button.error {
            background: #ff4444;
            color: #fff;
        }

        .debug-button.warning {
            background: #ffaa00;
            color: #000;
        }

        .debug-button.info {
            background: #a985ff;
            color: #000;
        }

        .debug-button.blue {
            background: #0088ff;
            color: #fff;
        }

        .debug-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .debug-button.cooldown {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Progress Bars */
        .progress-bars {
            display: flex;
            gap: 2px;
            height: 28px;
            margin: 8px 0;
            position: relative;
        }

        .progress-bar {
            border-radius: 2px;
        }

        /* Stop Button Styles */
        .primary-cta.stop {
            background: #000000;
            color: #00ff41;
            border: 2px solid #00ff41;
        }

        .primary-cta.stop:hover {
            background: #00ff41;
            color: #000000;
        }

        /* Leaderboard Section */
        .leaderboard-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .leaderboard-section:hover {
            border-color: #555;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
        }

        .leaderboard-header .title {
            color: #00ff41;
            font-weight: 600;
            text-transform: uppercase;
        }

        .leaderboard-header .user-rank {
            color: #00ff41;
        }

        .leaderboard-expand-icon {
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #666;
        }

        .leaderboard-section.is-expanded .leaderboard-expand-icon {
            transform: rotate(180deg);
        }

        .leaderboard-full-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            margin-top: 0;
            border-top: none;
            font-size: 9px;
        }

        .leaderboard-section.is-expanded .leaderboard-full-list {
            max-height: 200px; /* Adjust as needed */
            padding-top: 8px;
            margin-top: 8px;
            border-top: 1px solid #333;
        }

        /* Error States */
        .error-state {
            display: none;
        }

        .error-content {
            padding: 12px;
        }

        .status-indicator-terminal {
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 12px;
            margin: 15px 0;
            border: 2px solid;
            background: #111111;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
        }

        .status-indicator-terminal.warning {
            border-color: #ffaa00;
            color: #ffaa00;
            background: #1a1000;
        }

        .status-indicator-terminal.error {
            border-color: #ff4444;
            color: #ff4444;
            background: #1a0000;
        }

        /* Pulse animation for loading */
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .pulse { 
            animation: pulse 1.5s infinite; 
        }

        /* Indexing Details Section */
        .indexing-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 15px;
            padding: 0 5px;
        }

        .indexing-progress-bar-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 80px;
            margin-bottom: 15px;
            gap: 2px;
        }

        .progress-bar-segment {
            background-color: #4CAF50;
            width: 12px;
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .progress-bar-segment.grey {
            background-color: #444;
        }

        .progress-bar-divider {
            width: 1px;
            height: 60%;
            background: #555;
            margin: 0 5px;
        }

        .progress-bar-annotation {
            color: #fff;
            font-size: 8px;
            text-align: center;
            line-height: 1.1;
        }
        
        .progress-bar-segment.special-segment {
            width: 30px;
            height: 90%;
            background-color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
        }

        .progress-bar-annotation.top-annotation {
            color: #fff;
        }

        .progress-bar-annotation.bottom-annotation {
            color: #888;
        }

        .indexing-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .now-playing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .now-playing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .stats-info {
            text-align: right;
        }

        .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        /* Remove old separated layout styles */
        .now-next-container, .now-playing-card, .next-up-card, .reward-info, .progress-time {
            all: unset; /* Reset properties from old layout */
        }
        
        .card-header span:nth-child(2) {
            margin: 0 4px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        /* New Indexing UI */
        .indexing-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .indexing-content .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        .indexing-content .indexing-info {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
            margin-bottom: 10px;
        }

        .indexing-content .indexing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .indexing-content .indexing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .indexing-content .stats-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 10px;
        }

        .indexing-content .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .indexing-content .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }

        /* New Horizontal Progress Bar */
        .horizontal-progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .horizontal-progress-bar-fill {
            height: 100%;
            background: #00ff41;
            transition: width 0.5s ease;
        }

        /* New Flippable Card */
        .card-flipper {
            perspective: 1000px;
            width: 100%;
            height: 100px;
            position: relative;
        }

        .card-flipper .card {
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            position: absolute;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card-flipper .card.front {
            transform: rotateY(0deg);
        }

        .card-flipper .card.back {
            transform: rotateY(180deg);
        }

        .card-flipper.is-flipped .card.front {
            transform: rotateY(-180deg);
        }

        .card-flipper.is-flipped .card.back {
            transform: rotateY(0deg);
        }

        .card-flipper .card-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .card-flipper .card-content .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-flipper .card-content .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .card-flipper .card-content .flip-button {
            background: transparent;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        /* Indexing Details Section */
        .nokia-section {
            background: #080808;
            border-radius: 8px;
            padding: 15px;
        }

        .indexing-window, .session-stats-panel {
            background: #111;
            border: 1px solid #333;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-shadow: 0 0 2px #00ff41;
        }
        
        .indexing-window pre, .session-stats-panel pre {
            margin: 0;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
            color: #00ff41;
            font-weight: bold;
        }
        
        .bonus-glint {
            color: #a985ff;
            font-weight: 700;
        }
        
        .now-playing-section {
            background: #1c1c1c;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
        }

        .now-playing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-title {
            font-size: 15px;
            font-weight: 600;
        }

        .show-queue-button {
            width: 100%;
            background: #2a2a2a;
            color: #a985ff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
            text-align: center;
        }
        
        .queue-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            border-top: 1px solid #333;
        }

        .queue-details.is-expanded {
            max-height: 200px;
            padding-top: 10px;
            margin-top: 10px;
        }

        .queue-item {
            font-size: 12px;
            color: #ccc;
            padding: 4px 0;
        }

        /* Settings View */
        .settings-section {
            background: #1c1c1c;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .settings-section-header {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .settings-item:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            color: #ccc;
        }

        .settings-value {
            color: #00ff41;
            font-weight: 600;
        }

        .settings-logout-button {
            width: 100%;
            background: #4d0000;
            color: #ff4444;
            border: 1px solid #ff4444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
        }

        /* Toggle Switch CSS */
        .switch {
          position: relative;
          display: inline-block;
          width: 34px;
          height: 20px;
        }

        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #333;
          transition: .4s;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 14px;
          width: 14px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          transition: .4s;
        }

        input:checked + .slider {
          background-color: #00ff41;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #00ff41;
        }

        input:checked + .slider:before {
          transform: translateX(14px);
        }

        .slider.round {
          border-radius: 20px;
        }

        .slider.round:before {
          border-radius: 50%;
        }

        /* Remove ALL old layout styles */
        .points-and-progress, .nokia-visualizer, .horizontal-progress-bar-container, .horizontal-progress-bar,
        .indexing-info, .now-playing-info, .stats-info, .card-flipper, .card-front, .card-back, .card-footer, .now-next-container,
        .now-playing-card, .next-up-card, .reward-info, .progress-time, .top-stats, .bottom-stats {
            all: unset;
        }

        /* Bonus Glint Animation */
        .bonus-glint {
            color: #ffaa00;
            animation: glint 2s ease-in-out infinite;
        }

        @keyframes glint {
            0%, 100% { 
                opacity: 0.3; 
                color: #ffaa00;
            }
            50% { 
                opacity: 1; 
                color: #ffdd00;
                text-shadow: 0 0 4px #ffaa00;
            }
        }

        /* Smooth animation transitions */
        .indexing-window pre {
            transition: all 0.1s ease-out;
        }

        .session-stats-panel pre {
            transition: all 0.2s ease-out;
        }

        /* NEW: Styles for channel view to be flexible */
        #channels-view .popup-body {
            height: 100%;
        }

        .extension-popup {
            width: 700px;
            margin: 0 auto;
            background-color: #0d0d0d;
            border: none;
            border-radius: 12px;
            overflow: hidden;
            display: none;
            flex-direction: column;
            align-items: stretch;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            position: relative;
        }

        .popup-header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1100;
        }

        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            width: 100%;
            box-sizing: border-box;
        }

        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 20px;
            /* border: 2px solid #00ff41; */
            width: 100%;
            box-sizing: border-box;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .primary-cta.automode {
            background: linear-gradient(135deg, #ffff00, #ffaa00);
            color: #000;
            border-color: #ffaa00;
        }

        .primary-cta.automode:hover {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            color: #000;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        /* Expandable Sections */
        .expandable-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            background: #111111;
            border: 1px solid #333333;
            margin: 8px 0;
        }

        .expandable-section.expanded {
            max-height: 800px; /* Increased to accommodate comprehensive settings content */
        }

        .expandable-content {
            padding: 12px;
            font-size: 10px;
            line-height: 1.4;
        }

        .expandable-title {
            font-size: 11px;
            font-weight: 600;
            color: #00ff41;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Paused State Styles */
        .paused .points-total,
        .paused .points-pending,
        .paused .holistic-progress,
        .paused .animation-panel-content,
        .paused .nokia-visual,
        .paused .progress-bar-segment,
        .paused .horizontal-progress-bar-fill,
        .paused .holistic-show-info,
        .paused .holistic-section,
        .paused .holistic-panel,
        .paused #animation-panel-content,
        .paused #holistic-show-info,
        .paused #holistic-progress,
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .primary-cta,
        .paused .secondary-button,
        .paused .channel-switcher,
        .paused .expandable-section,
        .paused .expandable-content,
        .paused .leaderboard-section,
        .paused .leaderboard-header,
        .paused .queue-item,
        .paused .settings-section,
        .paused .settings-item,
        .paused .settings-label,
        .paused .settings-value,
        .paused .popup-header,
        .paused .popup-body,
        .paused .points-section,
        .paused .points-header,
        .paused .nokia-section,
        .paused .holistic-panel,
        .paused .holistic-section,
        .paused .holistic-show-info,
        .paused .holistic-animation,
        .paused .holistic-progress,
        .paused .detected-show-ui-indexing,
        .paused .expandable-channel-section-indexing,
        .paused .expand-channel-header-indexing,
        .paused .channel-iframe-container-indexing {
            color: #888 !important;
            opacity: 0.6;
        }

        /* Paused state for buttons - change border colors too */
        .paused .primary-cta,
        .paused .secondary-button {
            border-color: #666 !important;
            color: #888 !important;
            opacity: 0.6;
        }

        /* Stronger specificity for points display */
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .points-total,
        .paused .points-pending {
            color: #888 !important;
            opacity: 0.6 !important;
        }

        .paused .progress-bar-segment {
            background-color: #666 !important;
        }

        .paused .horizontal-progress-bar-fill {
            background: #666 !important;
        }

        .paused .nokia-visual {
            border-color: #666 !important;
            color: #666 !important;
        }

        .paused .animation-panel-content {
            animation-play-state: paused !important;
        }

        /* Pause indicator */
        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 10;
            display: none;
        }

        .paused .pause-indicator {
            display: block;
        }

        /* Activation step styles */
        .extension-popup.deactivated {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        .activation-circle {
            position: fixed;
            top: calc(50% - 350px); /* higher above the popup */
            left: 50%;
            transform: translate(-50%, 0);
            width: 56px;
            height: 56px;
            border: 4px solid #0066ff;
            border-radius: 50%;
            background: #fff; /* white background for contrast */
            cursor: pointer;
            z-index: 99999;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 0 0 4px rgba(0,102,255,0.08);
            transition: all 0.3s ease;
            display: none; /* Temporarily hidden for testing */
        }

        .activation-circle:hover {
            border-color: #0099ff;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.5);
        }

        .activation-circle.activated {
            background: #0066ff;
            border-color: #0066ff;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.8);
        }

        .activation-circle.activated::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        /* Specific styling for stop indexing button - highest specificity */
        #stop-indexing-button {
            background: linear-gradient(135deg, #ffff00, #ffaa00) !important;
            color: #000 !important;
            border-color: #ffaa00 !important;
        }

        #stop-indexing-button:hover {
            background: linear-gradient(135deg, #ffaa00, #ff8800) !important;
            color: #000 !important;
        }
    </style>

        <script>
        // RUMI Feature Flag System for Safe Integration
        window.RUMI_INTEGRATION = {
            featureFlags: {
                USE_OPTIMIZED_GENRE_CHANNEL: false, // Start with current version
                ENABLE_MONITORING: true,
                ENABLE_ROLLBACK: true
            },
            
            // Load feature flags from file
            loadFeatureFlags: function() {
                try {
                    const flags = JSON.parse(localStorage.getItem('rumi_feature_flags') || '{}');
                    this.featureFlags = { ...this.featureFlags, ...flags };
                    console.log('🚩 RUMI Feature Flags loaded:', this.featureFlags);
                } catch (error) {
                    console.warn('⚠️ Could not load feature flags:', error);
                }
            },
            
            // Get the appropriate channel URL based on feature flags
            getChannelUrl: function() {
                if (this.featureFlags.USE_OPTIMIZED_GENRE_CHANNEL) {
                    console.log('🎯 Using optimized genre channel');
                    return 'Genre-channel_v2-INTEGRATED.html';
                } else {
                    console.log('📺 Using current genre channel');
                    return 'Genre-channel_v2.html';
                }
            },
            
            // Update channel frames to use the appropriate version
            updateChannelFrames: function() {
                const channelUrl = this.getChannelUrl();
                
                // Update main channel frame
                const channelFrame = document.getElementById('channel-frame');
                if (channelFrame && channelFrame.src !== channelUrl) {
                    console.log('🔄 Updating main channel frame to:', channelUrl);
                    channelFrame.src = channelUrl;
                }
                
                // Update indexing channel frame
                const channelFrameIndexing = document.getElementById('detection-channel-frame-indexing');
                if (channelFrameIndexing && channelFrameIndexing.src !== channelUrl) {
                    console.log('🔄 Updating indexing channel frame to:', channelUrl);
                    channelFrameIndexing.src = channelUrl;
                }
            },
            
            // Toggle between versions
            toggleOptimizedChannel: function(enable) {
                this.featureFlags.USE_OPTIMIZED_GENRE_CHANNEL = enable;
                localStorage.setItem('rumi_feature_flags', JSON.stringify(this.featureFlags));
                this.updateChannelFrames();
                console.log('🚩 Optimized channel:', enable ? 'ENABLED' : 'DISABLED');
            },
            
            // Initialize the integration
            init: function() {
                this.loadFeatureFlags();
                this.updateChannelFrames();
                
                // Listen for feature flag messages from iframes
                window.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'rumi:featureFlagsLoaded') {
                        console.log('📡 Feature flags loaded in iframe:', event.data.flags);
                    }
                });
                
                console.log('🎯 RUMI Integration initialized');
            }
        };
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                window.RUMI_INTEGRATION.init();
            });
        } else {
            window.RUMI_INTEGRATION.init();
        }
        </script>
        
</head>
<body>
    <!-- Activation Circle (completely outside the popup) -->
    <div class="activation-circle" id="activation-circle" onclick="activateExtension()">
        <div style="position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 8px; white-space: nowrap; color: #ccc; font-size: 12px; text-align: center;">
            ← click to enable extension
        </div>
    </div>

    <!-- Debug Trigger -->
    <div class="debug-trigger" onclick="toggleDebugPanel()" title="Debug Panel (Ctrl+Shift+D)">
        Debug
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-panel-header" onclick="toggleDebugPanel()">
            <span>Rumi Debug</span>
            <button class="debug-panel-toggle" id="debug-panel-toggle">▼</button>
        </div>
        
        <div class="debug-panel-content" id="debug-panel-content">
            <!-- Basic Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('basic-testing')">
                    <span>Basic Testing</span>
                    <button class="debug-section-toggle" id="basic-testing-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="basic-testing-content">
        <button class="debug-button" onclick="Tracker.showDebugOverlay()">Show Tracker</button>
        <!-- <button class="debug-button" onclick="testHomeScreen()">Test Home</button> -->
        <!-- <button class="debug-button" onclick="testChannels()">Test Channels</button> -->
        <!-- <button class="debug-button" onclick="testReceipt()">Test Receipt</button> -->
        <button class="debug-button" onclick="showState()">Show State</button>
        <!-- <button class="debug-button info" onclick="testShowDetection()">Test Show Detection</button> -->
        <!-- <button class="debug-button info" onclick="debugChannelState()">Debug Channel State</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelContent()">Check Genre Channel Content</button> -->
        <!-- <button class="debug-button info" onclick="testPlanetEarthDetection()">Test Planet Earth II</button> -->
        <!-- <button class="debug-button info" onclick="testMessagePassing()">Test Message Passing</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelLoaded()">Check Channel Loaded</button> -->
                </div>
            </div>

            <!-- Error Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('error-testing')">
                    <span>Error Testing</span>
                    <button class="debug-section-toggle" id="error-testing-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="error-testing-content">
                    <button class="debug-button warning" onclick="testVolumeError()">Volume Error</button>
                    <button class="debug-button warning" onclick="testSpeedError()">Speed Error</button>
                    <button class="debug-button warning" onclick="testLanguageError()">Language Error</button>
                    <button class="debug-button error" onclick="testSystemError()">System Error</button>
                    <button class="debug-button error" onclick="testNetworkError()">Network Error</button>
                    <button class="debug-button error" onclick="testBrowserError()">Browser Error</button>
                    <button class="debug-button blue" onclick="testShowInterrupt()">Show Interrupt</button>
                </div>
            </div>

            <!-- Session Management Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('session-management')">
                    <span>Session Management</span>
                    <button class="debug-section-toggle" id="session-management-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="session-management-content">
                    <!-- Core Session Controls -->
                    <button class="debug-button info" id="debug-ludicrous-mode-btn" onclick="toggleLudicrousMode()">⚡ LUDICROUS SPEED (300x)</button>
                    
                    <!-- Channel & Content Testing (Hidden) -->
                    <!-- <button class="debug-button info" onclick="testChannelVisibility()">🔍 Test Channel Visibility</button> -->
                    <!-- <button class="debug-button info" onclick="testShowSelection()">📺 Test Show Selection</button> -->
                    <!-- <button class="debug-button info" onclick="testLudicrousMode()">⚡ Test Ludicrous Mode</button> -->
                    <!-- <button class="debug-button info" onclick="testBackendGenreAutopopulation()">Test Backend Genre Autopop</button> -->
                    <!-- <button class="debug-button info" onclick="testGenreChannelPopulation()">Test Genre Channel Population</button> -->
                    
                    <!-- Debug & Reset (Hidden) -->
                    <!-- <button class="debug-button warning" onclick="debugShowDetectionState()">Debug Show Detection</button> -->
                    <!-- <button class="debug-button warning" onclick="debugChannelContent()">Debug Channel Content</button> -->
                    <!-- <button class="debug-button danger" onclick="debugResetShowDetection()">Reset Show Detection</button> -->
                </div>
            </div>



            <!-- NEW: Breakpoint Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header">
                    <span>Breakpoint Testing</span>
                    <button class="debug-section-toggle" id="breakpoint-testing-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="breakpoint-testing-content">
                    <button class="debug-button info" onclick="setViewportHeight(400)">📱 Very Short (400px)</button>
                    <button class="debug-button info" onclick="setViewportHeight(600)">📱 Short (600px)</button>
                    <button class="debug-button" onclick="setViewportHeight(800)">💻 Standard (800px)</button>
                    <button class="debug-button info" onclick="setViewportHeight(1100)">🖥️ Tall (1100px)</button>
                    <button class="debug-button warning" onclick="resetViewportHeight()">🔄 Reset to Natural</button>
                    <button class="debug-button blue" onclick="testAllBreakpoints()">🧪 Test All Breakpoints</button>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div class="simulation-container">
        <div class="entry-point-panel">
            <div class="entry-point-header">SIMULATED ENTRY POINTS</div>
            <div id="stream-detector-entry" class="stream-detector">
                <!-- Content will be populated by JS -->
            </div>
            <div style="margin-bottom: 10px;">
                <button class="automode-button" onclick="launchWithAutomode()">
                    AUTOMODE
                </button>
                <select id="bucket-select" onchange="changeBucket(this.value)" style="background: #1a1a1a; border: 1px solid #333; color: #ccc; padding: 6px 10px; border-radius: 4px; font-size: 11px; width: 100%; margin-top: 8px;">
                    <option value="Content Intelligence">🧠 Content Intelligence</option>
                    <option value="Scene Description Pipeline">🎬 Scene Description Pipeline</option>
                    <option value="Story Tree">🌳 Story Tree</option>
                    <option value="Character Summaries">👥 Character Summaries</option>
                </select>
            </div>
            <button id="user-changes-content-btn" class="secondary-button" onclick="simulateShowChange()" style="display: none; margin-top: 10px;">
                User Changes Content
            </button>
            <button id="cache-control-btn" class="secondary-button" onclick="toggleCacheControl()" style="margin-top: 10px; background: #1a1a1a; border-color: #666; color: #ccc;">
                🗂️ Disable Cache
            </button>
            
            <!-- Developer Options -->
            <div style="margin-top: 20px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px;">
                <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">DEVELOPER OPTIONS</div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <input type="checkbox" id="cache-control-toggle" style="width: 14px; height: 14px;">
                    <label for="cache-control-toggle" style="font-size: 11px; color: #ccc; cursor: pointer;">Disable Browser Cache</label>
                </div>
                <div style="font-size: 9px; color: #888; line-height: 1.3;">
                    Forces browser to reload all files on each request. Useful for development and testing.
                </div>
            </div>
    </div>

        <!-- Extension Popup (centered, always one header at top) -->
    <div class="extension-popup" style="display: none;">
        <div class="popup-header">
            <div class="popup-logo">RUMI</div>
            <div class="header-controls">
                <button class="settings-button" onclick="testSettings()">⚙ SETTINGS</button>
            </div>
        </div>
        <!-- Receipt View (Initially Hidden) -->
        <div id="receipt-view" style="display: none;">
            <div class="popup-body">
                <div style="background: #0d0d0d; border: 1px solid #333; border-radius: 12px; padding: 20px; max-width: 520px; margin: 0 auto; box-sizing: border-box; width: 100%;">
                    <div style="text-align: center; margin-bottom: 12px;">
                        <div style="font-size: 14px; color: #888; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span>SESSION COMPLETED for</span>
                            <span style="font-size: 24px; font-weight: 700; color: #00ff41;" id="receipt-total-points">+0.00</span>
                            <span>POINTS</span>
                        </div>
                        <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span id="receipt-total-pending" style="font-size: 13px; color: #ffaa00; font-weight: 600;"></span>
                            <span>PENDING FROM TODAY</span>
            </div>
        </div>

                        <!-- Session Details -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">SESSION DETAILS</div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Duration:</span>
                                <span style="color: #fff;" id="receipt-duration">0:00</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Multiplier:</span>
                                <span style="color: #fff;" id="receipt-multiplier">1.0x</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Base Rate:</span>
                                <span style="color: #fff;">0.5 pts/5s</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; font-size: 11px;">
                                <span style="color: #888;">Bonus Applied:</span>
                                <span style="color: #ffaa00;" id="receipt-bonus">None</span>
                            </div>
                        </div>

                        <!-- Indexed Content Summary -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">INDEXED CONTENT</div>
                            
                            <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Content detected and processed during this session:</div>
                            
                            <div id="receipt-content-list" style="font-size: 10px; max-height: 120px; overflow-y: auto;">
                                <!-- --- Indexed Content View: Show actual indexed content with 3 visible lines and auto-scroll (ping-pong) ---
                                if (appState.indexedContent && appState.indexedContent.length > 0) {
                                    const indexed = appState.indexedContent;
                                    // Generate HTML for all items
                                    const contentHTML = indexed.map(item => `
                                        <div class="indexed-content-item" style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #1a1a1a; border-radius: 3px; height: 24px; align-items: center;">
                                            <span style="color: #fff;">${item.title}</span>
                                            <span style="color: #888;">${item.duration}m</span>
                                </div>
                                    `).join('');
                                    contentList.innerHTML = `<div id="indexed-content-scroll" style="overflow: hidden; height: 76px; position: relative;">${contentHTML}</div>`;
                                    // Animate auto-scroll if more than 3 items
                                    if (indexed.length > 3) {
                                        setTimeout(() => {
                                            const scrollDiv = document.getElementById('indexed-content-scroll');
                                            let scrollPos = 0;
                                            let direction = 1;
                                            const itemHeight = 28; // px (24px + 4px margin)
                                            const maxScroll = (indexed.length * itemHeight) - (3 * itemHeight);
                                            function scrollStep() {
                                                scrollPos += direction;
                                                if (scrollPos >= maxScroll) {
                                                    scrollPos = maxScroll;
                                                    direction = -1;
                                                } else if (scrollPos <= 0) {
                                                    scrollPos = 0;
                                                    direction = 1;
                                                }
                                                scrollDiv.scrollTop = scrollPos;
                                                requestAnimationFrame(scrollStep);
                                            }
                                            scrollStep();
                                        }, 500);
                                    }
                                    // Return early so the rest of the function doesn't overwrite this view
                                    return;
                                } -->
                            </div>
                        </div>

                        <!-- Next Steps -->
                        <div style="background: #1a1000; border: 1px solid #ffaa00; border-radius: 6px; padding: 12px; margin-bottom: 20px;">
                            <div style="font-size: 12px; color: #ffaa00; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">NEXT STEPS</div>
                            <div style="font-size: 11px; color: #ccc; line-height: 1.4;">
                                Your points are now pending validation. They will be added to your total balance within 24 hours. Continue indexing to earn more points!
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 8px; margin-top: 16px;">
                            <button class="primary-cta" onclick="returnToEntryPoint()" style="flex: 1; background: #222; color: #00ff41; border: 2px solid #00ff41;">
                                DONE
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main View -->
        <div id="main-view">
            <!-- Message Area -->
            <div class="message-area collapsed">
                    <span id="message-summary-text">System operational - Daily bonus in 2h 34m</span>
                    <div id="error-details"></div>
                    <!-- Expandable Error Details Section -->
                    <div class="expandable-section" id="error-details-section">
                        <div class="expandable-content">
                            <div class="expandable-title">ERROR DETAILS</div>
                            <div id="error-details-content">
                                <!-- Error details will be populated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Expandable Warning Details Section -->
                    <div class="expandable-section" id="warning-details-section">
                        <div class="expandable-content" id="warning-details-content">
                            <!-- Warning details will be populated here -->
                        </div>
                    </div>
                    <!-- Expandable Settings Panel Section -->
                    <div class="expandable-section" id="settings-panel-section">
                        <div class="expandable-content">
                            <div class="expandable-title">SETTINGS CONFIGURATION</div>
                            <div id="settings-panel-content">
                                <!-- Settings content will be populated here -->
                            </div>
                        </div>
                    </div>
            </div>

            <!-- Points Section -->
            <div class="points-section">
                <div style="text-align: center; margin-bottom: 12px;">
                        <div id="points-primary-display" class="points-total">4349 LIFETIME POINTS</div>
                        <div id="points-secondary-display" class="points-pending">+200 pending from today</div>
                </div>
                
                <!-- Dynamic Content: Changes based on indexing state -->
                <div id="dynamic-content">
                        <!-- NEW HOME CONTENT (replaces channel iframe) -->
                        <div id="home-content">
                            <!-- Section 2a: Content Detected Section -->
                            <div id="section-2a-content-detected" style="display: none;">
                                <!-- Start Watching Button -->
                                <div style="margin-top: 12px;">
                                    <button id="start-watching-button" class="primary-cta" onclick="startDetectionIndexing()">
                                        START WATCHING [Show] S[Season]E[Episode]
                                    </button>
                        </div>

                                <!-- Collapsible Genre Channel -->
                                <div id="expandable-channel-section" style="margin-top: 12px; display: none;">
                                    <div id="expand-channel-header" onclick="toggleChannelExpansion()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-channel-text" style="flex: none;">WHAT ARE WE LEARNING</span>
                                        <span id="expand-channel-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                </div>
                                    <!-- Channel Container (initially hidden) -->
                                    <div id="channel-expanded-container" style="display: none; margin-top: 4px;">
                                        <div id="channel-iframe-container" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="channel-loading" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Channel...</div>
                                            <iframe id="channel-frame" src="Genre-channel_v2.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onerror="showChannelError()"></iframe>
                                    </div>
                                    </div>
                                    </div>
                                        </div>

                            <!-- Section 2b: Automode Section -->
                            <div id="section-2b-automode" style="display: none;">
                                <!-- Start Learning Button -->
                                <div style="margin-top: 12px;">
                                    <button id="start-learning-button" class="primary-cta automode" onclick="startAutomodeIndexing()">
                                        START LEARNING [Rumi Category]
                                    </button>
                                    </div>

                                <!-- Collapsible Rumi Channel -->
                                <div id="expandable-rumi-channel-section" style="margin-top: 12px; display: none;">
                                    <div id="expand-rumi-channel-header" onclick="toggleRumiChannelExpansion()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-rumi-channel-text" style="flex: none;">WHAT ARE WE LEARNING</span>
                                        <span id="expand-rumi-channel-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                    </div>
                                    <!-- Rumi Channel Container (initially hidden) -->
                                    <div id="rumi-channel-expanded-container" style="display: none; margin-top: 4px;">
                                        <div id="rumi-channel-iframe-container" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="rumi-channel-loading" style="padding: 20px; text-align: center; color: #ffff00; font-size: 12px; z-index: 1; display: none;">Loading Rumi Channel...</div>
                                            <iframe id="rumi-channel-frame" src="rumi-channel.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onerror="showRumiChannelError()"></iframe>
                                </div>
                            </div>
                        </div>

                                <!-- Section 2b: 🧠 Real-time Learning Insights (Automode Only) -->
                                <div id="real-time-learning-insights" style="margin-top: 16px; display: none;">
                                    <div id="expand-learning-insights-header" onclick="toggleLearningInsightsExpansion()" style="display: flex; align-items: center; justify-content: center; background: #2a2a0a; color: #ffff00; border: 1px solid #ffff00; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-learning-insights-text" style="flex: none;">🧠 Real-time Learning Insights</span>
                                        <span id="expand-learning-insights-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                    </div>
                                    <!-- Learning Insights Container (initially hidden) -->
                                    <div id="learning-insights-expanded-container" style="display: none; margin-top: 4px;">
                                        <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 9px;">
                                                <div>
                                                    <div style="color: #ffaa00; font-weight: 600; margin-bottom: 4px;">Content Analysis</div>
                                                    <div style="color: #ccc; margin-bottom: 2px;">Patterns detected: <span style="color: #ffff00;">127</span></div>
                                                    <div style="color: #ccc; margin-bottom: 2px;">Genres identified: <span style="color: #ffff00;">8</span></div>
                                                    <div style="color: #ccc;">Accuracy improving: <span style="color: #ffff00;">+12%</span></div>
                                                </div>
                                                <div>
                                                    <div style="color: #ffaa00; font-weight: 600; margin-bottom: 4px;">Learning Progress</div>
                                                    <div style="color: #ccc; margin-bottom: 2px;">Neural connections: <span style="color: #ffff00;">2,847</span></div>
                                                    <div style="color: #ccc; margin-bottom: 2px;">Training samples: <span style="color: #ffff00;">1,203</span></div>
                                                    <div style="color: #ccc;">Model confidence: <span style="color: #ffff00;">87.3%</span></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>


                    </div>

                    <!-- Top Section: Points and Progress (shown when indexing) -->
                    <div id="nokia-content" class="nokia-section" style="display: none; position: relative;">
                        <!-- Pause indicator -->
                        <div class="pause-indicator">⏸️ INDEXING PAUSED</div>
                        
                        <!-- Section 1: Entry Points Panel (formerly Holistic Indexing Panel) -->
                        <div id="holistic-indexing-panel" class="holistic-panel">
                            <div id="holistic-show-info" class="holistic-section"></div>
                            <div id="holistic-animation" class="holistic-section">
                            <pre id="animation-panel-content"></pre>
                        </div>
                            <div id="holistic-progress" class="holistic-section"></div>
                        </div>

                        <!-- STOP INDEXING Button positioned between holistic panel and channel -->
                        <div style="margin-top: 16px;">
                            <button id="stop-indexing-button" class="primary-cta automode" onclick="toggleIndexing()">
                                STOP INDEXING
                            </button>
                            <!-- Subtitle removed -->
                        </div>

                        <!-- Channel Section (replaces now-playing) -->
                        <div style="margin-top: 16px;">
                            <!-- Detected Show UI for Indexing View -->
                            <div id="detected-show-ui-indexing" style="display: none; margin-bottom: 12px; background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; border: 1px solid #00ff41;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">🎯 SHOW DETECTED</div>
                                        <div id="detected-show-title-indexing" style="font-size: 11px; font-weight: 600;">Loading...</div>
                                        <div id="detected-show-meta-indexing" style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">Processing...</div>
                                    </div>
                                    <button onclick="dismissDetectedShowIndexing()" style="background: none; border: none; color: #000; font-size: 16px; cursor: pointer; padding: 4px; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">×</button>
                                </div>
                            </div>
                                
                                <!-- Detection Mode Channel Section for Indexing View -->
                                <div id="detection-channel-section-indexing" style="margin-top: 12px; display: none;">
                                    <div id="expand-detection-channel-header-indexing" onclick="toggleDetectionChannelExpansionIndexing()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-detection-channel-text-indexing" style="flex: none;">WATCH YOUR NEXT SHOW WITH US</span>
                                        <span id="expand-detection-channel-icon-indexing" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                    </div>
                                    <!-- Detection Channel Container (initially hidden) -->
                                    <div id="detection-channel-expanded-container-indexing" style="display: none; margin-top: 4px;">
                                        <div id="detection-channel-iframe-container-indexing" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="detection-channel-loading-indexing" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Genre Channel...</div>
                                            <iframe id="detection-channel-frame-indexing" src="Genre-channel_v2.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onerror="showDetectionChannelErrorIndexing()"></iframe>
                                        </div>
                                    </div>
                        </div>

                                <!-- Automode Channel Section for Indexing View -->
                                <div id="automode-channel-section-indexing" style="margin-top: 12px; display: none;">
                                    <div id="expand-automode-channel-header-indexing" onclick="toggleAutomodeChannelExpansionIndexing()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-automode-channel-text-indexing" style="flex: none;">WHAT ARE WE LEARNING</span>
                                        <span id="expand-automode-channel-icon-indexing" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                    </div>
                                    <!-- Automode Channel Container (initially hidden) -->
                                    <div id="automode-channel-expanded-container-indexing" style="display: none; margin-top: 4px;">
                                        <div id="automode-channel-iframe-container-indexing" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="automode-channel-loading-indexing" style="padding: 20px; text-align: center; color: #ffff00; font-size: 12px; z-index: 1; display: none;">Loading Rumi Channel...</div>
                                            <iframe id="automode-channel-frame-indexing" src="rumi-channel.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onerror="showAutomodeChannelErrorIndexing()"></iframe>
                                        </div>
                                    </div>
                                </div>
                        </div>



                        <!-- Section 3b: 🧠 Training Progress Dashboard (Automode Only) -->
                        <div id="training-progress-dashboard" style="margin-top: 16px; display: none;">
                            <div id="expand-training-progress-header" onclick="toggleTrainingProgressExpansion()" style="display: flex; align-items: center; justify-content: center; background: #2a2a0a; color: #ffff00; border: 1px solid #ffff00; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                <span id="expand-training-progress-text" style="flex: none;">🧠 Training Progress Dashboard</span>
                                <span id="expand-training-progress-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                            </div>
                            <!-- Training Progress Container (initially hidden) -->
                            <div id="training-progress-expanded-container" style="display: none; margin-top: 4px;">
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                                    <!-- AI Learning Stages -->
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                                        <div class="training-stage active" style="background: #2a2a0a; border: 1px solid #ffff00; border-radius: 4px; padding: 8px;">
                                            <div style="font-size: 9px; color: #ffff00; font-weight: 600;">⚡ Pattern Recognition</div>
                                            <div style="font-size: 8px; color: #888; margin-top: 2px;">Learning content patterns</div>
                                            <div style="font-size: 8px; color: #ffff00; margin-top: 4px;">Active</div>
                                        </div>
                                        <div class="training-stage" style="background: #222; border: 1px solid #444; border-radius: 4px; padding: 8px;">
                                            <div style="font-size: 9px; color: #666; font-weight: 600;">🧠 Classification</div>
                                            <div style="font-size: 8px; color: #555; margin-top: 2px;">Genre & content analysis</div>
                                            <div style="font-size: 8px; color: #666; margin-top: 4px;">Queued</div>
                                        </div>
                                        <div class="training-stage" style="background: #222; border: 1px solid #444; border-radius: 4px; padding: 8px;">
                                            <div style="font-size: 9px; color: #666; font-weight: 600;">📊 Behavior Analysis</div>
                                            <div style="font-size: 8px; color: #555; margin-top: 2px;">User preference learning</div>
                                            <div style="font-size: 8px; color: #666; margin-top: 4px;">Queued</div>
                                        </div>
                                        <div class="training-stage" style="background: #222; border: 1px solid #444; border-radius: 4px; padding: 8px;">
                                            <div style="font-size: 9px; color: #666; font-weight: 600;">🎯 Optimization</div>
                                            <div style="font-size: 8px; color: #555; margin-top: 2px;">Algorithm refinement</div>
                                            <div style="font-size: 8px; color: #666; margin-top: 4px;">Queued</div>
                                        </div>
                                    </div>

                                    <!-- Training Progress Bar -->
                                    <div style="background: #111; border: 1px solid #333; border-radius: 4px; height: 20px; position: relative; overflow: hidden;">
                                        <div style="position: absolute; top: 0; left: 0; height: 100%; width: 25%; background: linear-gradient(90deg, #ffff00, #ffaa00); border-radius: 4px; transition: width 1s ease;" id="automode-training-progress"></div>
                                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 9px; color: #ccc; font-weight: 600;">
                                            <span id="automode-progress-text">Loading learning content...</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Section 4b: Real-time Learning Insights (Automode Only) -->
                        <div id="real-time-learning-insights" style="margin-top: 16px; display: none;">
                            <div id="expand-learning-insights-header" onclick="toggleLearningInsightsExpansion()" style="display: flex; align-items: center; justify-content: center; background: #2a2a0a; color: #ffff00; border: 1px solid #ffff00; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                <span id="expand-learning-insights-text" style="flex: none;">🧠 Real-time Learning Insights</span>
                                <span id="expand-learning-insights-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                            </div>
                            <!-- Learning Insights Container (initially hidden) -->
                            <div id="learning-insights-expanded-container" style="display: none; margin-top: 4px;">
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 9px;">
                                        <div>
                                            <div style="color: #ffaa00; font-weight: 600; margin-bottom: 4px;">Content Analysis</div>
                                            <div style="color: #ccc; margin-bottom: 2px;">Patterns detected: <span style="color: #ffff00;">127</span></div>
                                            <div style="color: #ccc; margin-bottom: 2px;">Genres identified: <span style="color: #ffff00;">8</span></div>
                                            <div style="color: #ccc;">Accuracy improving: <span style="color: #ffff00;">+12%</span></div>
                                        </div>
                                        <div>
                                            <div style="color: #ffaa00; font-weight: 600; margin-bottom: 4px;">Learning Progress</div>
                                            <div style="color: #ccc; margin-bottom: 2px;">Neural connections: <span style="color: #ffff00;">2,847</span></div>
                                            <div style="color: #ccc; margin-bottom: 2px;">Training samples: <span style="color: #ffff00;">1,203</span></div>
                                            <div style="color: #ccc;">Model confidence: <span style="color: #ffff00;">87.3%</span></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Section 4b: Indexed Content (Automode Only) -->
                        <div id="indexed-content-list" style="margin-top: 16px; display: none;">
                            <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px;">
                                <div style="color: #ffaa00; font-weight: 600; margin-bottom: 4px;">Indexed Clips This Session</div>
                                <ul id="indexed-content-ul" style="list-style: none; padding: 0; margin: 0; font-size: 11px; color: #ffff00;">
                                    <!-- Populated by JS -->
                                </ul>
                            </div>
                        </div>

                        <script>
                        // Function to update indexed content list in 4b
                        function updateIndexedContentList() {
                            const ul = document.getElementById('indexed-content-ul');
                            if (!ul) return;
                            ul.innerHTML = '';
                            if (appState.indexedContent && appState.indexedContent.length > 0) {
                                appState.indexedContent.forEach(item => {
                                    const li = document.createElement('li');
                                    li.textContent = item.title || item.name || '[Untitled]';
                                    ul.appendChild(li);
                                });
                            } else {
                                const li = document.createElement('li');
                                li.textContent = 'No content indexed yet.';
                                ul.appendChild(li);
                            }
                        }
                        // Call this after each content transition
                        </script>
                    </div>
                </div>
            </div>
            </div>
        </div>

        <!-- Settings View (Initially Hidden) -->
        <div id="settings-view" style="display: none;">
            <div class="popup-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="font-size: 16px;">SETTINGS</h2>
                </div>
                
                <!-- Account Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Account</h3>
                    <div class="settings-item">
                        <span class="settings-label">Username</span>
                        <span class="settings-value">CRYPTO_MAVEN</span>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Member Since</span>
                        <span class="settings-value">Dec 2023</span>
                    </div>
                    <button class="settings-logout-button">LOGOUT</button>
                </div>

                <!-- Preferences Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Preferences</h3>
                    <div class="settings-item">
                        <span class="settings-label">Desktop Notifications</span>
                        <label class="switch">
                            <input type="checkbox" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Auto-start Indexing</span>
                        <label class="switch">
                            <input type="checkbox">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error State Views -->
        <!-- (Removed: error-state panels are now handled in the message area) -->
    </div>


    <!-- Scripts -->
    <script src="tracker.js"></script>
    <!-- Backend Integration -->
    <script src="rumi-backend-engine.js"></script>
    <script src="rumi-backend-integration.js"></script>
    <!-- Change Monitoring Agent -->
    <script src="change-monitor.js"></script>
    <!-- Transition System -->
    <script src="transition-system.js"></script>
    <script>
        // Debug: Check if tracker loaded
        console.log('Tracker loaded:', typeof Tracker !== 'undefined');
        console.log('RUMI_PROJECT loaded:', typeof RUMI_PROJECT !== 'undefined');

        // App State
        const appState = {
            pendingShowForGenreChannel: null, // Corrected syntax
            pendingEntryPoint: null, // NEW: Store pending entry point for activation
            pendingDetectedShow: null, // NEW: Store pending detected show for activation
            pendingDetectionGenre: null, // NEW: Store selected genre for detection mode
            pendingGenreContent: null, // NEW: Store content for selected genre
            view: 'home',
            pointsEarned: 4349,
            totalPendingPoints: 200,
            sessionEarnings: 0,
            currentMultiplier: 1.0,
            currentContent: null,
            isIndexing: false,
            indexingStartTime: null,
            sortMode: 'points', // 'points' or 'channel'
            currentBucket: 'Rumi Internal Audiences', // NEW: To store the selected bucket
            // Error States
            errorState: null, // null, 'volume', 'connection', 'loading', 'offline'
            volumeLevel: 100,
            connectionStatus: 'connected', // 'connected', 'lost', 'offline'
            isLoading: false,
            // NEW: Automode content tracking
            automodeContentItems: [], // Array of content items for current session
            currentContentIndex: 0, // Index of current content item
            contentItemStartTime: 0, // When current content item started
            contentItemDuration: 0, // Duration of current content item in seconds
            contentTransitionProgress: 0, // Smooth transition between content items
            channelExpanded: false, // Add to appState
            simResolved: false, // Prevents error re-trigger after SIM RESOLVE
            indexingTimer: null, // Timer for indexing session
            // NEW: Pause state tracking
            isPaused: false, // Whether indexing is currently paused
            pauseStartTime: null, // When the pause started
            pauseDuration: 0, // Total time paused in this session
            sessionEndReason: null, // 'normal', 'fatal_error', 'user_stop'
            // NEW: Debug button cooldowns
            debugSkipCooldown: 0, // Cooldown timer for skip to end button
            debugTomorrowCooldown: 0, // Cooldown timer for skip to tomorrow button
            // NEW: Session management
            userChoice: null, // 'rumi' or 'streamer' - user's choice for content control
            showChoicePrompt: false, // Whether to show the choice prompt
            sessionCompleted: false, // Whether the current session has been completed
            indexedContent: [], // Array to track actual content indexed during this session
            // NEW: Content tracking to prevent duplicates
            playedContent: new Set(), // Set of content IDs that have been played
            channelContent: new Map(), // Map of channel name -> Set of content IDs in that channel
            globalContentQueue: [], // Global queue across all channels
            contentHistory: [], // Array of recently played content for recommendations
            cachedSessionDuration: null, // Cache for session duration
            cachedSessionDurationTimestamp: null, // Timestamp for cache expiration
            showInterruptTimestamp: null, // Timestamp when show interrupt occurred
            // NEW: Transition-test.html inspired content tracking
            totalSessionLength: 0, // Total duration of all content in session (minutes)
            timeIndexed: 0, // Time indexed in current content item (minutes)
            completedContent: new Set(), // Track completed content IDs (cannot be removed)
            playedContentForReceipt: [], // Array of {title, timeIndexed, points, multiplier, duration} for receipt
            isTransitioning: false, // Whether a content transition is in progress
            currentContentItem: null, // Current content item being indexed
            contentItemStartTime: null, // When current content item started
            contentItemDuration: 0, // Duration of current content item in seconds
            // Fast Mode state
            fastMode: null
        };

        // NEW: Content tracking utility functions
        function generateContentId(content) {
            // Generate a unique ID for content based on title, type, and episode info
            let id = content.title || content.name || '';
            
            // Add episode information if available
            if (content.season && content.episode) {
                id += `-S${content.season}E${content.episode}`;
            } else if (content.episode) {
                id += `-E${content.episode}`;
            }
            
            // Add type if available
            if (content.type) {
                id += `-${content.type}`;
            }
            
            // Add service if available
            if (content.service) {
                id += `-${content.service}`;
            }
            
            return id.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        }

        function isContentPlayed(contentId) {
            return appState.playedContent.has(contentId);
        }

        function markContentAsPlayed(content) {
            const contentId = generateContentId(content);
            appState.playedContent.add(contentId);
            
            // Add to content history (keep last 50 items)
            appState.contentHistory.unshift({
                id: contentId,
                content: content,
                playedAt: Date.now()
            });
            if (appState.contentHistory.length > 50) {
                appState.contentHistory.pop();
            }
            
            Tracker.logRumiAction('Content marked as played', { contentId, title: content.title });
        }

        function isContentInChannel(contentId, channelName) {
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            return appState.channelContent.get(channelName).has(contentId);
        }

        function addContentToChannel(content, channelName) {
            const contentId = generateContentId(content);
            
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            
            appState.channelContent.get(channelName).add(contentId);
            Tracker.logRumiAction('Content added to channel', { contentId, channelName, title: content.title });
        }

        function removeContentFromChannel(contentId, channelName) {
            if (appState.channelContent.has(channelName)) {
                appState.channelContent.get(channelName).delete(contentId);
                Tracker.logRumiAction('Content removed from channel', { contentId, channelName });
            }
        }

        function addToGlobalQueue(content, channelName) {
            const contentId = generateContentId(content);
            
            // Check if content is already in global queue
            const existingIndex = appState.globalContentQueue.findIndex(item => generateContentId(item.content) === contentId);
            if (existingIndex !== -1) {
                return false; // Already in queue
            }
            
            appState.globalContentQueue.push({
                content: content,
                channelName: channelName,
                addedAt: Date.now(),
                contentId: contentId
            });
            
            Tracker.logRumiAction('Content added to global queue', { contentId, channelName, title: content.title });
            return true;
        }

        function removeFromGlobalQueue(contentId) {
            const index = appState.globalContentQueue.findIndex(item => item.contentId === contentId);
            if (index !== -1) {
                const removed = appState.globalContentQueue.splice(index, 1)[0];
                Tracker.logRumiAction('Content removed from global queue', { contentId, channelName: removed.channelName });
                return removed;
            }
            return null;
        }

        function getFilteredContentForChannel(contentList, channelName, excludeContentIds = new Set()) {
            // Filter out content that's already been played, is in the channel, or is in excludeContentIds
            return contentList.filter(content => {
                const contentId = generateContentId(content);
                return !isContentPlayed(contentId) && !isContentInChannel(contentId, channelName) && !excludeContentIds.has(contentId);
            });
        }

        function getContentRecommendations(excludePlayed = true, limit = 10) {
            // Get content recommendations based on history
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && (!excludePlayed || !isContentPlayed(contentId))) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        function clearContentTracking() {
            // Clear all content tracking (useful for testing or reset)
            appState.playedContent.clear();
            appState.channelContent.clear();
            appState.globalContentQueue = [];
            appState.contentHistory = [];
            Tracker.logRumiAction('Content tracking cleared');
        }

        // NEW: Debug function to test content tracking
        function debugContentTracking() {
            console.log('=== CONTENT TRACKING DEBUG ===');
            console.log('Played Content Count:', appState.playedContent.size);
            console.log('Played Content IDs:', Array.from(appState.playedContent));
            
            console.log('Channel Content:');
            appState.channelContent.forEach((contentSet, channelName) => {
                console.log(`  ${channelName}: ${contentSet.size} items`);
                console.log(`    IDs:`, Array.from(contentSet));
            });
            
            console.log('Global Queue Count:', appState.globalContentQueue.length);
            console.log('Global Queue Items:', appState.globalContentQueue.map(item => ({
                title: item.content.title,
                channelName: item.channelName,
                contentId: item.contentId
            })));
            
            console.log('Content History Count:', appState.contentHistory.length);
            console.log('Recent History:', appState.contentHistory.slice(0, 5).map(item => ({
                title: item.content.title,
                playedAt: new Date(item.playedAt).toLocaleTimeString()
            })));
            
            // Test content ID generation
            const testContent = {
                title: 'Test Show',
                season: 'S1',
                episode: 'E1',
                type: 'show',
                service: 'netflix'
            };
            console.log('Test Content ID:', generateContentId(testContent));
            
            // Test filtering
            const testContentList = [
                { title: 'Show 1', type: 'show' },
                { title: 'Show 2', type: 'movie' },
                { title: 'Show 3', type: 'show' }
            ];
            const filtered = getFilteredContentForChannel(testContentList, 'test-channel');
            console.log('Filtered Content for test-channel:', filtered.length, 'items');
            
            console.log('=== END CONTENT TRACKING DEBUG ===');
        }

        // NEW: Debug function to inspect show detection state
        function debugShowDetectionState() {
            console.log('=== SHOW DETECTION DEBUG STATE ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Is Indexing:', appState.isIndexing);
            console.log('Indexing Start Time:', appState.indexingStartTime);
            console.log('Detected Show:', appState.detectedShow);
            
            if (appState.isIndexing && appState.indexingStartTime) {
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                console.log('Elapsed Time:', elapsedTime.toFixed(2) + 's');
            }
            
            console.log('Content Items Count:', appState.automodeContentItems ? appState.automodeContentItems.length : 0);
            console.log('Current Content Index:', appState.currentContentIndex);
            console.log('Content Item Start Time:', appState.contentItemStartTime);
            console.log('Content Item Duration:', appState.contentItemDuration);
            
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                console.log('Current Content Item:', appState.automodeContentItems[appState.currentContentIndex]);
                if (appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                    console.log('Next Content Item:', appState.automodeContentItems[appState.currentContentIndex + 1]);
                }
            }
            
            // Show session duration info without causing overflow
            console.log('Cached Session Duration:', appState.cachedSessionDuration);
            console.log('Cache Timestamp:', appState.cachedSessionDurationTimestamp);
            if (appState.cachedSessionDurationTimestamp) {
                const cacheAge = Date.now() - appState.cachedSessionDurationTimestamp;
                console.log('Cache Age:', (cacheAge / 1000).toFixed(1) + 's');
            }
            console.log('Chained Session Duration:', appState.chainedSessionDuration);
            if (appState.detectedShow && appState.detectedShow.duration) {
                console.log('Detected Show Duration:', appState.detectedShow.duration + ' minutes');
            }
            console.log('Base Rate:', appState.baseRate);
            console.log('Current Multiplier:', appState.currentMultiplier);
            console.log('=== END SHOW DETECTION DEBUG ===');
        }

        // NEW: Debug function to inspect channel content
        function debugChannelContent() {
            console.log('=== CHANNEL CONTENT DEBUG ===');
            const channelFrame = document.getElementById('detection-channel-frame-indexing');
            if (channelFrame && channelFrame.contentWindow) {
                console.log('Channel frame found, requesting content...');
                try {
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                } catch (e) {
                    console.log('Error requesting channel content:', e.message);
                }
            } else {
                console.log('Channel frame not found or not accessible');
            }
            console.log('=== END CHANNEL CONTENT DEBUG ===');
        }

        // NEW: Debug function to reset show detection state
        function debugResetShowDetection() {
            console.log('=== RESETTING SHOW DETECTION STATE ===');
            appState.automodeContentItems = [];
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = 0;
            appState.contentTransitionProgress = 0;
            console.log('Show detection state reset');
            console.log('=== END RESET ===');
        }

        // NEW: Function to clear session duration cache
        function clearSessionDurationCache() {
            appState.cachedSessionDuration = null;
            appState.cachedSessionDurationTimestamp = null;
            console.log('Session duration cache cleared');
        }

        // NEW: Channel integration functions
        function integrateContentTrackingWithChannels() {
            // Send content tracking data to all loaded channels
            const channelFrames = [
                document.getElementById('channel-frame'),
                document.getElementById('detection-channel-frame-indexing')
            ];
            
            channelFrames.forEach(frame => {
                if (frame && frame.contentWindow) {
                    try {
                        // Send played content data to channel
                        frame.contentWindow.postMessage({
                            type: 'contentTracking',
                            playedContent: Array.from(appState.playedContent),
                            channelContent: Object.fromEntries(appState.channelContent),
                            globalQueue: appState.globalContentQueue
                        }, '*');
                    } catch (e) {
                        console.log('Could not send content tracking to channel:', e.message);
                    }
                }
            });
        }

        function handleChannelContentAdded(content, channelName) {
            // Called when content is added to a channel
            addContentToChannel(content, channelName);
            
            // Also add to global queue if not already there
            addToGlobalQueue(content, channelName);
            
            Tracker.logRumiAction('Content added to channel from tracking', { 
                contentId: generateContentId(content), 
                channelName, 
                title: content.title 
            });
        }

        function handleChannelContentPlayed(content, channelName) {
            // Called when content is played from a channel
            markContentAsPlayed(content);
            
            // Remove from channel content (since it's now played)
            const contentId = generateContentId(content);
            removeContentFromChannel(contentId, channelName);
            
            // Remove from global queue
            removeFromGlobalQueue(contentId);
            
            Tracker.logRumiAction('Content played from channel', { 
                contentId, 
                channelName, 
                title: content.title 
            });
        }

        // NEW: Function to get filtered content for channels
        function getChannelContentRecommendations(channelName, limit = 10) {
            // Get content recommendations that haven't been played and aren't in this channel
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && 
                    !isContentPlayed(contentId) && 
                    !isContentInChannel(contentId, channelName)) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        // NEW: Function to export content tracking data
        function exportContentTrackingData() {
            return {
                playedContent: Array.from(appState.playedContent),
                channelContent: Object.fromEntries(appState.channelContent),
                globalQueue: appState.globalContentQueue,
                contentHistory: appState.contentHistory.map(item => ({
                    id: item.id,
                    title: item.content.title,
                    playedAt: item.playedAt
                }))
            };
        }

        // NEW: Function to import content tracking data
        function importContentTrackingData(data) {
            if (data.playedContent) {
                appState.playedContent = new Set(data.playedContent);
            }
            if (data.channelContent) {
                appState.channelContent = new Map(Object.entries(data.channelContent).map(([key, value]) => [key, new Set(value)]));
            }
            if (data.globalQueue) {
                appState.globalContentQueue = data.globalQueue;
            }
            if (data.contentHistory) {
                appState.contentHistory = data.contentHistory;
            }
            
            Tracker.logRumiAction('Content tracking data imported', { 
                playedCount: appState.playedContent.size,
                channelCount: appState.channelContent.size,
                queueCount: appState.globalContentQueue.length
            });
        }

        // Initialize app
        function initApp() {
            // If we have already launched from an entry point, don't re-initialize.
            if (appState.entryPoint) {
                return;
            }

            console.log('Initializing app...');
            
            if (typeof Tracker === 'undefined') {
                console.error('Tracker not loaded!');
                return;
            }

            Tracker.startFlow(RUMI_PROJECT.flows.HOME_SCREEN);
            Tracker.logRumiAction('App initialized');
            Tracker.logRumiState(appState);
            
            // Initialize UI based on current state
            updateUI();
            updatePointsDisplay();
            
            // Test home screen checkpoints
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.HOME_LOADED, true, 'Home screen loaded');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.POINTS_DISPLAYED, true, 'Points displayed correctly');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.CTA_POSITIONED, true, 'CTA positioned correctly');
            
            Tracker.endFlow();
            console.log('App initialized successfully');

            // Start error monitoring
            monitorVolume();
            // monitorConnection(); // Disabled - was causing false connection errors during indexing
            
            // Initialize transition system
            if (window.TransitionSystem) {
                window.transitionSystem = new window.TransitionSystem();
                console.log('✅ INDEXD: Transition system initialized');
            } else {
                console.log('⚠️ INDEXD: Transition system not available');
            }
            
            // Pre-load CSV content for automode
            console.log('Pre-loading CSV content for automode...');
            getCSVBucketContent();
        }

        // Toggle indexing state
        function toggleIndexing() {
            console.log('toggleIndexing called, isIndexing:', appState.isIndexing);
            if (appState.isIndexing) {
                console.log('Stopping indexing...');
                stopIndexing();
            } else {
                console.log('Starting indexing...');
                startIndexing();
            }
        }

        // Start indexing
       function startIndexing() {
            // If session is already running, do nothing.
            if (appState.indexingStartTime) return;

            // Ensure state and view are correct, even if called directly.
            if (!appState.isIndexing) {
                appState.isIndexing = true;
                
                // Show the indexing view (nokia content)
                const homeContent = document.getElementById('home-content');
                const nokiaContent = document.getElementById('nokia-content');
                
                if (homeContent) homeContent.style.display = 'none';
                if (nokiaContent) nokiaContent.style.display = 'block';
                
                updateUI();
            }

            // Reset session state
            appState.sessionEndReason = null;
            appState.isPaused = false;
            appState.pauseStartTime = null;
            appState.pauseDuration = 0;
            appState.sessionCompleted = false; // Reset session completion flag
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for new session

            // Set base rate for this session
            appState.baseRate = (appState.entryPoint === 'automode') ? 0.25 : 0.1;
            appState.indexingStartTime = Date.now();
            appState.sessionEarnings = 0;

            // Initialize automode content tracking
            if (appState.entryPoint === 'automode') {
                // Generate content items for the session (30 minutes = 1800 seconds)
                appState.automodeContentItems = getAutomodeContent(appState.currentBucket, 1800, appState.baseRate, appState.currentMultiplier);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // If no content was loaded, retry after a short delay
                if (appState.automodeContentItems.length === 0) {
                    console.log('No automode content loaded, retrying after delay...');
                    setTimeout(() => {
                        if (appState.entryPoint === 'automode' && appState.isIndexing) {
                            console.log('Retrying automode content loading...');
                            appState.automodeContentItems = getAutomodeContent(appState.currentBucket, 1800, appState.baseRate, appState.currentMultiplier);
                            updateAutomodeProgressText();
                        }
                    }, 1000);
                }
                
                // Calculate duration for first content item
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                    console.log(`Initial setup - First item: ${firstItem.title}, duration string: "${firstItem.duration}"`);
                    // Parse duration string (e.g., "1:23") to seconds
                    const durationParts = firstItem.duration.split(':');
                    console.log(`Initial setup - Duration parts:`, durationParts);
                    appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    console.log(`Initial setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                }
                
                // Update the progress text with initial content
                updateAutomodeProgressText();
                
                // Also update after a delay to ensure CSV content is loaded
                setTimeout(() => {
                    if (appState.entryPoint === 'automode') {
                        console.log('Delayed update of progress text after CSV load');
                        updateAutomodeProgressText();
                    }
                }, 500);
            } else if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // Initialize content items for show detection mode
                const sessionDuration = calculateSessionDuration();
                appState.automodeContentItems = getShowDetectionContent(appState.detectedShow, sessionDuration);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // Request content from genre channel if available
                const channelFrame = document.getElementById('detection-channel-frame-indexing');
                if (channelFrame && channelFrame.contentWindow) {
                    try {
                        // Request current content from the genre channel
                        channelFrame.contentWindow.postMessage({ 
                            type: 'requestCurrentContent' 
                        }, '*');
                        console.log('Requested content from genre channel for detection mode');
                    } catch (e) {
                        console.log('Could not request content from genre channel:', e.message);
                    }
                }
                
                // Calculate duration for first content item if we have content
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                    console.log(`Show detection setup - First item: ${firstItem.title}, duration: ${firstItem.duration}`);
                    
                    // Handle both duration strings and numeric durations
                    if (typeof firstItem.duration === 'string' && firstItem.duration.includes(':')) {
                        // Parse duration string (e.g., "0:45") to seconds
                        const durationParts = firstItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        console.log(`Show detection setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                    } else {
                        // Use duration as-is (already in seconds)
                        appState.contentItemDuration = firstItem.duration;
                        console.log(`Show detection setup - Using duration as-is: ${appState.contentItemDuration} seconds`);
                    }
                } else {
                    // No content yet - will be populated when channel responds
                    console.log('Show detection setup - No content items yet, waiting for channel response');
                    // Set a default duration until content arrives
                    appState.contentItemDuration = 45 * 60; // 45 minutes default
                }
            }

            // Start animation loop
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animateSessionStats();
            
            Tracker.logRumiAction('Indexing session activated');
            updatePointsDisplay(); // Switch to session view in points panel
            appState.simResolved = false;
            updateDebugButtonStates(); // Update debug button states when indexing starts
            
            // Show Learning Insights for automode indexing (Section 3b)
            if (appState.entryPoint === 'automode') {
                showLearningInsightsForIndexing();
            }
            
            // Ensure channel visibility when starting indexing
            setTimeout(() => {
                ensureChannelVisibility();
            }, 500);
        }
// Helper to record actual indexed content before showing receipt
function recordActualIndexedContentBeforeReceipt() {
    try {
        // If already populated, do nothing
        if (appState.indexedContent && appState.indexedContent.length > 0) return;

        // Only proceed if in detection mode and a show is detected
        if (appState.entryPoint !== 'detection') return;
        if (!appState.detectedShow || !appState.detectedShow.title) {
            console.warn('No detectedShow available for indexed content recording.');
            return;
        }
        const sessionDuration = calculateSessionDuration();
        const sessionDurationMinutes = Math.floor(sessionDuration / 60);
        const totalElapsedTime = Math.floor((Date.now() - appState.indexingStartTime) / 60000);
        const actualDuration = Math.min(sessionDurationMinutes, totalElapsedTime);

        if (appState.originalShow && appState.interruptNewShow) {
            // If there was a show transition, split time using interrupt timestamp if available
            let originalShowTime, chainedShowTime;
            if (appState.showInterruptTimestamp) {
                const interruptTimeMinutes = Math.floor((appState.showInterruptTimestamp - appState.indexingStartTime) / 60000);
                originalShowTime = Math.min(interruptTimeMinutes, actualDuration);
                chainedShowTime = Math.max(0, actualDuration - originalShowTime);
            } else {
                const interruptTime = Math.floor(actualDuration * 0.75);
                originalShowTime = interruptTime;
                chainedShowTime = actualDuration - interruptTime;
            }
            // Record original show
            const originalShowItem = {
                title: `${appState.originalShow.title} ${appState.originalShow.season !== 'N/A' ? `S${appState.originalShow.season} E${appState.originalShow.episode}` : '(Film)'}`,
                duration: originalShowTime,
                type: 'detected_show',
                points: Math.round((originalShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(originalShowItem);
            // Record chained show
            const chainedShowItem = {
                title: `${appState.interruptNewShow.title} ${appState.interruptNewShow.season !== 'N/A' ? `S${appState.interruptNewShow.season} E${appState.interruptNewShow.episode}` : '(Film)'} (Chained)`,
                duration: chainedShowTime,
                type: 'chained_show',
                points: Math.round((chainedShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(chainedShowItem);
            markContentAsPlayed(originalShowItem);
            markContentAsPlayed(chainedShowItem);
            console.log('Indexed content recorded (transition):', appState.indexedContent);
        } else {
            // No show transition - just record the current show
            const indexedContentItem = {
                title: `${appState.detectedShow.title} ${appState.detectedShow.season !== 'N/A' ? `S${appState.detectedShow.season} E${appState.detectedShow.episode}` : '(Film)'}`,
                duration: actualDuration,
                type: 'detected_show',
                points: Math.round((actualDuration * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(indexedContentItem);
            markContentAsPlayed(indexedContentItem);
            console.log('Indexed content recorded:', appState.indexedContent);
        }
    } catch (e) {
        console.error('Error in recordActualIndexedContentBeforeReceipt:', e);
    }
}
        function stopIndexing() {
            console.log('stopIndexing called, isIndexing:', appState.isIndexing);
            if (!appState.isIndexing) {
                console.log('Not indexing, returning early');
                return;
            }
            // Only record indexed content for detection mode
            if (appState.entryPoint === 'detection') {
                recordActualIndexedContentBeforeReceipt();
            }
            // Record automode indexed content
            if (appState.entryPoint === 'automode') {
                // Only include items that were actually shown (up to currentContentIndex)
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    appState.indexedContent = appState.automodeContentItems
                        .slice(0, appState.currentContentIndex + 1)
                        .map(item => ({
                            title: item.title,
                            duration: 1, // Each item represents ~1 minute of content
                            points: (appState.baseRate || 0.25) * (appState.currentMultiplier || 1.0) * 60, // 1 minute worth of points
                            type: 'automode'
                        }));
                }
            }
            appState.isIndexing = false;
            appState.totalPendingPoints += appState.sessionEarnings;
            
            // Set session end reason
            appState.sessionEndReason = 'user_stop';
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Calculate any remaining real-time points before showing the receipt
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.sessionEarnings = (appState.baseRate || 0.1) * appState.currentMultiplier * elapsedTime;
            
            // NEW: Complete current show before showing receipt (ensures last content is logged)
            if (typeof completeCurrentShow === "function") {
                completeCurrentShow();
            }
            // Calculate session data and show receipt
            const sessionDuration = Math.floor(elapsedTime);
            const finalMultiplier = appState.currentMultiplier;
            showReceiptView(appState.sessionEarnings, sessionDuration, finalMultiplier);

            // Reset session state
            appState.indexingStartTime = null;
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for next session
            
            Tracker.logRumiAction('Indexing stopped');
            updatePointsDisplay();
            updateDebugButtonStates(); // Update debug button states when indexing stops
        }

        // Show receipt view with session results
        function showReceiptView(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt view shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint,
                sessionEndReason: appState.sessionEndReason
            });
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="hideReceiptView()">← BACK</button>';
            // }
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${sessionEarnings.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${(appState.totalPendingPoints + sessionEarnings).toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(sessionDuration);
            document.getElementById('receipt-multiplier').textContent = `${finalMultiplier.toFixed(1)}x`;
            
            // Set bonus text based on multiplier
            const bonusElement = document.getElementById('receipt-bonus');
            if (appState.interruptNewShow && finalMultiplier >= 1.1) {
                bonusElement.textContent = 'Chained Content Bonus';
                bonusElement.style.color = '#ffaa00';
            } else if (finalMultiplier >= 1.2) {
                bonusElement.textContent = '10min Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Set the correct base rate in the receipt
            const baseRateValue = appState.entryPoint === 'automode' ? '0.25 pts/s' : '0.1 pts/s';
            const baseRateSpans = document.querySelectorAll('#receipt-view span[style*="color: #fff"]');
            baseRateSpans.forEach(span => {
                if (span.textContent.includes('pts/')) {
                    span.textContent = baseRateValue;
                }
            });
            
            // Generate mode-specific content list with session end reason
            generateReceiptContentList(sessionDuration, appState.entryPoint, appState.sessionEndReason);
            
            appState.view = 'receipt';
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // Generate content list for receipt based on session duration and mode
        function generateReceiptContentList(sessionDuration, mode, sessionEndReason) {
            const contentList = document.getElementById('receipt-content-list');
            const contentItems = [];
            
            // Calculate base rate and multiplier for points calculation
            const baseRate = appState.entryPoint === 'automode' ? 0.25 : 0.1; // points per second
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Add session end reason if it was a fatal error
            if (sessionEndReason === 'fatal_error') {
                contentItems.push({
                    title: 'Session ended by terminal error',
                    duration: '--',
                    points: '--',
                    isError: true
                });
            }
            
            // Use actual indexed content if available
            if (appState.indexedContent && appState.indexedContent.length > 0) {
                appState.indexedContent.forEach(content => {
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration} min`,
                        points: content.points.toFixed(1),
                        isChained: content.type === 'chained' || content.title.includes('(Chained)')
                    });
                });
            } else if (mode === 'detection' || mode === 'showDetection') {
                // Fallback: Show detection mode: show the detected show and related content
                if (appState.detectedShow) {
                    // Use original show if available (for chained content), otherwise use current detected show
                    const show = appState.originalShow || appState.detectedShow;
                    
                    // Use dynamic session duration instead of hardcoded 45 minutes
                    const sessionDurationMinutes = Math.floor(calculateSessionDuration() / 60);
                    const showTime = Math.min(sessionDuration, sessionDurationMinutes); // Use calculated duration
                    const showTimeSeconds = showTime * 60; // Convert to seconds
                    const showPoints = Math.round((showTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                    
                    contentItems.push({
                        title: `${show.title} ${show.season !== 'N/A' ? `S${show.season} E${show.episode}` : '(Film)'}`,
                        duration: formatTime(showTime),
                        points: showPoints.toFixed(1)
                    });
                    
                    // Add related content based on genre
                    const remainingTime = sessionDuration - showTime;
                    if (remainingTime > 0) {
                        // Check if there was a show interrupt and add the chained content
                        if (appState.interruptNewShow) {
                            const chainedShow = appState.interruptNewShow;
                            const chainedTime = Math.min(remainingTime, 30); // Assume 30 min for chained content
                            if (chainedTime > 0) {
                                const chainedTimeSeconds = chainedTime * 60;
                                const chainedPoints = Math.round((chainedTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                                
                                contentItems.push({
                                    title: `${chainedShow.title} ${chainedShow.season !== 'N/A' ? `S${chainedShow.season} E${chainedShow.episode}` : '(Film)'} (Chained)`,
                                    duration: formatTime(chainedTime),
                                    points: chainedPoints.toFixed(1),
                                    isChained: true
                                });
                                
                                // Add related content for the chained show if there's remaining time
                                const finalRemainingTime = remainingTime - chainedTime;
                                if (finalRemainingTime > 0) {
                                    const relatedContent = getRelatedContentWithPoints(chainedShow.genre, finalRemainingTime, baseRate, finalMultiplier);
                                    contentItems.push(...relatedContent);
                                }
                            }
                        } else {
                            const relatedContent = getRelatedContentWithPoints(show.genre, remainingTime, baseRate, finalMultiplier);
                            contentItems.push(...relatedContent);
                        }
                    }
                }
            } else if (mode === 'automode') {
                // Automode: show content from the current bucket
                const bucketContent = getAutomodeContentWithPoints(appState.currentBucket, sessionDuration, baseRate, finalMultiplier);
                contentItems.push(...bucketContent);
            } else {
                // Fallback: generic content
                const genericContent = getGenericContentWithPoints(sessionDuration, baseRate, finalMultiplier);
                contentItems.push(...genericContent);
            }
            
            // Generate HTML for content items with points
            const contentHTML = contentItems.map(item => `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: ${item.isError ? '#1a0000' : item.isChained ? '#1a1a00' : '#1a1a1a'}; border-radius: 3px; border: ${item.isError ? '1px solid #ff4444' : item.isChained ? '1px solid #ffaa00' : 'none'};">
                    <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'};">${item.title}</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #888;">${item.duration}</span>
                        <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points} pts</span>
                    </div>
                </div>
            `).join('');
            
            contentList.innerHTML = contentHTML;
            
            // Handle display based on number of items
            if (contentItems.length <= 4) {
                // For 4 or fewer items: expand the section to fit all items
                contentList.style.maxHeight = 'none';
                contentList.style.overflowY = 'visible';
            } else {
                // For more than 4 items: maintain 4-line layout with auto-scroll
                contentList.style.maxHeight = '120px'; // Height for approximately 4 items
                contentList.style.overflowY = 'auto';
                
                // Add scroll indicator
                const scrollIndicator = document.createElement('div');
                scrollIndicator.style.cssText = `
                    font-size: 9px; 
                    color: #666; 
                    text-align: center; 
                    padding: 4px; 
                    font-style: italic;
                    border-top: 1px solid #333;
                    margin-top: 4px;
                `;
                scrollIndicator.textContent = `Scroll to see ${contentItems.length - 4} more items`;
                contentList.appendChild(scrollIndicator);
                
                // Auto-scroll to bottom after a short delay
                setTimeout(() => {
                    contentList.scrollTop = contentList.scrollHeight;
                }, 500);
            }
        }

        // Show main view (from settings only now)
        function showMainView() {
            Tracker.logRumiAction('Main view shown');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="showSettingsView()">⚙ SETTINGS</button>';
            // }
            
            // Hide settings view and show settings view
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'none';
            
            // Reset entry point state to return to home screen
            appState.entryPoint = null;
            appState.detectedShow = null;
            
            // Update UI based on current state
            updateUI();
            updatePointsDisplay();
        }

        // Update UI based on current state
        function updateUI() {
            const ctaButton = document.getElementById('cta-button');
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            const stopIndexingButton = document.getElementById('stop-indexing-button');
            const stopIndexingSubtitle = stopIndexingButton ? stopIndexingButton.nextElementSibling : null;

            // Add null checks to prevent errors
            if (!ctaButton) {
                console.warn('CTA button not found');
                return;
            }

            if (appState.isIndexing) {
                // Show stop button and indexing content
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `STOP LEARNING ABOUT "${bucketName}"`;
                } else {
                ctaButton.textContent = 'STOP INDEXING';
                }
                ctaButton.className = 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'none';
                if(nokiaContent) nokiaContent.style.display = 'block';
                
                // Update indexing screen button
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `STOP TRAINING "${bucketName}"`;
                    } else {
                    stopIndexingButton.textContent = 'STOP INDEXING';
                }
                    stopIndexingButton.className = 'primary-cta';
                }
            } else if (appState.entryPoint) {
                // Show indexing screen but with START INDEXING button (idle state)
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `START WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `START LEARNING ${bucketName}`;
                } else {
                ctaButton.textContent = 'START INDEXING';
                }
                ctaButton.className = 'primary-cta';
                
                // Show home content (leaderboard) when not indexing yet
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
                
                // Update indexing screen button (this will be shown when indexing starts)
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `START WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `START LEARNING ${bucketName}`;
                    } else {
                    stopIndexingButton.textContent = 'START INDEXING';
                    }
                    stopIndexingButton.className = 'primary-cta';
                }
            } else {
                // Show start button and home content (leaderboard/queue)
                ctaButton.textContent = 'START WATCHING';
                ctaButton.className = 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
            }
            
            // Show appropriate sections based on entry point
            if (appState.entryPoint === 'detection') {
                showSection2a();
            } else if (appState.entryPoint === 'automode') {
                showSection2b();
            }
            
            // Update expandable channel UI
            updateExpandableChannelUI();
            
            // Show appropriate channel sections in indexing view
            if (appState.isIndexing) {
                const detectionChannelSection = document.getElementById('detection-channel-section-indexing');
                const automodeChannelSection = document.getElementById('automode-channel-section-indexing');
                const detectedShowUI = document.getElementById('detected-show-ui-indexing');
                
                console.log('Indexing view channel sections:', {
                    detectionChannelSection: detectionChannelSection ? 'found' : 'not found',
                    automodeChannelSection: automodeChannelSection ? 'found' : 'not found',
                    detectedShowUI: detectedShowUI ? 'found' : 'not found',
                    entryPoint: appState.entryPoint,
                    detectedShow: appState.detectedShow ? appState.detectedShow.title : 'none'
                });
                
                if (appState.entryPoint === 'detection') {
                    // Show detection channel and detected show UI
                    if (detectionChannelSection) {
                        detectionChannelSection.style.display = 'block';
                        console.log('Detection channel section shown');
                    } else {
                        console.log('Detection channel section not found!');
                    }
                    if (automodeChannelSection) automodeChannelSection.style.display = 'none';
                    if (detectedShowUI && appState.detectedShow) {
                        detectedShowUI.style.display = 'block';
                        // Update detected show info
                        const titleElement = document.getElementById('detected-show-title-indexing');
                        const metaElement = document.getElementById('detected-show-meta-indexing');
                        if (titleElement) titleElement.textContent = appState.detectedShow.title;
                        if (metaElement) {
                            if (appState.detectedShow.season !== 'N/A') {
                                metaElement.textContent = `S${appState.detectedShow.season} E${appState.detectedShow.episode} | ${appState.detectedShow.genre || 'Drama'}`;
                            } else {
                                metaElement.textContent = `Film | ${appState.detectedShow.genre || 'Drama'}`;
                            }
                        }
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Show automode channel and hide detected show UI
                    if (detectionChannelSection) detectionChannelSection.style.display = 'none';
                    if (automodeChannelSection) {
                        automodeChannelSection.style.display = 'block';
                        console.log('Automode channel section shown');
                    }
                    if (detectedShowUI) detectedShowUI.style.display = 'none';
                }
            }
            
            updateDebugButtonStates(); // Update debug button states when UI changes
        }

        // Indexing timer for status panel
        let pointAccrualInterval;
        let indexingTimerInterval;
        let animationFrameId;
        
        // Point accrual and timer logic
        function startPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            appState.sessionStartTime = Date.now();
            appState.sessionEarnings = 0;
            appState.currentMultiplier = 1.0;
            
            // Start the animation loop
            animateSessionStats();

            // Set different base rates based on entry point
            let baseRate;
            let interval;
            
            if (appState.entryPoint === 'automode') {
                baseRate = 0.25; // 0.25 points per second for automode
                interval = 1000; // Update every second
            } else {
                baseRate = 0.1; // 0.1 points per second for show detection
                interval = 1000; // Update every second
            }

            pointAccrualInterval = setInterval(() => {
                let pointsThisInterval = baseRate * appState.currentMultiplier;
                
                // Apply Ludicrous Speed acceleration to points if active
                if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                    const speedMultiplier = window.LudicrousSpeedManager.currentSpeed || 300;
                    pointsThisInterval = pointsThisInterval * speedMultiplier;
                    console.log(`🚀 LUDICROUS POINTS: Accelerated points to ${pointsThisInterval.toFixed(2)} (${speedMultiplier}x speed)`);
                }
                
                appState.sessionEarnings += pointsThisInterval;
                Tracker.logRumiAction('Points accrued in session', {
                    amount: pointsThisInterval,
                    sessionTotal: appState.sessionEarnings,
                    baseRate: baseRate,
                    mode: appState.entryPoint
                });
                
                // Update the points display in real-time
                updatePointsDisplay();
                // Also update the holistic-progress counter in real-time
                let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Apply Ludicrous Speed acceleration to elapsed time for animation
                if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                    const speedMultiplier = window.LudicrousSpeedManager.currentSpeed || 300;
                    elapsedTime = elapsedTime * speedMultiplier;
                }
                
                updateAnimationPanel(elapsedTime);
            }, interval);
        }

        function stopPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        }

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Enhanced Nokia animation with show indexing integration
        let currentIndexingShow = null;
        let animationUpdateInterval = null;
        let lastShowUpdate = 0;
        let lastUpdateTime = 0;

        const getTonalCharacter = (originalChar, revealProgress) => {
            if (originalChar === '#') {
                if (revealProgress > 0.85) return '#';
                if (revealProgress > 0.7) return 'X';
                if (revealProgress > 0.55) return 'O';
                if (revealProgress > 0.4) return 'o';
                return '.';
            }
            if (originalChar === '=' || originalChar === '|' || originalChar === '+' || originalChar === '/' || originalChar === '~' || originalChar === '<' || originalChar === '>' || originalChar === ':' || originalChar === '{' || originalChar === '}' || originalChar === '[' || originalChar === ']' || originalChar === '^' || originalChar === 'v' || originalChar === 'W' || originalChar === '8' || originalChar === '@' || originalChar === '0' || originalChar === '%' || originalChar === '&' || originalChar === '$') {
                 if (revealProgress > 0.8) return 'X';
                if (revealProgress > 0.65) return 'O';
                if (revealProgress > 0.5) return 'o';
                if (revealProgress > 0.35) return '.';
                return '.';
            }
            return originalChar;
        };

        function renderReveal(template, progress, width, height) {
            let display = Array(height).fill('.'.repeat(width));
            if (!template) return display;

            const allTemplateChars = [];
            for (let y = 0; y < height; y++) {
                const row = template[y] || '';
                for (let x = 0; x < width; x++) {
                    if (row[x] && row[x] !== ' ') {
                        allTemplateChars.push({ char: row[x], x, y });
                    }
                }
            }
            allTemplateChars.sort((a, b) => a.y - b.y || a.x - b.x);

            const totalPixels = allTemplateChars.length;
            const pixelsToShow = Math.floor(totalPixels * progress);
            
            for (let i = 0; i < pixelsToShow; i++) {
                const { char, x, y } = allTemplateChars[i];
                const pixelProgress = pixelsToShow > 1 ? (i / (pixelsToShow - 1)) : 1;
                let rowArray = display[y].split('');
                rowArray[x] = getTonalCharacter(char, pixelProgress);
                display[y] = rowArray.join('');
            }
            return display;
        }

        function renderCrossfade(oldTemplate, newTemplate, progress, width, height) {
            // Add null checks to prevent TypeError
            if (!oldTemplate || !newTemplate || !Array.isArray(oldTemplate) || !Array.isArray(newTemplate)) {
                return Array(height).fill('.'.repeat(width));
            }
            
            let display = Array(height).fill('.'.repeat(width));
            for (let y = 0; y < height; y++) {
                let rowArray = display[y].split('');
                for (let x = 0; x < width; x++) {
                    const oldChar = oldTemplate[y]?.[x] || ' ';
                    const newChar = newTemplate[y]?.[x] || ' ';
                    
                    const oldCharRender = (oldChar !== ' ' && oldChar !== '.') ? getTonalCharacter(oldChar, 1 - progress) : '.';
                    const newCharRender = (newChar !== ' ' && newChar !== '.') ? getTonalCharacter(newChar, progress) : '.';
                    
                    rowArray[x] = (newCharRender !== '.') ? newCharRender : oldCharRender;
                }
                display[y] = rowArray.join('');
            }
            return display;
        }

        function updateAnimationPanel(elapsedTime) {
            const holisticInfo = document.getElementById('holistic-show-info');
            const panel = document.getElementById('animation-panel-content');
            const holisticProgress = document.getElementById('holistic-progress');

            if (!panel || !holisticInfo || !holisticProgress) return;
            
            // Apply automode styling based on entry point
            if (appState.entryPoint === 'automode') {
                panel.classList.add('automode');
            } else {
                panel.classList.remove('automode');
            }
            
            const width = 28;
            const height = 6;
            
            let showTitle = 'INDEXING';
            let showType = 'data';
            let showDetails = `Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;

            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                showTitle = appState.detectedShow.title.toUpperCase();
                showType = appState.detectedShow.genre ? appState.detectedShow.genre.toLowerCase() : 'data';
                
                if (appState.detectedShow.season !== 'N/A') {
                    showDetails = `S${appState.detectedShow.season} E${appState.detectedShow.episode} | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                } else {
                    showDetails = `FILM | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                }
            } else if (appState.entryPoint === 'automode') {
                showTitle = 'AUTOMODE TRAINING';
                showType = 'automode';
                showDetails = `Bucket: ${appState.currentBucket || 'Content Intelligence'} | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
            }
            
            holisticInfo.innerHTML = `<strong>INDEXING</strong>`;

            const asciiTemplates = {
                drama: [
                    ["    ################    ","   ##<<<<<<<<<<<<##   ","  ####################  "," ##>>>>>>>>>>>>## ","########################"," ##<<<<<<<<<<<<## "],
                    ["  ####################  "," ##////////////## ","########################"," ##\\\\\\\\\\\\## "," ##////////////## "," ###################### "]
                ],
                scifi: [
                    ["  ########################  ","    ##||||||||||||||||##    ","   ##..####....####....##   ","     ##<<<<<<>>>>>>##     ","   ##..####....####....##   ","  ########################  "],
                    ["          ########          ","        ##========##        ","    ####################    ","      ##////////////##      ","      ##~~~~~~~~~~~~##      ","          ########          "]
                ],
                comedy: [
                    ["    ################    ","   ##~~~~~~~~~~~~##   ","  ####################  "," ##^^^^^^^^^^^^## ","########################"," ##vvvvvvvvvvvv## "],
                    ["  ####################  "," ##{{{{{{{{{{{{## ","########################"," ##}}}}}}}}}}}}## "," ##[[[[[[[[[[[[## "," ###################### "]
                ],
                general: [
                    ["    ################    ","   ##WWWWWWWWWWWW##   ","  ####################  "," ################## ","########################"," ##888888888888## "],
                    ["  ####################  "," ##@@@@@@@@@@@@@@@@## ","########################"," ##000000000000## "," ##%%%%%%%%%%%%## "," ###################### "]
                ],
                data: [
                    ["      ##########        ","    ##&&&&&&##      ","  ##################    "," ##$$$$$$$$$$$$## ","  ##++++++++++++##    ","    ################      "],
                    ["########################","##==============##","##....................##","##>>>>>>>>>>>>##","##::::::::::::##","########################"]
                ],
                automode: [
                    ["  ########################  ","    ##||||||||||||||||##    ","   ##..####....####....##   ","     ##<<<<<<>>>>>>##     ","   ##..####....####....##   ","  ########################  "],
                    ["          ########          ","        ##========##        ","    ####################    ","      ##////////////##      ","      ##~~~~~~~~~~~~##      ","          ########          "],
                    ["    ################    ","   ##WWWWWWWWWWWW##   ","  ####################  "," ################## ","########################"," ##888888888888## "]
                ]
            };
            
            // Choose templates based on entry point
            let currentTemplates;
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // Show detection: use genre-based templates
                currentTemplates = asciiTemplates[showType] || asciiTemplates.general;
            } else if (appState.entryPoint === 'automode') {
                // Automode: use automode-specific templates
                currentTemplates = asciiTemplates.automode;
            } else {
                // Fallback to general templates
                currentTemplates = asciiTemplates.general;
            }
            
            // Function to shift animation patterns from right to left for automode
            function shiftPatternRightToLeft(pattern, shiftAmount) {
                return pattern.map(row => {
                    const shift = Math.floor(shiftAmount) % row.length;
                    return row.substring(shift) + row.substring(0, shift);
                });
            }
            
            const templateDuration = 3.0;
            const revealDuration = 2.0;
            const holdDuration = 0.5;
            const transitionDuration = 0.5;

            const cycleTime = elapsedTime % templateDuration;
            const currentTemplateIndex = Math.floor(elapsedTime / templateDuration) % currentTemplates.length;
            const nextTemplateIndex = (currentTemplateIndex + 1) % currentTemplates.length;

            let currentTemplate = currentTemplates[currentTemplateIndex];
            let nextTemplate = currentTemplates[nextTemplateIndex];
            
            // Apply right-to-left movement for automode
            if (appState.entryPoint === 'automode') {
                const shiftSpeed = 0.3; // characters per second
                const shiftAmount = elapsedTime * shiftSpeed;
                currentTemplate = shiftPatternRightToLeft(currentTemplate, shiftAmount);
                nextTemplate = shiftPatternRightToLeft(nextTemplate, shiftAmount);
            }

            let displayGrid;

            if (cycleTime < revealDuration) {
                const revealProgress = cycleTime / revealDuration;
                displayGrid = renderReveal(currentTemplate, revealProgress, width, height);
            } else if (cycleTime < revealDuration + holdDuration) {
                displayGrid = renderReveal(currentTemplate, 1.0, width, height);
                            } else {
                const transitionProgress = (cycleTime - (revealDuration + holdDuration)) / transitionDuration;
                displayGrid = renderCrossfade(currentTemplate, nextTemplate, transitionProgress, width, height);
            }

            let bottomText = '';
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // Show detection mode: handle content transitions
                    // For show detection, we need to create content items from the detected show
                    // and any additional content from the genre channel
                    if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                        // Create content items from detected show and genre channel content
                        const detectedShowItem = {
                        title: appState.detectedShow.title,
                        duration: appState.detectedShow.duration || 60,
                            type: 'detected_show'
                        };
                        
                        // Add detected show as first item
                        appState.automodeContentItems = [detectedShowItem];
                        appState.currentContentIndex = 0;
                        appState.contentItemStartTime = 0;
                        appState.contentItemDuration = detectedShowItem.duration * 60; // Convert to seconds
                    }
                    
                    // Use the same content item transition logic as automode
                    updateCurrentContentItem(elapsedTime);
                    
                    // Get current and next content items
                    const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                    const nextItem = appState.automodeContentItems[appState.currentContentIndex + 1];
                    
                    if (currentItem && currentItem.title) {
                        // Calculate time within current content item
                        const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
                        
                        // Define transition timing
                        const transitionDuration = 2.0; // 2 seconds for sliding transition
                        const transitionStart = Math.max(0, appState.contentItemDuration - transitionDuration);
                        
                        if (timeInCurrentItem < transitionStart) {
                            // Normal display phase - just scroll the current item
                            bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                        } else if (timeInCurrentItem >= transitionStart && timeInCurrentItem < appState.contentItemDuration) {
                            // Sliding transition phase
                            const transitionProgress = (timeInCurrentItem - transitionStart) / transitionDuration;
                            
                            const currentTitle = currentItem.title;
                            const nextTitle = nextItem && nextItem.title ? nextItem.title : 'Session complete';
                            
                            // Create sliding effect: current title slides left, next title slides in from right
                            const slideDistance = Math.floor(transitionProgress * (width - 2));
                            const currentText = currentTitle.padEnd(width - 2).substring(slideDistance);
                            const nextText = nextTitle.padStart(width - 2).substring(0, slideDistance);
                            
                            // Combine for sliding effect
                            bottomText = (currentText + nextText).substring(0, width - 2);
                        } else if (timeInCurrentItem >= appState.contentItemDuration) {
                            // Item finished, move to next
                            moveToNextContentItem(elapsedTime);
                            
                            // After moving to next item, show the current item (which is now the new episode)
                            const updatedCurrentItem = appState.automodeContentItems[appState.currentContentIndex];
                            if (updatedCurrentItem && updatedCurrentItem.title) {
                                bottomText = scrollText(updatedCurrentItem.title, elapsedTime, width - 2);
                            } else {
                                bottomText = "Session complete";
                            }
                        } else {
                            // Fallback
                            bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                        }
                    } else {
                        bottomText = 'No content available';
                    }
            } else if (appState.entryPoint === 'automode') {
                    // For automode, use existing logic
                    if (appState.automodeContentItems.length > 0) {
                        // Use the same content item transition logic as automode
                        updateCurrentContentItem(elapsedTime);
                        
                        // Get current and next content items
                        const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                        const nextItem = appState.automodeContentItems[appState.currentContentIndex + 1];
                        
                        if (currentItem && currentItem.title) {
                            // Calculate time within current content item
                            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
                            
                            // Define transition timing
                            const transitionDuration = 2.0; // 2 seconds for sliding transition
                            const transitionStart = Math.max(0, appState.contentItemDuration - transitionDuration);
                            
                            if (timeInCurrentItem < transitionStart) {
                                // Normal display phase - just scroll the current item
                                bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                            } else if (timeInCurrentItem >= transitionStart && timeInCurrentItem < appState.contentItemDuration) {
                                // Sliding transition phase
                                const transitionProgress = (timeInCurrentItem - transitionStart) / transitionDuration;
                                
                                const currentTitle = currentItem.title;
                                const nextTitle = nextItem && nextItem.title ? nextItem.title : 'Session complete';
                                
                                // Create sliding effect: current title slides left, next title slides in from right
                                const slideDistance = Math.floor(transitionProgress * (width - 2));
                                const currentText = currentTitle.padEnd(width - 2).substring(slideDistance);
                                const nextText = nextTitle.padStart(width - 2).substring(0, slideDistance);
                                
                                // Combine for sliding effect
                                bottomText = (currentText + nextText).substring(0, width - 2);
                            } else if (timeInCurrentItem >= appState.contentItemDuration) {
                                // Item finished, move to next
                                moveToNextContentItem(elapsedTime);
                                
                                // After moving to next item, show the current item (which is now the new episode)
                                const updatedCurrentItem = appState.automodeContentItems[appState.currentContentIndex];
                                if (updatedCurrentItem && updatedCurrentItem.title) {
                                    bottomText = scrollText(updatedCurrentItem.title, elapsedTime, width - 2);
                                } else {
                                    bottomText = "Session complete";
                                }
                            } else {
                                // Fallback
                                bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                            }
                        } else {
                            bottomText = 'No content available';
                        }
                    } else {
                        // Show dynamic learning content instead of "Training in progress..."
                        bottomText = generateLearningText();
                    }
            } else {
                // Fallback
                bottomText = 'Indexing...';
            }

            if (displayGrid && displayGrid.length === height) {
                displayGrid[height - 1] = bottomText;
            }
            
            panel.innerHTML = displayGrid.join('\n');

            // --- Progress Bar Logic ---
            const sessionDuration = calculateSessionDuration();
            const barWidth = 28;

            // Calculate progress
            const progress = Math.min(elapsedTime / sessionDuration, 1);
            const filledWidth = Math.floor(progress * barWidth);
            let progressBar = '█'.repeat(filledWidth);
            let placeholder = '░'.repeat(barWidth - filledWidth);
            
            // Define multiplier milestones based on timeline patterns from channels
            const multiplierMilestones = [
                { time: 0, multiplier: 1.0 },      // Start
                { time: 0.25, multiplier: 1.2 },   // 25% of session (1.2x milestone)
                { time: 0.5, multiplier: 1.5 },    // 50% of session (1.5x milestone) 
                { time: 0.75, multiplier: 1.8 }    // 75% of session (1.8x milestone)
            ];
            
            // Add glints for each milestone
            multiplierMilestones.forEach((milestone, index) => {
                if (index === 0) return; // Skip the starting milestone
                
                const milestonePosition = Math.floor(milestone.time * barWidth);
                
                if (elapsedTime < (milestone.time * sessionDuration)) {
                    // Milestone not yet reached - show glint in placeholder
                    if (milestonePosition > filledWidth) {
                let placeholderArray = placeholder.split('');
                        const glintIndex = milestonePosition - filledWidth - 1;
                if (glintIndex >= 0 && glintIndex < placeholderArray.length) {
                            placeholderArray[glintIndex] = '◆';
                }
                placeholder = placeholderArray.join('');
            }
                } else {
                    // Milestone reached - show glint in filled bar
                    if (milestonePosition <= filledWidth) {
                let barArray = progressBar.split('');
                        if (milestonePosition - 1 < barArray.length) {
                            barArray[milestonePosition - 1] = '◆';
                }
                progressBar = barArray.join('');
            }
                }
            });
            
            progressBar += placeholder;

            const runningTime = formatRunningTime(elapsedTime);
            const visualProgressBar = progressBar;
            
            holisticProgress.innerHTML = `
                <div style='text-align:center; font-size:13px; font-weight:bold; margin-bottom: 4px;'>${runningTime}</div>
                <div style='text-align:center; font-family: monospace; font-size: 12px; color: #ffff00;'>${visualProgressBar}</div>
            `;
        }

        // NEW: Helper function to update current content item
        function updateCurrentContentItem(elapsedTime) {
            if (!appState.automodeContentItems.length) return;
            
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Check if we need to move to next item
            if (timeInCurrentItem >= appState.contentItemDuration) {
                moveToNextContentItem(elapsedTime);
            }
        }

        // NEW: Helper function to move to next content item
        function moveToNextContentItem(elapsedTime) {
            if (appState.automodeContentItems.length > 0 && appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                appState.currentContentIndex++;
                appState.contentItemStartTime = elapsedTime;
                
                // Calculate duration for new content item
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                        const durationParts = currentItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        appState.contentItemDuration = currentItem.duration;
                    }
                }
                
                // Update automode progress text
                updateAutomodeProgressText();
                
                Tracker.logRumiAction('Content item transitioned', { 
                    newItem: currentItem.title,
                    index: appState.currentContentIndex
                });
            } else {
                // Reached end of all content - trigger session completion
                console.log('End of channel content reached - completing session');
                
                if (!appState.sessionCompleted) {
                    appState.sessionCompleted = true;
                    appState.sessionEndReason = 'content_complete';
                    
                    Tracker.logRumiAction('Session completed - end of content', { 
                        entryPoint: appState.entryPoint,
                        totalContentItems: appState.automodeContentItems.length,
                        completedIndex: appState.currentContentIndex
                    });
                    
                    // Give user 2 seconds to see "Session complete" message, then show receipt
                    setTimeout(() => {
                        stopIndexing();
                    }, 2000);
                }
            }
        }

        // Generate dynamic learning text for ASCII art display
        function generateLearningText() {
            console.log('generateLearningText: automodeContentItems length:', appState.automodeContentItems?.length, 'currentContentIndex:', appState.currentContentIndex);
            console.log('generateLearningText: appState.entryPoint:', appState.entryPoint);
            console.log('generateLearningText: appState.isIndexing:', appState.isIndexing);
            
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0 && appState.currentContentIndex >= 0) {
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                console.log('generateLearningText: currentItem:', currentItem);
                
                if (currentItem) {
                    // Extract show name and episode info from title
                    const title = currentItem.title;
                    
                    // Parse title to get show name and episode
                    let showName = title;
                    let episodeInfo = '';
                    
                    // Handle different title formats
                    if (title.includes('S') && title.includes('E')) {
                        // Format like "Breaking Bad S01E01 - Pilot"
                        const match = title.match(/^(.+?)\s+(S\d+E\d+)/);
                        if (match) {
                            showName = match[1];
                            episodeInfo = match[2];
                        }
                    } else if (title.includes('Season') && title.includes('Episode')) {
                        // Format like "Show Name Season 1 Episode 2"
                        const match = title.match(/^(.+?)\s+Season\s+(\d+)\s+Episode\s+(\d+)/);
                        if (match) {
                            showName = match[1];
                            episodeInfo = `S${match[2]}E${match[3]}`;
                        }
                    }
                    
                    // Use the description field for more granular learning content
                    let learningContent = 'content analysis';
                    if (currentItem.description) {
                        learningContent = currentItem.description.toLowerCase();
                        // Truncate description if too long (increased limit)
                        if (learningContent.length > 40) {
                            learningContent = learningContent.substring(0, 37) + '...';
                        }
                    }
                    
                    // Create learning text
                    const learningText = `${showName} ${episodeInfo} learning ${learningContent}`;
                    
                    // Truncate if too long for display (increased limit for ASCII art)
                    if (learningText.length > 50) {
                        return learningText.substring(0, 47) + '...';
                    }
                    
                    console.log('generateLearningText: returning:', learningText);
                    return learningText;
                }
            }
            
            // Fallback
            console.log('generateLearningText: returning fallback');
            return 'Loading learning content...';
        }

        // Update points display
        function updatePointsDisplay() {
            const primaryDisplay = document.getElementById('points-primary-display');
            const secondaryDisplay = document.getElementById('points-secondary-display');
            
            if (!primaryDisplay || !secondaryDisplay) return;

            if (appState.isIndexing) {
                // Calculate real-time session points during indexing
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                const realTimeSessionPoints = (appState.baseRate || 0.1) * appState.currentMultiplier * elapsedTime;
                
                // In-session view: Pending validation is primary
                const totalPending = appState.totalPendingPoints + realTimeSessionPoints;
                primaryDisplay.textContent = `${totalPending.toFixed(2)} PENDING VALIDATION`;
                
                const sessionStr = `Current: +${realTimeSessionPoints.toFixed(2)} @ ${appState.currentMultiplier.toFixed(1)}x`;
                const earnedStr = `Lifetime: ${Math.floor(appState.pointsEarned).toLocaleString()}`;
                secondaryDisplay.textContent = `${sessionStr} | ${earnedStr}`;

            } else {
                // Default view: Total earned is primary
                primaryDisplay.textContent = `${Math.floor(appState.pointsEarned).toLocaleString()} LIFETIME POINTS`;
                secondaryDisplay.textContent = `+${Math.floor(appState.totalPendingPoints).toLocaleString()} pending from today`;
            }
        }

        // Legacy function for compatibility
        function startWatching() {
            toggleIndexing();
        }

        // Test functions
        function testHomeScreen() {
            console.log('testHomeScreen called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testHomeScreenFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        function testChannels() {
            console.log('testChannels called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testChannelsFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        function showState() {
            console.log('showState called');
            console.log('Current App State:', appState);
            if (typeof Tracker !== 'undefined') {
                Tracker.logRumiState(appState);
            } else {
                console.error('Tracker not available');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded');
            setTimeout(initApp, 100);
            initializeEntryPoint(); // Setup the launcher panel
        });

        // --- Error State Management via Message Area ---
        let wasIndexingBeforeError = false;

        function setErrorState(errorType) {
            // Save if we were indexing before error, but DON'T stop indexing
            if (errorType && appState.isIndexing) {
                wasIndexingBeforeError = true;
                // Pause indexing when error occurs
                pauseIndexing();
            }

            // Hide all error-state panels (legacy, just in case)
            document.querySelectorAll('.error-state').forEach(el => {
                if (el && el.style) el.style.display = 'none';
            });
            
            // Show error in message area using new expandable functionality
            if (errorType) {
                // Map old error types to new ones for compatibility
                let newErrorType = errorType;
                switch (errorType) {
                    case 'volume':
                        newErrorType = 'user-error';
                        break;
                    case 'connection':
                        newErrorType = 'system-error';
                        break;
                    case 'loading':
                        newErrorType = 'loading';
                        break;
                    case 'offline':
                        newErrorType = 'offline';
                        break;
                    case 'show-interrupt':
                        newErrorType = 'show-interrupt';
                        break;
                }
                
                updateMessageArea(newErrorType);
                autoExpandSections(newErrorType);
                appState.errorState = errorType;
                Tracker.logRumiAction('ERROR_STATE_SET', { errorType, timestamp: Date.now() });
            } else {
                // Clear error state
                updateMessageArea('normal');
                appState.errorState = null;
                Tracker.logRumiAction('ERROR_STATE_CLEARED', { timestamp: Date.now() });
                // Resume indexing if it was active before error
                if (wasIndexingBeforeError) {
                    wasIndexingBeforeError = false;
                    // Resume indexing using the new pause/resume system
                    resumeIndexing();
                }
            }
            updateUI();
            updateDebugButtonStates(); // Update debug button states when error state changes
        }

        function handleVolumeError() {
            setErrorState('volume');
            // Update the volume display
            const volumeDisplay = document.getElementById('current-volume-display');
            if (volumeDisplay) {
                volumeDisplay.textContent = `${appState.volumeLevel}%`;
            }
            Tracker.logRumiAction('VOLUME_ERROR_DETECTED', { 
                currentVolume: appState.volumeLevel,
                requiredVolume: 100 
            });
        }

        function handleConnectionLost() {
            setErrorState('connection');
            Tracker.logRumiAction('CONNECTION_LOST', { 
                sessionDuration: appState.isIndexing ? Date.now() - appState.indexingStartTime : 0 
            });
        }

        function handleLoadingState() {
            setErrorState('loading');
            Tracker.logRumiAction('LOADING_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function handleOfflineState() {
            setErrorState('offline');
            Tracker.logRumiAction('OFFLINE_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function clearErrorState() {
            setErrorState(null);
        }

        // Error Recovery Functions
        function retryConnection() {
            Tracker.logRumiAction('CONNECTION_RETRY_ATTEMPTED', { timestamp: Date.now() });
            
            // Simulate connection retry
            setTimeout(() => {
                clearErrorState();
                Tracker.logRumiAction('CONNECTION_RESTORED', { timestamp: Date.now() });
            }, 2000);
        }

        function resumeSession() {
            if (appState.volumeLevel >= 100) {
                clearErrorState();
                Tracker.logRumiAction('SESSION_RESUMED', { timestamp: Date.now() });
            } else {
                // Update the volume display to show current level
                const volumeDisplay = document.getElementById('current-volume-display');
                if (volumeDisplay) {
                    volumeDisplay.textContent = `${appState.volumeLevel}%`;
                }
                Tracker.logRumiAction('SESSION_RESUME_FAILED', { 
                    reason: 'Volume still below 100%',
                    currentVolume: appState.volumeLevel 
                });
            }
        }

        // Test Functions for Error States
        function testVolumeError() {
            appState.volumeLevel = 20;
            handleVolumeError();
        }

        function testVolumeRestored() {
            appState.volumeLevel = 100;
            // This will trigger auto-resume in monitorVolume
            Tracker.logRumiAction('Volume restored for testing', { volumeLevel: appState.volumeLevel });
        }

        function testConnectionLost() {
            handleConnectionLost();
        }

        function testLoadingState() {
            handleLoadingState();
            // Auto-clear after 3 seconds
            setTimeout(() => {
                clearErrorState();
            }, 3000);
        }

        function testOfflineState() {
            handleOfflineState();
        }

        // Error State Compression (for mobile)
        function compressErrorState() {
            const errorStates = document.querySelectorAll('.error-state');
            errorStates.forEach(state => {
                state.style.fontSize = '0.8em';
                state.style.padding = '8px';
            });
        }

        // Monitor volume changes (simulated)
        function monitorVolume() {
            // Simulate volume monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger volume errors if we're already in a volume error state
                if (appState.errorState === 'volume') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && appState.volumeLevel < 100) {
                    handleVolumeError();
                }
                // Note: Removed auto-resume to prevent cycling - user must manually resolve
            }, 5000);
        }

        // Monitor connection status (simulated)
        function monitorConnection() {
            // Simulate connection monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger connection errors if we're already in a connection error state
                if (appState.errorState === 'connection') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && Math.random() < 0.1) {
                    handleConnectionLost();
                }
            }, 10000);
        }

        function showSettingsView() {
            Tracker.logRumiAction('Settings view shown');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="showMainView()">← BACK</button>';
            // }
            
            // Hide main view and show settings view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'block';
            
            appState.view = 'settings';
        }

        // Test function for receipt flow
        function testReceipt() {
            Tracker.testReceiptFlow();
            
            // Simulate a completed session for testing
            const testSessionEarnings = 45.6;
            const testSessionDuration = 930; // 15:30
            const testMultiplier = 1.2;
            
            showReceiptView(testSessionEarnings, testSessionDuration, testMultiplier);
        }

        // Toggle Leaderboard visibility
        function toggleLeaderboard() {
            const leaderboardSection = document.getElementById('leaderboard-section');
            const isExpanded = leaderboardSection.classList.toggle('is-expanded');
            Tracker.logRumiAction('Leaderboard toggled', { expanded: isExpanded });
        }

        // Toggle queue visibility
        function toggleQueue() {
            const queueDetails = document.getElementById('queue-details');
            const queueButton = document.querySelector('.show-queue-button');
            const isExpanded = queueDetails.classList.toggle('is-expanded');

            if (isExpanded) {
                queueButton.textContent = 'Hide Queue ▲';
                updateQueueView(); // Populate the queue when showing
                Tracker.logRumiAction('Queue shown');
            } else {
                queueButton.textContent = 'Show Queue ▼';
                Tracker.logRumiAction('Queue hidden');
            }
        }
        
        // Update Queue View
        function updateQueueView() {
            const queueDetails = document.getElementById('queue-details');
            if (!queueDetails) return;

            // Clear previous items
            queueDetails.innerHTML = '';

            if (appState.queue.length > 0) {
                appState.queue.forEach(item => {
                    const queueItem = document.createElement('div');
                    queueItem.className = 'queue-item';
                    queueItem.textContent = `${item.title} - ${item.details}`;
                    queueDetails.appendChild(queueItem);
                });
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'queue-item';
                noItems.textContent = 'Queue is empty';
                queueDetails.appendChild(noItems);
            }
        }
        
        // Iframe resizing and error handling logic
        function resizeIframe(iframe) {
            console.log('resizeIframe called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Iframe visibility set to visible');
                
                // Integrate content tracking with the loaded channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoading() {
            const loadingDiv = document.getElementById('channel-loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelError() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available');
        }

        // Listen for messages from iframes
        window.addEventListener('message', (event) => {
            // Basic security check
            if (!event.data || !event.data.type) {
                return;
            }

            if (event.data.type === 'rumi:setBucket') {
                const bucket = event.data.payload.bucket;
                if (bucket) {
                    appState.currentBucket = bucket;
                    Tracker.logRumiAction('Bucket changed', { bucket });
                    console.log('Rumi bucket set to:', bucket);
                    updateChannelTitle(); // Update the UI
                    updateUI(); // Update button labels for automode
                }
            }
            
            if (event.data.type === 'rumi:showAdded') {
                const { showTitle, position } = event.data.payload;
                if (showTitle) {
                    console.log(`Show "${showTitle}" added to ${position} of channel`);
                    Tracker.logRumiAction('Show added to channel', { showTitle, position });
                    
                    // Show the detected show UI
                    showDetectedShowUI(showTitle);
                } else {
                    console.warn('Received showAdded message with undefined showTitle');
                }
            }
        });

        // Initialize and update channel title
        function initializeChannelTitle() {
            updateChannelTitle();
        }

        function updateChannelTitle() {
            const channelTitleEl = document.getElementById('channel-title');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Indexing channel functions
        function resizeIframeIndexing(iframe) {
            console.log('resizeIframeIndexing called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Indexing iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting indexing iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Indexing iframe visibility set to visible');
                
                // Integrate content tracking with the loaded indexing channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoadingIndexing() {
            const loadingDiv = document.getElementById('channel-loading-indexing');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelErrorIndexing() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available (indexing)');
        }

        function initializeChannelTitleIndexing() {
            updateChannelTitleIndexing();
        }

        function updateChannelTitleIndexing() {
            const channelTitleEl = document.getElementById('channel-title-indexing');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Channel switching functionality
        let currentChannel = 'rumi'; // 'rumi' or 'genre'
        
        function toggleChannel() {
            // This function is no longer needed - channels are handled automatically
            // based on entry point. Remove the problematic element access.
            console.log('Channel switching is now automatic based on entry point');
        }

        // Function to send show detection to genre channel
        function sendShowDetection(showData) {
            // Don't send if showData is null or undefined
            if (!showData) {
                console.log('Sending show detection: null (skipping)');
                return;
            }
            
            console.log('Sending show detection:', showData);
            
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('detection-channel-frame-indexing');
            
            const message = {
                type: 'rumi:showDetected',
                payload: showData
            };
            
            console.log('Sending message to channel frames:', message);
            
            // Function to send message when iframe is ready
            function sendMessageWhenReady(iframe, frameName) {
                if (iframe && iframe.contentWindow) {
                    // Check if iframe is loaded and ready
                    try {
                        console.log(`Sending to ${frameName} channel frame`);
                        console.log(`${frameName} frame src:`, iframe.src);
                        console.log(`${frameName} frame readyState:`, iframe.contentWindow.document.readyState);
                        console.log(`${frameName} frame document title:`, iframe.contentWindow.document.title);
                        
                        // Check if the iframe is actually pointing to the genre channel
                        if (!iframe.src.includes('Genre-channel_v2.html')) {
                            console.log(`${frameName} frame is not pointing to Genre-channel_v2.html, skipping message`);
                            return false;
                        }
                        
                        iframe.contentWindow.postMessage(message, '*');
                        console.log(`Message sent to ${frameName} frame successfully`);
                        return true;
                    } catch (e) {
                        console.error(`Error sending to ${frameName} frame:`, e);
                        return false;
                    }
                } else {
                    console.error(`${frameName} channel frame not found or not ready`);
                    console.log(`${frameName} frame exists:`, !!iframe);
                    console.log(`${frameName} frame contentWindow exists:`, !!(iframe && iframe.contentWindow));
                    return false;
                }
            }
                
            // Send to both iframes (home and indexing views)
            const homeSent = sendMessageWhenReady(channelFrame, 'home');
            const indexingSent = sendMessageWhenReady(channelFrameIndexing, 'indexing');
            
            if (!homeSent || !indexingSent) {
                // If either frame wasn't ready, try again after a longer delay
                console.log('Some frames not ready, retrying in 2 seconds...');
                setTimeout(() => {
                    sendMessageWhenReady(channelFrame, 'home (retry)');
                    sendMessageWhenReady(channelFrameIndexing, 'indexing (retry)');
                }, 2000);
            }
            
            // Don't automatically populate with backend content - let the channel handle it
            // The genre channel will request content when it's ready
                
            Tracker.logRumiAction('Show detection sent', showData);
        }

        // Test function to simulate show detection
        function testShowDetection() {
            const testShows = [
                {
                    title: 'BREAKING BAD',
                    genre: 'Thriller',
                    service: 'NETFLIX',
                    season: 'S5',
                    episode: 'E16'
                },
                {
                    title: 'STRANGER THINGS',
                    genre: 'Thriller',
                    service: 'NETFLIX',
                    season: 'S4',
                    episode: 'E9'
                },
                {
                    title: 'THE CROWN',
                    genre: 'Drama',
                    service: 'NETFLIX',
                    season: 'S6',
                    episode: 'E10'
                },
                {
                    title: 'BLACK MIRROR',
                    genre: 'Sci-Fi',
                    service: 'NETFLIX',
                    season: 'S6',
                    episode: 'E3'
                }
            ];
            
            const randomShow = testShows[Math.floor(Math.random() * testShows.length)];
            sendShowDetection(randomShow);
        }

        // Test function to manually test the animation
        function testAnimation() {
            console.log('Testing animation manually...');
            
            // Force show the nokia content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.style.display = 'block';
                console.log('Nokia content shown');
            }
            
            // Test the animation panel directly
            const panel = document.getElementById('animation-panel-content');
            if (panel) {
                console.log('Animation panel found, testing with simple content...');
                panel.innerHTML = 'TESTING ANIMATION\n################\n##WORKING####\n################\nTESTING ANIMATION';
                console.log('Set test content to panel');
            } else {
                console.error('Animation panel not found!');
            }
            
            // Also test the session stats panel
            const statsPanel = document.getElementById('session-stats-content');
            if (statsPanel) {
                statsPanel.innerHTML = 'TESTING STATS\nMULTIPLIER: 1.0x\nSESSION: +0.00 | [0:00/30:00]\n############################';
                console.log('Set test content to stats panel');
            }
        }

        // Test function to manually test genre channel population
        function testGenreChannelPopulation() {
            console.log('Testing genre channel population...');
            
            // Set entry point to detection mode
            appState.entryPoint = 'detection';
            
            // Update UI to show genre channel
            updateExpandableChannelUI();
            
            // Create a test show
            const testShow = {
                title: 'Breaking Bad',
                genre: 'Drama',
                service: 'NETFLIX',
                season: 'S5',
                episode: 'E16',
                duration: 47
            };
            
            // Send show detection after a delay to ensure channel is loaded
            setTimeout(() => {
                console.log('Sending test show detection:', testShow);
                sendShowDetection(testShow);
            }, 2000);
        }

        // Function to show detected show UI
        function showDetectedShowUI(showTitle) {
            // The animation will be updated by the main animation loop once it starts.
            // There is no need to force an update here.
            Tracker.logRumiAction('Detected show UI shown', { showTitle });
        }

        // Function to dismiss detected show UI (home view)
        function dismissDetectedShow() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI dismissed');
        }

        // Function to dismiss detected show UI (indexing view)
        function dismissDetectedShowIndexing() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI (indexing) dismissed');
        }

        // Function to update animation when show is detected
        function updateAnimationForShow(showTitle) {
            // Force an immediate animation update with new show data
            if (appState.isIndexing) {
                const now = Date.now();
                const elapsedMilliseconds = (now - appState.indexingStartTime) / 1000;
                updateAnimationPanel(elapsedMilliseconds);
                
                // Log the show detection for animation
                Tracker.logRumiAction('Animation updated for show', { showTitle });
            }
        }

        // Enhanced animation loop with show detection integration
        function animateSessionStats() {
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            updateAnimationPanel(elapsedTime);
            updatePointsDisplay(); // Update points display in real-time at 60fps
            
            // Update automode progress text during indexing for automode sessions
            if (appState.isIndexing && appState.entryPoint === 'automode') {
                updateAutomodeProgressText();
            }
            
            // Continue animation loop at 60fps
            animationFrameId = requestAnimationFrame(animateSessionStats);
        }

        function simulateStreamDetection() {
            const statusEl = document.getElementById('stream-detector-status');
            if (!statusEl) return;

            statusEl.textContent = 'DETECTING...';
            setTimeout(() => {
                statusEl.textContent = 'STREAM DETECTED!';
                // Open extension or perform other action here
            }, 2000);
        }

        function simulateAutomode() {
            // Placeholder for automode campaign logic
            alert('Automode Campaign button clicked!');
        }

        let detectedShow = null;
        const availableShows = [
            { title: 'Stranger Things', genre: 'Thriller', service: 'NETFLIX', season: 'S4', episode: 'E9', duration: 60 },
            { title: 'The Office', genre: 'Comedy', service: 'PEACOCK', season: 'S3', episode: 'E20', duration: 22 },
            { title: 'Blade Runner 2049', genre: 'Sci-Fi', service: 'HBO MAX', season: 'N/A', episode: 'N/A', year: '2017', duration: 164 },
            { title: 'The Crown', genre: 'Drama', service: 'NETFLIX', season: 'S6', episode: 'E10', duration: 58 },
            { title: 'Planet Earth II', genre: 'Documentary', service: 'DISCOVERY+', season: 'S1', episode: 'E1', duration: 60 }
        ];

        // NEW: State for coordinating the genre channel update
        appState.pendingShowForGenreChannel = null;

        function initializeEntryPoint() {
            // Pick a random show on load
            detectedShow = availableShows[Math.floor(Math.random() * availableShows.length)];
            
            const detectorUI = document.getElementById('stream-detector-entry');
            detectorUI.innerHTML = `
                <div class="status">Stream Detected!</div>
                <div class="subtext" style="margin-top: 10px; margin-bottom: 10px;">
                    Select detected show:
                </div>
                <select id="detection-show-select" onchange="changeDetectionShow(this.value)" style="background: #1a1a1a; border: 1px solid #333; color: #ccc; padding: 6px 10px; border-radius: 4px; font-size: 11px; width: 100%; margin-bottom: 10px;">
                    <option value="">Select a show...</option>
                    ${availableShows.map(show => {
                        const episodeInfo = show.season !== 'N/A' ? `S${show.season}E${show.episode}` : `(${show.year})`;
                        return `<option value="${show.title}" ${show.title === detectedShow.title ? 'selected' : ''}>${show.title} ${episodeInfo} - ${show.service}</option>`;
                    }).join('')}
                </select>
                <button class="primary-cta" style="width:100%; padding: 10px 12px; font-size: 12px;" onclick="launchWithDetection()">
                    Launch Rumi & Get Points
                </button>
            `;
            detectorUI.style.cursor = 'default';
        }

        function launchWithDetection() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'block';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const streamDetector = document.getElementById('stream-detector-entry');
            const automodeButton = document.querySelector('.automode-button');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Store the entry point info for when activation happens
            appState.pendingEntryPoint = 'detection';
            appState.pendingDetectedShow = detectedShow;
            
            // Get the selected show from the dropdown
            const showSelect = document.getElementById('detection-show-select');
            if (showSelect && showSelect.value) {
                const selectedShow = availableShows.find(show => show.title === showSelect.value);
                if (selectedShow) {
                    detectedShow = selectedShow;
                    appState.pendingDetectedShow = selectedShow;
                    console.log('Detection show selected:', selectedShow.title);
                }
            }
            
            // Don't set the main entry point yet - wait for activation
            // appState.entryPoint = 'detection';
            // appState.detectedShow = detectedShow;
            
            // Don't update UI yet - wait for activation
            // updateUI();
        }

        // NEW: Function to handle show selection in the detection dropdown
        function changeDetectionShow(showTitle) {
            if (!showTitle) return;
            
            const selectedShow = availableShows.find(show => show.title === showTitle);
            if (selectedShow) {
                detectedShow = selectedShow;
                console.log('Detection show changed to:', selectedShow.title);
                
                // Update the UI to reflect the selected show
                const detectorUI = document.getElementById('stream-detector-entry');
                if (detectorUI) {
                    const showSelect = detectorUI.querySelector('#detection-show-select');
                    if (showSelect) {
                        showSelect.value = showTitle;
                    }
                }
                
                // If we have backend integration, get content for this show's genre
                if (window.RumiBackend && window.RumiBackend.isReady()) {
                    console.log('Getting content for detection show genre:', selectedShow.genre);
                    const relatedContent = window.RumiBackend.filterContentByGenre(selectedShow.genre);
                    console.log(`Found ${relatedContent.length} items for detection show genre: ${selectedShow.genre}`);
                    
                    // Store the content for when the genre channel loads
                    appState.pendingGenreContent = relatedContent.slice(0, 10);
                }
                
                Tracker.logRumiAction('Detection show changed', { 
                    show: selectedShow.title, 
                    genre: selectedShow.genre, 
                    project: 'Rumi Extension' 
                });
            }
        }

        function launchWithAutomode() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'block';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const streamDetector = document.getElementById('stream-detector-entry');
            const automodeButton = document.querySelector('.automode-button');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Set the entry point immediately for UI updates
            appState.entryPoint = 'automode';
            appState.pendingEntryPoint = 'automode';
            
            // Update UI to show the channel
            updateUI();
        }

        function activateExtension() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Activate the circle with visual feedback
            activationCircle.classList.add('activated');
            
            // After a brief delay, remove the deactivated state and proceed
            setTimeout(() => {
                // Remove deactivated state
                popup.classList.remove('deactivated');
                activationCircle.style.display = 'none';
                activationCircle.classList.remove('activated');
                
                // Now proceed with the normal flow based on pending entry point
                if (appState.pendingEntryPoint === 'detection') {
                    // Set the state to show pre-indexing confirmation screen for detection
                    appState.isIndexing = false;
                    appState.entryPoint = 'detection';
                    appState.detectedShow = appState.pendingDetectedShow;
                    appState.pendingShowForGenreChannel = appState.pendingDetectedShow;
                    
                    // Reset channel expansion state for new entry point
                    appState.channelExpanded = false;

                    // Show home content with detection section (pre-indexing confirmation)
                    const homeContent = document.getElementById('home-content');
                    const nokiaContent = document.getElementById('nokia-content');
                    
                    if (homeContent) homeContent.style.display = 'block';
                    if (nokiaContent) nokiaContent.style.display = 'none';

                    // Show the detection section
                    showSection2a();

                    // Update the UI elements within the detection view
                    showDetectedShowUI(appState.pendingDetectedShow.title);

                    // Wait for the genre channel to load before sending show detection
                    setTimeout(() => {
                        // Check if the channel frame is pointing to the genre channel
                        const channelFrame = document.getElementById('channel-frame');
                        const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                        
                        if (channelFrame && channelFrame.src.includes('Genre-channel_v2.html')) {
                            console.log('Genre channel loaded, sending show detection');
                            sendShowDetection(appState.pendingDetectedShow);
                            
                            // If we have pending genre content, populate the channel
                            if (appState.pendingGenreContent && appState.pendingGenreContent.length > 0) {
                                console.log('Populating genre channel with pending content');
                                channelFrame.contentWindow.postMessage({
                                    type: 'populateWithContent',
                                    payload: { 
                                        content: appState.pendingGenreContent,
                                        genre: appState.pendingDetectedShow.genre
                                    }
                                }, '*');
                            }
                        } else {
                            console.log('Genre channel not yet loaded, waiting...');
                            // Wait a bit more and try again
                            setTimeout(() => {
                                sendShowDetection(appState.pendingDetectedShow);
                                
                                // If we have pending genre content, populate the channel
                                if (appState.pendingGenreContent && appState.pendingGenreContent.length > 0) {
                                    console.log('Populating genre channel with pending content (delayed)');
                                    const channelFrame = document.getElementById('channel-frame');
                                    if (channelFrame && channelFrame.contentWindow) {
                                        channelFrame.contentWindow.postMessage({
                                            type: 'populateWithContent',
                                            payload: { 
                                                content: appState.pendingGenreContent,
                                                genre: appState.pendingDetectedShow.genre
                                            }
                                        }, '*');
                                    }
                                }
                            }, 1000);
                        }
                    }, 1000); // Increased delay to ensure channel loads
                    
                } else if (appState.pendingEntryPoint === 'automode') {
                    // Set the state to show pre-indexing confirmation screen for automode
                    appState.isIndexing = false;
                    appState.entryPoint = 'automode';
                    detectedShow = null; // Clear detectedShow for automode

                    // Ensure we're on the Rumi channel for automode
                    currentChannel = 'rumi';
                    
                    // Reset channel expansion state for new entry point
                    appState.channelExpanded = false;
                    
                    // Show pre-indexing confirmation screen for automode
                    showAutomodePreIndexingScreen();
                }
                
                // Clear pending entry point
                appState.pendingEntryPoint = null;
                appState.pendingDetectedShow = null;
                
            }, 500); // 500ms delay for visual feedback
        }

        function updateEntryPointForNextStep() {
            const detectorUI = document.getElementById('stream-detector-entry');
            detectorUI.innerHTML = `
                <div class="status">Indexing in Progress...</div>
                <div class="subtext" style="margin-top: 10px; margin-bottom: 10px;">
                    Current Show: <strong>${detectedShow.title}</strong>
                </div>
                <button class="secondary-button" style="width:100%; padding: 10px 12px; font-size: 12px; border-color: #ffaa00; color: #ffaa00;" onclick="simulateShowChange()">
                    Simulate User Changing Show
                </button>
            `;
        }

        function simulateShowChange() {
            // Pick a new random show
            const newShow = availableShows.find(s => s.title !== detectedShow.title) || availableShows[1];
            
            // Stop current indexing if active
            if (appState.isIndexing) {
            stopIndexing();
            }
            
            // Update the detected show
            detectedShow = newShow;
            appState.detectedShow = newShow;
            appState.pendingShowForGenreChannel = newShow;
            
            // Update the entry point UI
            updateEntryPointForNextStep();
            
            // Send the new show detection
            setTimeout(() => {
                sendShowDetection(newShow);
            }, 500);
        }

        // Cache control toggle function
        function toggleCacheControl() {
            const cacheBtn = document.getElementById('cache-control-btn');
            const isCacheDisabled = cacheBtn.textContent.includes('Disable');
            
            if (isCacheDisabled) {
                // Enable cache
                cacheBtn.textContent = '🗂️ Enable Cache';
                cacheBtn.style.background = '#1a2a1a';
                cacheBtn.style.borderColor = '#00ff41';
                cacheBtn.style.color = '#00ff41';
                
                // Remove cache-busting headers from genre channel iframe
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                if (channelFrame && channelFrame.src.includes('Genre-channel_v2.html')) {
                    channelFrame.src = channelFrame.src.split('?')[0];
                }
                if (channelFrameIndexing && channelFrameIndexing.src.includes('Genre-channel_v2.html')) {
                    channelFrameIndexing.src = channelFrameIndexing.src.split('?')[0];
                }
                
                console.log('Cache enabled - iframes will use cached versions');
            } else {
                // Disable cache
                cacheBtn.textContent = '🗂️ Disable Cache';
                cacheBtn.style.background = '#1a1a1a';
                cacheBtn.style.borderColor = '#666';
                cacheBtn.style.color = '#ccc';
                
                // Add cache-busting parameter to genre channel iframes
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                const timestamp = Date.now();
                
                if (channelFrame && channelFrame.src.includes('Genre-channel_v2.html')) {
                    channelFrame.src = channelFrame.src.split('?')[0] + '?cache=' + timestamp;
                }
                if (channelFrameIndexing && channelFrameIndexing.src.includes('Genre-channel_v2.html')) {
                    channelFrameIndexing.src = channelFrameIndexing.src.split('?')[0] + '?cache=' + timestamp;
                }
                
                console.log('Cache disabled - iframes will reload fresh versions');
            }
        }

        // Add new message listeners for genre channel coordination
        window.addEventListener('message', (event) => {
    const message = event.data;

    if (!message) return; // Ignore empty messages

    console.log('Main window received message:', message);

    switch(message.type) {
        case 'rumi:setBucket': {
            const { bucket } = message.payload;
            if (bucket) {
                appState.currentBucket = bucket;
                console.log('Rumi channel bucket updated:', appState.currentBucket);
            }
            break;
        }
        case 'genreChannelReady': {
            console.log('Genre channel ready, sending pending show detection');
            if (appState.pendingShowForGenreChannel) {
                // Add a small delay to ensure the channel is fully initialized
                setTimeout(() => {
                    sendShowDetection(appState.pendingShowForGenreChannel);
                }, 500);
            }
            break;
        }
        case 'rumiChannelReady': {
            // Rumi channel is ready, no special action needed for automode
            console.log('Rumi channel ready');
            break;
        }
        case 'genreChangeComplete': {
            if (appState.pendingShowForGenreChannel) {
                // Now that the genre channel is confirmed to be updated, start indexing.
                startIndexing();
                updateEntryPointForNextStep();
                
                // Clear the pending state
                appState.pendingShowForGenreChannel = null;
            }
            break;
        }
        case 'showDetectionReceived': {
            console.log('Genre channel confirmed show detection received:', message.payload);
            break;
        }
        case 'contentPopulationComplete': {
            console.log('Genre channel content population complete:', message.payload);
            
            // Don't automatically start indexing - let user confirm first
            // The pre-indexing confirmation screen should handle this
            break;
        }
    }
});

        // Entry Point 1: Launch with a detected show
        function launchWithShowDetection(show) {
            if (!show) return;

            appState.entryPoint = 'detection'; // Changed from 'showDetection' to 'detection'
            Tracker.logRumiAction('Launch via show detection', { showTitle: show.title });

            // Set the detected show state immediately
            updateDetectedShowState(show); // Pass the whole show object

            // Switch to the Genre Channel view programmatically
            switchToGenreChannel();

            // Store the show data to be sent after the channel is ready
            appState.pendingShowForGenreChannel = show;
            
            // Show start-indexing screen for detection entry point
            showStartIndexingScreen(show);
        }

        // Function to switch to genre channel view
        function switchToGenreChannel() {
            console.log('Switching to genre channel view...');
            
            // Update the channel frame to point to the genre channel
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('detection-channel-frame-indexing');
            
            if (channelFrame && channelFrame.src !== 'Genre-channel_v2.html') {
                console.log('Updating home channel frame to Genre-channel_v2.html');
                channelFrame.src = 'Genre-channel_v2.html';
            }
            
            if (channelFrameIndexing && channelFrameIndexing.src !== 'Genre-channel_v2.html') {
                console.log('Updating indexing channel frame to Genre-channel_v2.html');
                channelFrameIndexing.src = 'Genre-channel_v2.html';
            }
            
            // Update the current channel state
            appState.currentChannel = 'genre';
            
            console.log('Genre channel view activated');
            Tracker.logRumiAction('Switched to genre channel view');
        }

        // This function sets the application state when a show is detected.
        // It's a key part of the entry point 1 flow.
        function updateDetectedShowState(show) {
            appState.detectedShow = show;
            showDetectedShowUI(show.title);
        }

        // NEW: Show start-indexing screen for detection entry point
        function showStartIndexingScreen(show) {
            console.log('Showing start-indexing screen for detection entry point...');
            
            // Hide home content and show nokia content (indexing view)
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'none';
            if (nokiaContent) nokiaContent.style.display = 'block';
            
            // Set up content for detection mode
            appState.indexingStartTime = Date.now();
            appState.sessionDuration = calculateSessionDuration();
            
            if (appState.detectedShow) {
                const contentItems = getShowDetectionContent(appState.detectedShow, appState.sessionDuration);
                appState.automodeContentItems = contentItems;
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0;
                appState.contentItemDuration = contentItems[0] ? contentItems[0].duration * 60 : 3600; // Convert to seconds
            }
            
            // Populate start-indexing content
            const startIndexingContent = document.getElementById('start-indexing-content');
            if (startIndexingContent) {
            startIndexingContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 14px; font-weight: 700; color: #00ff41; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                        🎯 Show Detected
                    </div>
                    <div style="font-size: 12px; color: #ccc; margin-bottom: 16px;">
                        Ready to start indexing session
                    </div>
                </div>
                
                <!-- Detected Show Info -->
                <div style="background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 16px; border-radius: 8px; border: 1px solid #00ff41; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;">${show.title.toUpperCase()}</div>
                            <div style="font-size: 11px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">
                                ${show.season !== 'N/A' ? `S${show.season} E${show.episode}` : 'FILM'} | ${show.service} | ${show.duration}min
                            </div>
                            <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                                Genre: ${show.genre || 'Unknown'} | Multiplier: ${appState.currentMultiplier.toFixed(1)}x
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Session Info -->
                <div style="background: #222; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 20px;">
                    <div style="font-size: 11px; color: #ccc; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">
                        Session Configuration
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888; margin-bottom: 4px;">
                        <span>Duration:</span>
                        <span>${calculateSessionDuration()} minutes</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888; margin-bottom: 4px;">
                        <span>Base Rate:</span>
                        <span>${appState.baseRate || 0.1} points/min</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888; margin-bottom: 4px;">
                        <span>Multiplier:</span>
                        <span>${appState.currentMultiplier.toFixed(1)}x</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #888;">
                        <span>Projected Points:</span>
                        <span style="color: #00ff41; font-weight: 600;">${(calculateSessionDuration() * (appState.baseRate || 0.1) * appState.currentMultiplier).toFixed(1)}</span>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="startDetectionIndexing()" class="primary-cta" style="width: 100%;">
                        START WATCHING ${show.title}${show.season !== 'N/A' ? ` S${show.season}E${show.episode}` : ''}
                    </button>
                    <button onclick="returnToHomeFromStartIndexing()" style="background: #333; border: 1px solid #555; color: #ccc; padding: 12px; border-radius: 6px; font-size: 12px; cursor: pointer; width: 100%;">
                        CANCEL
                    </button>
                </div>
            `;
            }
            
            console.log('Start-indexing screen displayed for detection entry point');
        }

        // Section 1A: Enable Extension Function
        function enableExtension() {
            console.log('Extension activation requested...');
            // This would normally activate the browser extension
            // For now, just show a success message
            setMessageState('success', '✅ Extension activated successfully', true);
            document.getElementById('success-details-content').innerHTML = `
                <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                    <strong>Extension Status:</strong> ✅ ACTIVATED<br>
                    <strong>Content Detection:</strong> Ready<br>
                    <strong>Audio Analysis:</strong> Enabled<br>
                    <strong>Timestamp:</strong> ${new Date().toLocaleTimeString()}
                </div>
            `;
        }

        // Section 2a: Start Detection Indexing Function
        function startDetectionIndexing() {
            console.log('Starting detection indexing...');
            
            // Set app state to start indexing
            appState.isIndexing = true;
            appState.indexingStartTime = Date.now();
            appState.sessionDuration = calculateSessionDuration();
            
            // Set up content for detection mode
            if (appState.detectedShow) {
                const contentItems = getShowDetectionContent(appState.detectedShow, appState.sessionDuration);
                appState.automodeContentItems = contentItems;
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0;
                appState.contentItemDuration = contentItems[0] ? parseFloat(contentItems[0].duration) * 60 : 3600;
            }
            
            // Start points earning
            startPointsEarning();
            
            // Initialize backend if available
            if (window.RumiBackend) {
                window.RumiBackend.startSession();
                console.log('Backend session started');
            }
            
            // Show the indexing view (nokia content) - Section 3a
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'none';
            if (nokiaContent) nokiaContent.style.display = 'block';
            
            // Update UI to show indexing mode
            updateUI();
            
            // Explicitly show the detection channel section for indexing view
            const detectionChannelSection = document.getElementById('detection-channel-section-indexing');
            if (detectionChannelSection) {
                detectionChannelSection.style.display = 'block';
                console.log('Detection channel section explicitly shown for indexing');
                
                // Ensure the indexing channel frame preserves content from the home channel frame
                const homeChannelFrame = document.getElementById('channel-frame');
                const indexingChannelFrame = document.getElementById('detection-channel-frame-indexing');
                
                if (homeChannelFrame && indexingChannelFrame) {
                    // If the home frame has content, ensure the indexing frame has the same content
                    try {
                        if (homeChannelFrame.contentWindow && homeChannelFrame.contentWindow.document) {
                            const homeProgramTrack = homeChannelFrame.contentWindow.document.getElementById('program-track');
                            const hasHomeContent = homeProgramTrack && homeProgramTrack.children.length > 1;
                            
                            if (hasHomeContent) {
                                console.log('Home channel has content, ensuring indexing channel preserves it');
                                // The indexing frame should already have the same content since they share the same src
                                // Just ensure it's visible
                                indexingChannelFrame.style.visibility = 'visible';
                                
                                // Re-send the show detection to the indexing channel frame to ensure content is populated
                                if (appState.detectedShow) {
                                    setTimeout(() => {
                                        if (indexingChannelFrame.contentWindow) {
                                            try {
                                                indexingChannelFrame.contentWindow.postMessage({
                                                    type: 'rumi:showDetected',
                                                    payload: appState.detectedShow
                                                }, '*');
                                                console.log('Re-sent show detection to indexing channel frame:', appState.detectedShow.title);
                                            } catch (e) {
                                                console.log('Could not re-send show detection to indexing channel frame:', e.message);
                                            }
                                        }
                                    }, 1000); // Wait for iframe to be ready
                                }
                            }
                        }
                    } catch (e) {
                        console.log('Cannot check home channel content (CORS):', e.message);
                    }
                }
            } else {
                console.log('Detection channel section not found for explicit show');
            }
            
            // Update debug button states
            updateDebugButtonStates();
            
            console.log('Detection indexing session started - advanced to Section 3a');
        }

        // Section 2b: Start Automode Indexing Function
        function startAutomodeIndexing() {
            console.log('Starting automode indexing...');
            
            // Set app state to start indexing
            appState.isIndexing = true;
            appState.indexingStartTime = Date.now();
            appState.sessionDuration = calculateSessionDuration();
            
            const bucketSelect = document.getElementById('bucket-select');
            const selectedBucket = bucketSelect ? bucketSelect.value : 'Content Intelligence';
            appState.currentBucket = selectedBucket;
            
            const contentItems = getAutomodeContent(selectedBucket, appState.sessionDuration, appState.baseRate || 0.1, appState.currentMultiplier);
            appState.automodeContentItems = contentItems;
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = contentItems[0] ? parseFloat(contentItems[0].duration) * 60 : 3600;
            
            // Start points earning
            startPointsEarning();
            
            // Initialize backend if available
            if (window.RumiBackend) {
                window.RumiBackend.startSession();
                console.log('Backend session started');
            }
            
            // Show the indexing view (nokia content) - Section 3b
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'none';
            if (nokiaContent) nokiaContent.style.display = 'block';
            
            // Show the Training Progress Dashboard (Section 3b)
            const trainingProgressDashboard = document.getElementById('training-progress-dashboard');
            if (trainingProgressDashboard) {
                trainingProgressDashboard.style.display = 'block';
                console.log('Training Progress Dashboard shown for Section 3b');
            }
            
            // Update UI to show indexing mode
            updateUI();
            
            // Explicitly show the automode channel section for indexing view
            const automodeChannelSection = document.getElementById('automode-channel-section-indexing');
            if (automodeChannelSection) {
                automodeChannelSection.style.display = 'block';
                console.log('Automode channel section explicitly shown for indexing');
            } else {
                console.log('Automode channel section not found for explicit show');
            }
            
            // Update debug button states
            updateDebugButtonStates();
            
            console.log('Automode indexing session started - advanced to Section 3b');
        }

        // Section 2b: Toggle Rumi Channel Expansion Function
        function toggleRumiChannelExpansion() {
            const container = document.getElementById('rumi-channel-expanded-container');
            const icon = document.getElementById('expand-rumi-channel-icon');
            const rumiChannelFrame = document.getElementById('rumi-channel-frame');
            
            if (container && icon) {
                if (container.style.display === 'none' || container.style.display === '') {
                    container.style.display = 'block';
                    icon.textContent = '▲';
                    // Make iframe visible when expanded
                    if (rumiChannelFrame) {
                        rumiChannelFrame.style.visibility = 'visible';
                        rumiChannelFrame.style.height = '320px';
                        
                        // Ensure the iframe is loaded with the correct content
                        if (rumiChannelFrame.src !== 'rumi-channel.html') {
                            rumiChannelFrame.src = 'rumi-channel.html';
                        }
                        
                        // Send bucket information to the iframe
                        setTimeout(() => {
                            if (rumiChannelFrame.contentWindow) {
                                try {
                                    rumiChannelFrame.contentWindow.postMessage({
                                        type: 'setBucket',
                                        payload: { bucket: appState.currentBucket || 'Content Intelligence' }
                                    }, '*');
                                    console.log('Sent bucket info to Rumi channel:', appState.currentBucket || 'Content Intelligence');
                                } catch (e) {
                                    console.log('Could not send bucket info to Rumi channel:', e.message);
                                }
                            }
                        }, 1000);
                    }
                } else {
                    container.style.display = 'none';
                    icon.textContent = '▼';
                }
            }
        }

                // Section 2b: Show Rumi Channel Error Function
        function showRumiChannelError() {
            console.error('Failed to load Rumi channel');
            const loading = document.getElementById('rumi-channel-loading');
            if (loading) {
                loading.textContent = 'Failed to load Rumi channel';
                loading.style.color = '#ff4444';
            }
        }

        // Section 3b: Toggle Training Progress Dashboard Expansion
        function toggleTrainingProgressExpansion() {
            const container = document.getElementById('training-progress-expanded-container');
            const icon = document.getElementById('expand-training-progress-icon');
            
            if (container && icon) {
                if (container.style.display === 'none' || container.style.display === '') {
                    container.style.display = 'block';
                    icon.textContent = '▲';
                } else {
                    container.style.display = 'none';
                    icon.textContent = '▼';
                }
            }
        }

        // Section 4b: Toggle Learning Insights Expansion
        function toggleLearningInsightsExpansion() {
            const container = document.getElementById('learning-insights-expanded-container');
            const icon = document.getElementById('expand-learning-insights-icon');
            
            if (container && icon) {
                if (container.style.display === 'none' || container.style.display === '') {
                    container.style.display = 'block';
                    icon.textContent = '▲';
                } else {
                    container.style.display = 'none';
                    icon.textContent = '▼';
                }
            }
        }

        // Function to update automode progress text with dynamic learning content
        function updateAutomodeProgressText() {
            const progressText = document.getElementById('automode-progress-text');
            if (!progressText) {
                console.log('updateAutomodeProgressText: Early return - progressText element not found');
                return;
            }

            // Get the full text without console truncation
            const fullText = generateLearningText();
            console.log('Full learning text:', JSON.stringify(fullText));

            // Check if the automode class is defined
            Array.from(document.styleSheets).forEach(sheet => {
                try {
                    Array.from(sheet.cssRules || []).forEach(rule => {
                        if (rule.selectorText && rule.selectorText.includes('.automode')) {
                            console.log('Found automode CSS rule:', rule.selectorText);
                        }
                    });
                } catch (e) {
                    // Cross-origin stylesheets will throw errors, ignore them
                }
            });

            console.log('updateAutomodeProgressText: Setting text to:', fullText);
            progressText.textContent = fullText;
        }

        // Detection Mode Channel Toggle for Indexing View
        function toggleDetectionChannelExpansionIndexing() {
            const container = document.getElementById('detection-channel-expanded-container-indexing');
            const icon = document.getElementById('expand-detection-channel-icon-indexing');
            const channelFrame = document.getElementById('detection-channel-frame-indexing');
            
            if (container && icon) {
                if (container.style.display === 'none' || container.style.display === '') {
                    container.style.display = 'block';
                    icon.textContent = '▲';
                    // Make iframe visible when expanded
                    if (channelFrame) {
                        channelFrame.style.visibility = 'visible';
                        channelFrame.style.height = '320px';
                    }
                } else {
                    container.style.display = 'none';
                    icon.textContent = '▼';
                }
            }
        }

        // Automode Channel Toggle for Indexing View
        function toggleAutomodeChannelExpansionIndexing() {
            const container = document.getElementById('automode-channel-expanded-container-indexing');
            const icon = document.getElementById('expand-automode-channel-icon-indexing');
            const channelFrame = document.getElementById('automode-channel-frame-indexing');
            
            if (container && icon) {
                if (container.style.display === 'none' || container.style.display === '') {
                    container.style.display = 'block';
                    icon.textContent = '▲';
                    // Make iframe visible when expanded
                    if (channelFrame) {
                        channelFrame.style.visibility = 'visible';
                        channelFrame.style.height = '320px';
                        
                        // Send bucket information to the iframe
                        setTimeout(() => {
                            if (channelFrame.contentWindow) {
                                try {
                                    channelFrame.contentWindow.postMessage({
                                        type: 'setBucket',
                                        payload: { bucket: appState.currentBucket || 'Content Intelligence' }
                                    }, '*');
                                    console.log('Sent bucket info to automode channel:', appState.currentBucket || 'Content Intelligence');
                                } catch (e) {
                                    console.log('Could not send bucket info to automode channel:', e.message);
                                }
                            }
                        }, 1000);
                    }
                } else {
                    container.style.display = 'none';
                    icon.textContent = '▼';
                }
            }
        }

        // Error functions for new channels
        function showDetectionChannelErrorIndexing() {
            console.error('Failed to load detection channel');
            const loading = document.getElementById('detection-channel-loading-indexing');
            if (loading) {
                loading.textContent = 'Failed to load detection channel';
                loading.style.color = '#ff4444';
            }
        }

        function showAutomodeChannelErrorIndexing() {
            console.error('Failed to load automode channel');
            const loading = document.getElementById('automode-channel-loading-indexing');
            if (loading) {
                loading.textContent = 'Failed to load automode channel';
                loading.style.color = '#ff4444';
            }
        }

        // Section Management: Show appropriate sections based on entry point
        function showSection2a() {
            console.log('showSection2a() called');
            // Hide all sections first
            const section2a = document.getElementById('section-2a-content-detected');
            const section2b = document.getElementById('section-2b-automode');
            
            if (section2a) section2a.style.display = 'none';
            if (section2b) section2b.style.display = 'none';
            
            // Show Section 2a (Content Detected)
            if (section2a) {
                section2a.style.display = 'block';
                console.log('Section 2a (Content Detected) displayed');
            } else {
                console.error('Section 2a element not found!');
            }
            
            // Update button text with detected show info
            const startWatchingButton = document.getElementById('start-watching-button');
            if (startWatchingButton && appState.detectedShow) {
                const show = appState.detectedShow;
                const episodeInfo = show.season !== 'N/A' ? ` S${show.season}E${show.episode}` : '';
                startWatchingButton.textContent = `START WATCHING ${show.title}${episodeInfo}`;
            }
            
            // Show the expandable channel section
            document.getElementById('expandable-channel-section').style.display = 'block';
            
            // Set channel to Genre channel for detection mode
            const channelFrame = document.getElementById('channel-frame');
            if (channelFrame) {
                channelFrame.src = 'Genre-channel_v2.html';
            }
        }

        function showSection2b() {
            console.log('showSection2b() called');
            // Hide all sections first
            const section2a = document.getElementById('section-2a-content-detected');
            const section2b = document.getElementById('section-2b-automode');
            
            if (section2a) section2a.style.display = 'none';
            if (section2b) section2b.style.display = 'none';
            
            // Show Section 2b (Automode)
            if (section2b) {
                section2b.style.display = 'block';
                console.log('Section 2b (Automode) displayed');
            } else {
                console.error('Section 2b element not found!');
            }
            
            // Update button text with selected bucket
            const startLearningButton = document.getElementById('start-learning-button');
            if (startLearningButton && appState.currentBucket) {
                startLearningButton.textContent = `START LEARNING ${appState.currentBucket}`;
            }
            
            // Show the expandable rumi channel section
            document.getElementById('expandable-rumi-channel-section').style.display = 'block';
            
            // Show the Real-time Learning Insights (moved from 3b to 2b)
            document.getElementById('real-time-learning-insights').style.display = 'block';
            
            // Set channel to Rumi channel for automode
            const rumiChannelFrame = document.getElementById('rumi-channel-frame');
            if (rumiChannelFrame) {
                rumiChannelFrame.src = 'rumi-channel.html';
            }
        }

        // Section 3b: Show Training Progress Dashboard (for automode indexing)
        function showTrainingProgressDashboard() {
            const dashboard = document.getElementById('training-progress-dashboard');
            if (dashboard) {
                dashboard.style.display = 'block';
            }
        }

        // Section 4b: Show Learning Insights (for automode indexing)
        function showLearningInsights() {
            const insights = document.getElementById('real-time-learning-insights');
            if (insights) {
                insights.style.display = 'block';
            }
        }

        // Show Learning Insights when indexing starts (Section 3b)
        function showLearningInsightsForIndexing() {
            const insights = document.getElementById('real-time-learning-insights');
            if (insights) {
                insights.style.display = 'block';
            }
        }

        // NEW: Show pre-indexing confirmation screen for automode
        function showAutomodePreIndexingScreen() {
            console.log('Showing pre-indexing confirmation screen for automode...');
            
            // Show home content with automode section
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'block';
            if (nokiaContent) nokiaContent.style.display = 'none';
            
            // Show the automode section
            showSection2b();
            
            console.log('Automode pre-indexing screen displayed');
        }

        // Show receipt with mode-specific data
        function showReceipt(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint
            });
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-overlay').style.display = 'block';
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${sessionEarnings.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${(appState.totalPendingPoints + sessionEarnings).toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(sessionDuration);
            document.getElementById('receipt-multiplier').textContent = `${finalMultiplier.toFixed(1)}x`;
            
            // Set bonus text based on multiplier
            const bonusElement = document.getElementById('receipt-bonus');
            if (finalMultiplier >= 1.2) {
                bonusElement.textContent = '10min Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Generate mode-specific content list
            generateReceiptContentList(sessionDuration, appState.entryPoint);
            
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // Helper function to get related content based on genre with points calculation
        function getRelatedContentWithPoints(genre, remainingTime, baseRate, multiplier) {
            const relatedShows = {
                'Drama': [
                    { title: 'Succession S4:E3', duration: 58 },
                    { title: 'The Crown S6:E8', duration: 52 },
                    { title: 'Mad Men S7:E14', duration: 47 },
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'The Wire S2:E12', duration: 60 },
                    { title: 'Better Call Saul S6:E13', duration: 45 }
                ],
                'Comedy': [
                    { title: 'The Office S3:E20', duration: 22 },
                    { title: 'Ted Lasso S3:E12', duration: 45 },
                    { title: 'Fleabag S2:E6', duration: 28 },
                    { title: 'Parks and Recreation S4:E22', duration: 22 },
                    { title: 'Brooklyn Nine-Nine S5:E23', duration: 22 },
                    { title: 'The Good Place S4:E13', duration: 22 }
                ],
                'Sci-Fi': [
                    { title: 'Stranger Things S4:E9', duration: 51 },
                    { title: 'Black Mirror S6:E3', duration: 45 },
                    { title: 'The Expanse S6:E6', duration: 42 },
                    { title: 'Westworld S3:E8', duration: 58 },
                    { title: 'Altered Carbon S2:E8', duration: 45 },
                    { title: 'The Mandalorian S3:E8', duration: 35 }
                ],
                'Thriller': [
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'Killing Eve S4:E8', duration: 44 },
                    { title: 'Ozark S4:E14', duration: 60 },
                    { title: 'Mindhunter S2:E9', duration: 45 },
                    { title: 'True Detective S3:E8', duration: 58 },
                    { title: 'The Sinner S4:E8', duration: 45 }
                ]
            };
            
            const shows = relatedShows[genre] || relatedShows['Drama'];
            const content = [];
            let timeLeft = remainingTime;
            
            for (const show of shows) {
                if (timeLeft <= 0) break;
                const showTime = Math.min(show.duration, timeLeft);
                const showTimeSeconds = showTime * 60;
                const showPoints = Math.round((showTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                content.push({
                    title: show.title,
                    duration: formatTime(showTime),
                    points: showPoints.toFixed(1)
                });
                timeLeft -= showTime;
            }
            
            return content;
        }

        // Helper function to get automode content based on bucket with points calculation
        function getAutomodeContent(bucket, sessionDuration, baseRate, multiplier) {
            console.log('getAutomodeContent called with bucket:', bucket);
            
            // Get content from CSV dynamically
            const bucketContent = getCSVBucketContent();
            console.log('getAutomodeContent: bucketContent keys:', Object.keys(bucketContent));
            
            const content = bucketContent[bucket] || bucketContent['Content Intelligence'];
            console.log('getAutomodeContent: content length:', content?.length);
            
            // If no content is available yet, use fallback content
            if (!content || content.length === 0) {
                console.log('getAutomodeContent: No CSV content available, using fallback');
                const fallbackContent = getFallbackBucketContent();
                const fallbackItems = fallbackContent[bucket] || fallbackContent['Content Intelligence'];
                
                const items = [];
                let timeLeft = sessionDuration;
                
                for (const item of fallbackItems) {
                    if (timeLeft <= 0) break;
                    const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                    const itemTime = Math.min(randomDuration, timeLeft);
                    const itemTimeSeconds = itemTime;
                    const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                    
                    items.push({
                        title: item.title,
                        duration: formatTime(itemTime),
                        points: itemPoints.toFixed(1),
                        description: item.description || 'content analysis'
                    });
                    timeLeft -= itemTime;
                }
                
                console.log('getAutomodeContent: returning fallback items:', items.length);
                return items;
            }
            
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of content) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1),
                    description: item.description || 'content analysis'
                });
                timeLeft -= itemTime;
            }
            
            console.log('getAutomodeContent: returning CSV items:', items.length);
            return items;
        }

        // NEW: Function to read CSV and organize content by intelligence buckets
        function getCSVBucketContent() {
            // If we already have the content cached, return it
            if (window.csvBucketContent) {
                return window.csvBucketContent;
            }

            // Initialize bucket content structure
            const bucketContent = {
                'Content Intelligence': [],
                'Scene Description Pipeline': [],
                'Story Tree': [],
                'Character Summaries': []
            };

            // Read CSV file and populate buckets
            fetch('content-library-expanded.csv')
                .then(response => response.text())
                .then(csvText => {
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    
                    // Find the intelligence_bucket column index
                    const bucketIndex = headers.findIndex(header => header.trim() === 'intelligence_bucket');
                    const titleIndex = headers.findIndex(header => header.trim() === 'title');
                    const descriptionIndex = headers.findIndex(header => header.trim() === 'description');
                    
                    if (bucketIndex === -1 || titleIndex === -1) {
                        console.error('Could not find intelligence_bucket or title columns in CSV');
                        return bucketContent;
                    }

                    // Process each line (skip header)
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        // Parse CSV line (handle quoted values)
                        const values = parseCSVLine(line);
                        if (values.length <= Math.max(bucketIndex, titleIndex)) continue;
                        
                        const title = values[titleIndex].replace(/"/g, '').trim();
                        const bucket = values[bucketIndex].replace(/"/g, '').trim();
                        const description = descriptionIndex !== -1 ? values[descriptionIndex].replace(/"/g, '').trim() : '';
                        
                        if (title && bucket && bucketContent.hasOwnProperty(bucket)) {
                            bucketContent[bucket].push({ 
                                title: title,
                                description: description
                            });
                        }
                    }
                    
                    // Cache the result
                    window.csvBucketContent = bucketContent;
                    console.log('CSV bucket content loaded:', bucketContent);
                    
                    // Update the progress text after content is loaded
                    if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                        console.log('CSV loaded - updating progress text');
                        updateAutomodeProgressText();
                    }
                })
                .catch(error => {
                    console.error('Error loading CSV content:', error);
                    // Return fallback content if CSV fails to load
                    return getFallbackBucketContent();
                });

            return bucketContent;
        }

        // Helper function to parse CSV line with quoted values
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            values.push(current);
            return values;
        }

        // Fallback content if CSV fails to load
        function getFallbackBucketContent() {
            return {
                'Content Intelligence': [
                    { title: 'Breaking Bad S01E01 - Pilot' },
                    { title: 'The Dark Knight' },
                    { title: 'Inception' }
                ],
                'Scene Description Pipeline': [
                    { title: 'The Office S01E01 - Pilot' },
                    { title: 'Our Planet S01E01 - One Planet' }
                ],
                'Story Tree': [
                    { title: 'Stranger Things S01E01 - The Vanishing of Will Byers' },
                    { title: 'Friends S01E01 - The Pilot' }
                ],
                'Character Summaries': [
                    { title: 'Better Call Saul S01E01 - Uno' },
                    { title: 'Parks and Recreation S01E01 - Pilot' }
                ]
            };

        }

        // Initialize CSV buckets and populate dropdown
        function initializeCSVBuckets() {
            fetch('content-library-expanded.csv')
                .then(response => response.text())
                .then(csvText => {
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    
                    // Find the intelligence_bucket column index
                    const bucketIndex = headers.findIndex(header => header.trim() === 'intelligence_bucket');
                    
                    if (bucketIndex === -1) {
                        console.error('Could not find intelligence_bucket column in CSV');
                        return;
                    }

                    // Collect unique buckets
                    const uniqueBuckets = new Set();
                    
                    // Process each line (skip header)
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        // Parse CSV line (handle quoted values)
                        const values = parseCSVLine(line);
                        if (values.length <= bucketIndex) continue;
                        
                        const bucket = values[bucketIndex].replace(/"/g, '').trim();
                        if (bucket) {
                            uniqueBuckets.add(bucket);
                        }
                    }
                    
                    // Populate dropdown with unique buckets
                    populateBucketDropdown(Array.from(uniqueBuckets));
                    console.log('CSV buckets loaded:', Array.from(uniqueBuckets));
                })
                .catch(error => {
                    console.error('Error loading CSV buckets:', error);
                    // Use fallback buckets
                    populateBucketDropdown(['Content Intelligence', 'Scene Description Pipeline', 'Story Tree', 'Character Summaries']);
                });
        }

        // Populate bucket dropdown with dynamic content
        function populateBucketDropdown(buckets) {
            const dropdown = document.getElementById('bucket-select');
            if (!dropdown) return;
            
            // Clear existing options
            dropdown.innerHTML = '';
            
            // Add options for each bucket
            buckets.forEach(bucket => {
                const option = document.createElement('option');
                option.value = bucket;
                
                // Add emoji based on bucket type
                let emoji = '🧠';
                if (bucket.includes('Scene')) emoji = '🎬';
                else if (bucket.includes('Story')) emoji = '🌳';
                else if (bucket.includes('Character')) emoji = '👥';
                
                option.textContent = `${emoji} ${bucket}`;
                dropdown.appendChild(option);
            });
        }

        // Helper function to get generic content with points calculation
        function getGenericContentWithPoints(sessionDuration, baseRate, multiplier) {
            const genericContent = [
                { title: 'Blade Runner 2029' },
                { title: 'Stranger Things S3:E1' },
                { title: 'The Witcher S2:E3' },
                { title: 'Breaking Bad Pilot' },
                { title: 'The Crown Opening' },
                { title: 'Black Mirror Episode' }
            ];
            
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of genericContent) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1)
                });
                timeLeft -= itemTime;
            }
            
            return items;
        }

        // Helper function to get show detection content based on detected show
        function getShowDetectionContent(detectedShow, sessionDuration) {
            console.log('=== GET SHOW DETECTION CONTENT START ===');
            console.log('Detected show:', detectedShow);
            console.log('Session duration:', sessionDuration);
            
            // Create initial content array with the detected show
            const contentItems = [];
            
            // Add the detected show as the first item
            if (detectedShow) {
                const detectedShowItem = {
                    title: detectedShow.title,
                    duration: detectedShow.duration || 45,
                    type: 'detected_show',
                    service: detectedShow.service || 'DETECTED',
                    season: detectedShow.season || 'N/A',
                    episode: detectedShow.episode || 'N/A',
                    genre: detectedShow.genre || 'Drama'
                };
                contentItems.push(detectedShowItem);
                console.log('Added detected show to content:', detectedShowItem);
            }
            
            // Use backend genre filtering if available
            if (window.RumiBackend && window.RumiBackend.isReady()) {
                console.log('Using backend genre filtering for content population');
                
                // Get genre-filtered content from backend
                const genre = detectedShow?.genre || 'Drama';
                const remainingTime = sessionDuration - (detectedShow?.duration || 45);
                
                // Create genre session using backend
                const genreSession = window.RumiBackend.createGenreSession(remainingTime, genre);
                
                console.log('Backend genre session created:', genreSession);
                
                // Convert backend content to the format expected by the system
                genreSession.content.forEach(item => {
                    const contentItem = {
                        title: item.title,
                        duration: item.duration * 60, // Convert minutes to seconds
                        type: 'related_show',
                        service: item.service || 'GENRE_CHANNEL',
                        season: item.season || 'N/A',
                        episode: item.episode || 'N/A',
                        genre: item.genre || genre
                    };
                    contentItems.push(contentItem);
                });
                
                console.log(`Backend provided ${genreSession.content.length} genre-filtered items`);
            } else {
                console.log('Backend not available, using fallback genre content');
                
                // Fallback to existing genre content system
                const relatedContent = getRelatedContentWithPoints(detectedShow?.genre || 'Drama', sessionDuration - (detectedShow?.duration || 45), appState.baseRate || 0.1, appState.currentMultiplier || 1.0);
                
                // Convert related content to the format expected by the system
                relatedContent.forEach(item => {
                    const contentItem = {
                        title: item.title,
                        duration: parseFloat(item.duration) || 45, // Convert formatTime back to minutes
                        type: 'related_show',
                        service: 'GENRE_CHANNEL',
                        season: 'N/A',
                        episode: 'N/A',
                        genre: detectedShow?.genre || 'Drama'
                    };
                    contentItems.push(contentItem);
                });
            }
            
            console.log('Final content items:', contentItems);
            console.log('=== GET SHOW DETECTION CONTENT COMPLETE ===');
            
            return contentItems;
        }

        // NEW: Message handler for channel content
        window.addEventListener('message', function(event) {
            if (event.data.type === 'currentContentResponse') {
                console.log('Received current content from channel:', event.data.content);
                
                // Convert channel content to show detection content format
                const channelContent = event.data.content || [];
                const showDetectionContent = channelContent.map(item => ({
                    title: item.title,
                    duration: typeof item.duration === 'number' ? item.duration * 60 : item.duration, // Convert minutes to seconds if needed
                    type: item.type || 'show',
                    service: item.service || 'UNKNOWN',
                    season: item.season || 'N/A',
                    episode: item.episode || 'N/A',
                    genre: item.genre || 'Drama'
                }));
                
                // Update the automode content items with actual channel content
                appState.automodeContentItems = showDetectionContent;
                
                // Recalculate content item duration if we have items
                if (showDetectionContent.length > 0) {
                    const firstItem = showDetectionContent[0];
                    appState.contentItemDuration = firstItem.duration;
                    console.log(`Updated show detection content with ${showDetectionContent.length} items from channel`);
                    console.log(`First item: ${firstItem.title}, duration: ${firstItem.duration} seconds`);
                    
                    // If we're currently indexing, update the UI to reflect the new content
                    if (appState.isIndexing) {
                        // Force an immediate animation update with the new content
                        const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        updateAnimationPanel(elapsedTime);
                        updatePointsDisplay();
                        
                        // Update the button text to show the current show
                        const ctaButton = document.getElementById('cta-button');
                        if (ctaButton && appState.entryPoint === 'detection') {
                            const show = firstItem;
                            if (show.season !== 'N/A' && show.episode !== 'N/A') {
                                ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                            } else {
                                ctaButton.textContent = `START WATCHING ${show.title}`;
                            }
                        }
                    }
                }
            }
            
            // Handle genre channel ready message
            if (event.data.type === 'genreChannelReady') {
                console.log('Genre channel is ready for content population');
                
                // If we have a detected show, populate the genre channel with backend content
                if (appState.detectedShow && window.RumiBackend && window.RumiBackend.isReady()) {
                    console.log('Populating genre channel with backend-filtered content');
                    
                    const genre = appState.detectedShow.genre || 'Drama';
                    const sessionDuration = calculateSessionDuration();
                    const remainingTime = sessionDuration - (appState.detectedShow.duration || 45);
                    
                    // Create genre session using backend
                    const genreSession = window.RumiBackend.createGenreSession(remainingTime, genre);
                    
                    console.log('Backend genre session for channel:', genreSession);
                    
                    // Send the genre-filtered content to the genre channel
                    const channelFrame = document.getElementById('detection-channel-frame-indexing');
                    if (channelFrame && channelFrame.contentWindow) {
                        try {
                            // Convert backend content to genre channel format
                            const channelContent = genreSession.content.map(item => ({
                                title: item.title,
                                duration: item.duration,
                                type: item.type || 'episode',
                                service: item.service || 'netflix',
                                season: item.season || '',
                                episode: item.episode || '',
                                genre: item.genre || genre
                            }));
                            
                            // Send content to genre channel
                            channelFrame.contentWindow.postMessage({
                                type: 'populateWithContent',
                                content: channelContent,
                                genre: genre
                            }, '*');
                            
                            console.log(`Sent ${channelContent.length} genre-filtered items to genre channel`);
                        } catch (e) {
                            console.log('Could not send content to genre channel:', e.message);
                        }
                    }
                }
                
                // Request current content from the genre channel
                const channelFrame = document.getElementById('detection-channel-frame-indexing');
                if (channelFrame && channelFrame.contentWindow) {
                    try {
                        channelFrame.contentWindow.postMessage({ 
                            type: 'requestCurrentContent' 
                        }, '*');
                        console.log('Requested current content from genre channel');
                    } catch (e) {
                        console.log('Could not request content from genre channel:', e.message);
                    }
                }
            }
        });

        // Debug Panel Collapsible Functions
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            const content = document.getElementById('debug-panel-content');
            const toggle = document.getElementById('debug-panel-toggle');
            
            if (panel.classList.contains('visible')) {
                // Hide the panel
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            } else {
                // Show the panel
                panel.classList.add('visible');
                trigger.style.display = 'none';
                
                // Expand the content when showing
                content.classList.remove('collapsed');
                toggle.textContent = '▼';
                toggle.classList.remove('collapsed');
                
                // Expand error testing section by default (most commonly used)
                const errorTestingContent = document.getElementById('error-testing-content');
                const errorTestingToggle = document.getElementById('error-testing-toggle');
                if (errorTestingContent && errorTestingToggle) {
                    errorTestingContent.classList.remove('collapsed');
                    errorTestingToggle.textContent = '▼';
                    errorTestingToggle.classList.remove('collapsed');
                }
            }
        }

        function toggleDebugSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const toggle = document.getElementById(sectionId + '-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = '▼';
                toggle.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.textContent = '▶';
                toggle.classList.add('collapsed');
            }
        }

        // Initialize debug panel state
        document.addEventListener('DOMContentLoaded', function() {
            // Start with debug panel hidden and trigger visible
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            
            if (panel && trigger) {
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            }
            
            // Start with sections collapsed
            const basicTestingContent = document.getElementById('basic-testing-content');
            const errorTestingContent = document.getElementById('error-testing-content');
            const sessionManagementContent = document.getElementById('session-management-content');
            const basicTestingToggle = document.getElementById('basic-testing-toggle');
            const errorTestingToggle = document.getElementById('error-testing-toggle');
            const sessionManagementToggle = document.getElementById('session-management-toggle');
            
            if (basicTestingContent && errorTestingContent && sessionManagementContent) {
                basicTestingContent.classList.add('collapsed');
                errorTestingContent.classList.add('collapsed');
                sessionManagementContent.classList.add('collapsed');
                basicTestingToggle.textContent = '▶';
                errorTestingToggle.textContent = '▶';
                sessionManagementToggle.textContent = '▶';
                basicTestingToggle.classList.add('collapsed');
                errorTestingToggle.classList.add('collapsed');
                sessionManagementToggle.classList.add('collapsed');
            }

                    // Initialize debug button states
        updateDebugButtonStates();
        
        // Show indexing section by default
        showIndexingSection();
        
        // Initialize debug section toggles
        initializeDebugSections();
        });

        // Keyboard shortcut for debug panel (Ctrl+Shift+D)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.shiftKey && event.key === 'D') {
                event.preventDefault();
                toggleDebugPanel();
            }
        });

        // Hide receipt overlay
        function hideReceiptView() {
            Tracker.logRumiAction('Receipt view hidden');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<div class="popup-balance">BALANCE: 4,349 PTS</div><button class="settings-button" onclick="showSettingsView()">⚙ SETTINGS</button>';
            // }
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
        }

        function returnToEntryPoint() {
            const originalEntryPoint = appState.entryPoint; // Store before resetting
            Tracker.logRumiAction('Returning to entry point', { entryPoint: originalEntryPoint });
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Show the extension popup
            const popup = document.querySelector('.extension-popup');
            if (popup) {
                popup.style.display = 'flex';
            }
            
            // Keep the entry point panel hidden when returning from receipt
            // It should only be visible on initial startup/reload
            const entryPointPanel = document.querySelector('.entry-point-panel');
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            
            // Show the user changes content button
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }
            
            // Reset indexing state
            appState.isIndexing = false;
            appState.entryPoint = originalEntryPoint; // Keep the same entry point
            console.log('App state after reset:', {
                isIndexing: appState.isIndexing,
                entryPoint: appState.entryPoint
            });
            
            // Ensure home content is visible and nokia content is hidden
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            if (homeContent) {
                homeContent.style.display = 'block';
                console.log('Home content displayed');
            }
            if (nokiaContent) {
                nokiaContent.style.display = 'none';
                console.log('Nokia content hidden');
            }
            
            // Navigate to the appropriate section based on entry point
            console.log('Returning to entry point:', originalEntryPoint);
            if (originalEntryPoint === 'detection') {
                // Go to section 2a (Content Detected)
                console.log('Showing section 2a (Content Detected)');
                showSection2a();
            } else if (originalEntryPoint === 'automode') {
                // Go to section 2b (Automode)
                console.log('Showing section 2b (Automode)');
                showSection2b();
            } else {
                // Default behavior - show home content
                console.log('Using default home content');
                const homeContent = document.getElementById('home-content');
                const nokiaContent = document.getElementById('nokia-content');
                if (homeContent) homeContent.style.display = 'block';
                if (nokiaContent) nokiaContent.style.display = 'none';
            }
            
            // If we came from detection, restore the detected show
            if (originalEntryPoint === 'detection' && detectedShow) {
                appState.detectedShow = detectedShow;
                showDetectedShowUI(detectedShow.title);
            }
            
            // Debug: Check what sections are actually visible
            setTimeout(() => {
                const section2a = document.getElementById('section-2a-content-detected');
                const section2b = document.getElementById('section-2b-automode');
                const homeContent = document.getElementById('home-content');
                const nokiaContent = document.getElementById('nokia-content');
                
                console.log('Final section visibility:', {
                    section2aVisible: section2a ? section2a.style.display : 'not found',
                    section2bVisible: section2b ? section2b.style.display : 'not found',
                    homeContentVisible: homeContent ? homeContent.style.display : 'not found',
                    nokiaContentVisible: nokiaContent ? nokiaContent.style.display : 'not found'
                });
            }, 100);
        }

        // Function to return to home from start indexing screen (CANCEL button)
        function returnToHomeFromStartIndexing() {
            console.log('Returning to home from start indexing screen');
            
            // Hide the start indexing screen and show home content
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'block';
            if (nokiaContent) nokiaContent.style.display = 'none';
            
            // Show the entry point panel
            const entryPointPanel = document.querySelector('.entry-point-panel');
            if (entryPointPanel) {
                entryPointPanel.style.display = 'block';
            }
            
            // Reset to home state
            appState.isIndexing = false;
            
            // Navigate to the appropriate section based on entry point
            if (appState.entryPoint === 'detection') {
                // Go to section 2a (Content Detected)
                showSection2a();
            } else if (appState.entryPoint === 'automode') {
                // Go to section 2b (Automode)
                showSection2b();
            } else {
                // Default behavior - show home content
                updateUI();
            }
            
            console.log('Returned to home from start indexing screen');
        }

        // --- Expandable Channel Section Logic ---
        function toggleChannelExpansion() {
            const expandedContainer = document.getElementById('channel-expanded-container');
            const expandHeader = document.getElementById('expand-channel-header');
            const expandText = document.getElementById('expand-channel-text');
            const expandIcon = document.getElementById('expand-channel-icon');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Channel expansion elements not found');
                return;
            }
            
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '▲';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '▼';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // --- Expandable Channel Section Logic for Indexing View ---
        function toggleChannelExpansionIndexing() {
            const expandedContainer = document.getElementById('channel-expanded-container-indexing');
            const expandHeader = document.getElementById('expand-channel-header-indexing');
            const expandText = document.getElementById('expand-channel-text-indexing');
            const expandIcon = document.getElementById('expand-channel-icon-indexing');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Indexing channel expansion elements not found');
                return;
            }
            
            // Use the same state as the main channel expansion
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '▲';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame-indexing');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '▼';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Indexing channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // Debug function to check channel state
        function debugChannelState() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            
            console.log('=== Channel Debug Info ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Channel Expanded:', appState.channelExpanded);
            console.log('Expandable Section Display:', expandableSection ? expandableSection.style.display : 'NOT FOUND');
            console.log('Expanded Container Display:', expandedContainer ? expandedContainer.style.display : 'NOT FOUND');
            console.log('Channel Frame Src:', channelFrame ? channelFrame.src : 'NOT FOUND');
            
            // Try to access iframe content to see if genre channel is working
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    if (channelTitle) {
                        console.log('Genre Channel Title:', channelTitle.textContent);
                    } else {
                        console.log('Genre Channel Title: NOT FOUND');
                    }
                    
                    // Check if there's content in the program track
                    const programTrack = iframeDocument.getElementById('program-track');
                    if (programTrack) {
                        console.log('Program Track Children:', programTrack.children.length);
                        if (programTrack.children.length > 0) {
                            console.log('First Program Item:', programTrack.children[0].textContent);
                        }
                    } else {
                        console.log('Program Track: NOT FOUND');
                    }
                } catch (e) {
                    console.log('Cannot access iframe content (CORS or not loaded):', e.message);
                }
            }
            
            console.log('========================');
        }

        // Update UI based on current state (additions for expandable channel)
        function updateExpandableChannelUI() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            const expandText = document.getElementById('expand-channel-text');
            
            // Indexing view elements
            const expandableSectionIndexing = document.getElementById('expandable-channel-section-indexing');
            const expandedContainerIndexing = document.getElementById('channel-expanded-container-indexing');
            const channelFrameIndexing = document.getElementById('detection-channel-frame-indexing');
            const expandTextIndexing = document.getElementById('expand-channel-text-indexing');
            
            if (!expandableSection || !expandedContainer || !channelFrame || !expandText) return;

            console.log('updateExpandableChannelUI called, entry point:', appState.entryPoint);

            // Only show expandable section if in entry point mode
            if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // Only set the src if it's not already correct AND we don't have content
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                console.log('Current channel frame src:', currentSrc);
                
                // Check if we already have content in the channel
                let hasContent = false;
                try {
                    if (channelFrame.contentWindow && channelFrame.contentWindow.document) {
                        const programTrack = channelFrame.contentWindow.document.getElementById('program-track');
                        hasContent = programTrack && programTrack.children.length > 1; // More than just the "+ ADD SHOW" button
                        console.log('Channel has content:', hasContent, 'Program track children:', programTrack ? programTrack.children.length : 0);
                    }
                } catch (e) {
                    console.log('Cannot check channel content (CORS):', e.message);
                }
                
                if (currentSrc !== 'Genre-channel_v2.html' && !hasContent) {
                    console.log('Changing channel frame src to Genre-channel_v2.html (no content detected)');
                    channelFrame.src = 'Genre-channel_v2.html';
                    console.log('Channel frame src after change:', channelFrame.src);
                    if (channelFrameIndexing) {
                        console.log('Changing indexing channel frame src to Genre-channel_v2.html');
                        channelFrameIndexing.src = 'Genre-channel_v2.html';
                        console.log('Indexing channel frame src after change:', channelFrameIndexing.src);
                    }
                    console.log('Detection mode: Set channel to Genre-channel_v2.html');
                    
                    // Check if iframe loads after a delay
                    setTimeout(() => {
                        console.log('Checking iframe src after 2 seconds:', channelFrame.src);
                        if (channelFrameIndexing) {
                            console.log('Checking indexing iframe src after 2 seconds:', channelFrameIndexing.src);
                        }
                        
                        // Ensure iframe visibility after loading
                        if (channelFrame.style.visibility === 'hidden') {
                            channelFrame.style.visibility = 'visible';
                            console.log('Made home channel frame visible');
                        }
                        if (channelFrameIndexing && channelFrameIndexing.style.visibility === 'hidden') {
                            channelFrameIndexing.style.visibility = 'visible';
                            console.log('Made indexing channel frame visible');
                        }
                    }, 2000);
                } else {
                    console.log('Channel frame already pointing to Genre-channel_v2.html OR has content, preserving existing content');
                }
            } else if (appState.entryPoint === 'automode') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // Only set the src if it's not already correct (compare filename only)
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                if (currentSrc !== 'rumi-channel.html') {
                    channelFrame.src = 'rumi-channel.html';
                    if (channelFrameIndexing) channelFrameIndexing.src = 'rumi-channel.html';
                    console.log('Automode: Set channel to rumi-channel.html');
                    
                    // Ensure iframe visibility after loading
                    setTimeout(() => {
                        if (channelFrame.style.visibility === 'hidden') {
                            channelFrame.style.visibility = 'visible';
                            console.log('Made home channel frame visible');
                        }
                        if (channelFrameIndexing && channelFrameIndexing.style.visibility === 'hidden') {
                            channelFrameIndexing.style.visibility = 'visible';
                            console.log('Made indexing channel frame visible');
                        }
                    }, 1000);
                }
            } else {
                expandableSection.style.display = 'none';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'none';
            }
            
            // Synchronize expansion state between both views
            if (expandedContainerIndexing) {
                expandedContainerIndexing.style.display = expandedContainer.style.display;
            }
            
            // Debug the channel state
            debugChannelState();
        }

        // Patch updateUI to call updateExpandableChannelUI
        const _originalUpdateUI = updateUI;
        updateUI = function() {
            _originalUpdateUI.apply(this, arguments);
            updateExpandableChannelUI();
            
            // Ensure channel visibility is maintained after UI updates
            setTimeout(() => {
                ensureChannelVisibility();
            }, 100);
        };
        
        // Call on load
        document.addEventListener('DOMContentLoaded', function() {
            updateExpandableChannelUI();
            setTimeout(() => {
                ensureChannelVisibility();
            }, 500);
        });
        
        // NEW: Function to ensure channel visibility
        function ensureChannelVisibility() {
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('detection-channel-frame-indexing');
            
            if (channelFrame && channelFrame.style.visibility === 'hidden') {
                channelFrame.style.visibility = 'visible';
                console.log('ensureChannelVisibility: Made home channel frame visible');
            }
            
            if (channelFrameIndexing && channelFrameIndexing.style.visibility === 'hidden') {
                channelFrameIndexing.style.visibility = 'visible';
                console.log('ensureChannelVisibility: Made indexing channel frame visible');
            }
        }

        function checkGenreChannelContent() {
            console.log('=== Checking Genre Channel Content ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    
                    // Check for genre channel specific elements
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    console.log('Channel title element:', channelTitle ? channelTitle.textContent : 'NOT FOUND');
                    
                    const programTrack = iframeDocument.getElementById('program-track');
                    console.log('Program track element:', programTrack ? 'FOUND' : 'NOT FOUND');
                    
                    if (programTrack) {
                        console.log('Program track children count:', programTrack.children.length);
                        for (let i = 0; i < Math.min(3, programTrack.children.length); i++) {
                            const child = programTrack.children[i];
                            console.log(`Program item ${i + 1}:`, child.textContent.trim());
                        }
                    }
                    
                    // Check for genre dropdown
                    const genreDropdown = iframeDocument.getElementById('genre-select');
                    console.log('Genre dropdown:', genreDropdown ? genreDropdown.value : 'NOT FOUND');
                    
                    // Check for any error messages or loading states
                    const errorElements = iframeDocument.querySelectorAll('.error, .loading, .status');
                    if (errorElements.length > 0) {
                        console.log('Error/status elements found:');
                        errorElements.forEach(el => console.log('-', el.textContent));
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            }
            
            console.log('=== End Genre Channel Check ===');
        }

        // Debug function to test Planet Earth II detection specifically
        function testPlanetEarthDetection() {
            console.log('=== Testing Planet Earth II Detection ===');
            
            // Set the entry point to detection mode so the genre channel gets loaded
            appState.entryPoint = 'detection';
            console.log('Set entry point to detection mode');
            
            const planetEarthShow = {
                title: 'Planet Earth II',
                genre: 'Documentary',
                service: 'DISCOVERY+',
                season: 'S1',
                episode: 'E1'
            };
            
            console.log('Sending Planet Earth II detection:', planetEarthShow);
            
            // Update the UI to load the genre channel first
            updateExpandableChannelUI();
            
            // Wait for the channel to load, then send the detection
            setTimeout(() => {
                // Check if the channel loaded correctly before sending the message
                checkGenreChannelLoaded();
                
                // Send the show detection
                sendShowDetection(planetEarthShow);
                
                // Check the channel content after a delay
                setTimeout(() => {
                    console.log('Checking channel content after Planet Earth II detection...');
                    checkGenreChannelContent();
                }, 2000);
            }, 2000); // Increased delay to ensure channel loads
        }

        // NEW: Debug function to test channel visibility
        function testChannelVisibility() {
            console.log('=== Testing Channel Visibility ===');
            
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            console.log('Home channel frame visibility:', channelFrame ? channelFrame.style.visibility : 'NOT FOUND');
            console.log('Indexing channel frame visibility:', channelFrameIndexing ? channelFrameIndexing.style.visibility : 'NOT FOUND');
            
            // Force visibility
            ensureChannelVisibility();
            
            console.log('After ensureChannelVisibility:');
            console.log('Home channel frame visibility:', channelFrame ? channelFrame.style.visibility : 'NOT FOUND');
            console.log('Indexing channel frame visibility:', channelFrameIndexing ? channelFrameIndexing.style.visibility : 'NOT FOUND');
            
            // Test channel expansion
            if (appState.entryPoint) {
                console.log('Testing channel expansion...');
                appState.channelExpanded = !appState.channelExpanded;
                updateExpandableChannelUI();
                console.log('Channel expanded:', appState.channelExpanded);
            }
        }

        // NEW: Debug function to test ludicrous mode
        function testLudicrousMode() {
            console.log('=== Testing Ludicrous Mode ===');
            
            if (!appState.isIndexing) {
                console.log('Please start an indexing session first');
                alert('Please start an indexing session first to use Ludicrous Mode');
                return;
            }
            
            console.log('Current entry point:', appState.entryPoint);
            console.log('Current fast mode state:', appState.fastMode);
            
            // Test the appropriate ludicrous mode based on entry point
            if (appState.entryPoint === 'detection') {
                console.log('Testing detection mode ludicrous speed...');
                // Simulate a detected show if none exists
                if (!appState.detectedShow) {
                    appState.detectedShow = {
                        title: 'Test Show',
                        genre: 'Drama',
                        service: 'NETFLIX',
                        season: 'S1',
                        episode: 'E1',
                        duration: 45
                    };
                }
                
                // Initialize transition system if needed
                if (!window.transitionSystem) {
                    window.transitionSystem = new TransitionSystem();
                }
                
            } else if (appState.entryPoint === 'automode') {
                console.log('Testing automode ludicrous speed...');
                // Ensure we have content items
                if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                    appState.automodeContentItems = [
                        { title: 'Test Content 1', duration: '1:30' },
                        { title: 'Test Content 2', duration: '2:15' },
                        { title: 'Test Content 3', duration: '1:45' }
                    ];
                    appState.currentContentIndex = 0;
                }
            }
            
            // Activate ludicrous mode (same as fast mode but with higher speed)
            if (!appState.fastMode) {
                if (appState.entryPoint === 'automode') {
                    appState.fastMode = {
                        active: true,
                        mode: 'automode',
                        speedMultiplier: 500, // Ludicrous speed: 500x
                        originalSessionDuration: null
                    };
                    startAutoModeFastMode();
                    console.log('Ludicrous Mode: Activated! Playing at 500x speed.');
                } else if (appState.entryPoint === 'detection') {
                    appState.fastMode = {
                        active: true,
                        mode: 'detection',
                        currentContentIndex: 0,
                        isInFinalSeconds: false,
                        contentStartTime: Date.now(),
                        normalSpeedBuffer: 2 // Even faster: 2 seconds at normal speed
                    };
                    startFastModeNavigation();
                    console.log('Ludicrous Mode: Activated! Ultra-fast content navigation.');
                }
                } else {
                // Deactivate ludicrous mode
                appState.fastMode.active = false;
                appState.fastMode = null;
                console.log('Ludicrous Mode: Deactivated');
            }
            
            console.log('Ludicrous mode toggled. Check console for progress updates.');
        }

        // NEW: Debug function to test show selection
        function testShowSelection() {
            console.log('=== Testing Show Selection ===');
            
            console.log('Available shows:', availableShows);
            console.log('Current detected show:', detectedShow);
            
            // Test changing to a different show
            const testShow = availableShows.find(show => show.title !== detectedShow?.title) || availableShows[0];
            if (testShow) {
                console.log('Testing change to:', testShow.title);
                changeDetectionShow(testShow.title);
                console.log('After change - detected show:', detectedShow);
            }
            
            // Test the dropdown
            const showSelect = document.getElementById('detection-show-select');
            if (showSelect) {
                console.log('Show select element found, current value:', showSelect.value);
                console.log('Available options:', Array.from(showSelect.options).map(opt => opt.value));
            } else {
                console.log('Show select element not found');
            }
        }

        // NEW: Breakpoint testing functions
        function setViewportHeight(height) {
            const container = document.querySelector('.simulation-container');
            if (container) {
                container.style.height = `${height}px`;
                container.style.overflow = 'hidden';
                console.log(`Viewport height set to ${height}px`);
                
                // Add visual indicator
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: #00ff41;
                    color: #000;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: bold;
                    z-index: 10000;
                    font-family: 'SF Mono', monospace;
                `;
                indicator.textContent = `${height}px`;
                indicator.id = 'viewport-indicator';
                
                // Remove existing indicator
                const existing = document.getElementById('viewport-indicator');
                if (existing) existing.remove();
                
                document.body.appendChild(indicator);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 3000);
            }
        }

        function resetViewportHeight() {
            const container = document.querySelector('.simulation-container');
            if (container) {
                container.style.height = '';
                container.style.overflow = '';
                console.log('Viewport height reset to natural');
                
                // Remove indicator
                const indicator = document.getElementById('viewport-indicator');
                if (indicator) indicator.remove();
            }
        }

        function testAllBreakpoints() {
            console.log('=== Testing All Breakpoints ===');
            
            const heights = [400, 600, 800, 1100];
            let currentIndex = 0;
            
            function cycleBreakpoint() {
                if (currentIndex < heights.length) {
                    const height = heights[currentIndex];
                    console.log(`Testing breakpoint: ${height}px`);
                    setViewportHeight(height);
                    currentIndex++;
                    
                    // Cycle to next breakpoint after 2 seconds
                    setTimeout(cycleBreakpoint, 2000);
                } else {
                    // Reset at the end
                    console.log('All breakpoints tested, resetting to natural');
                    resetViewportHeight();
                }
            }
            
            cycleBreakpoint();
        }

        // NEW: Initialize debug section toggles
        function initializeDebugSections() {
            const toggles = document.querySelectorAll('.debug-section-toggle');
            
            toggles.forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const section = this.closest('.debug-section');
                    const content = section.querySelector('.debug-section-content');
                    const isExpanded = content.style.display !== 'none';
                    
                    if (isExpanded) {
                        content.style.display = 'none';
                        this.textContent = '▶';
                    } else {
                        content.style.display = 'block';
                        this.textContent = '▼';
                    }
                });
            });
            
            // Set initial state - all sections expanded
            toggles.forEach(toggle => {
                const section = toggle.closest('.debug-section');
                const content = section.querySelector('.debug-section-content');
                content.style.display = 'block';
                toggle.textContent = '▼';
            });
        }
        
        // NEW: Show indexing section
        function showIndexingSection() {
            const expandableSectionIndexing = document.getElementById('expandable-channel-section-indexing');
            if (expandableSectionIndexing) {
                expandableSectionIndexing.style.display = 'block';
                console.log('Indexing section displayed');
            }
        }
        
        // NEW: Hide indexing section
        function hideIndexingSection() {
            const expandableSectionIndexing = document.getElementById('expandable-channel-section-indexing');
            if (expandableSectionIndexing) {
                expandableSectionIndexing.style.display = 'none';
                console.log('Indexing section hidden');
            }
        }

        // NEW: Indexing Session Management Functions
        function startIndexingSession() {
            console.log('=== Starting Indexing Session ===');
            
            // Set app state to start indexing
            appState.isIndexing = true;
            appState.indexingStartTime = Date.now();
            
            // Start points earning
            startPointsEarning();
            
            // Initialize backend if available
            if (window.RumiBackend) {
                window.RumiBackend.startSession();
                console.log('Backend session started');
            }
            
            // Update UI to show indexing mode
            updateUI();
            
            // Update debug button states
            updateDebugButtonStates();
            
            console.log('Indexing session started');
        }
        
        function stopIndexingSession() {
            console.log('=== Stopping Indexing Session ===');
            
            // Update UI
            document.getElementById('indexing-status-text').textContent = 'Stopped';
            document.getElementById('indexing-status-text').style.color = '#ff4444';
            document.getElementById('start-indexing-btn').style.display = 'inline-block';
            document.getElementById('stop-indexing-btn').style.display = 'none';
            
            // Set app state
            appState.isIndexing = false;
            
            // Stop indexing timer
            stopIndexingTimer();
            
            // Stop backend session if available
            if (window.RumiBackend) {
                const sessionData = window.RumiBackend.getSessionForUI();
                console.log('Backend session data:', sessionData);
            }
            
            // Update debug button states
            updateDebugButtonStates();
            
            console.log('Indexing session stopped');
        }
        
        function startIndexingTimer() {
            if (appState.indexingTimer) {
                clearInterval(appState.indexingTimer);
            }
            
            appState.indexingTimer = setInterval(() => {
                if (appState.isIndexing && appState.indexingStartTime) {
                    let elapsed = Date.now() - appState.indexingStartTime;
                    
                    // Apply Ludicrous Speed acceleration if active
                    if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                        const speedMultiplier = window.LudicrousSpeedManager.currentSpeed || 300;
                        elapsed = elapsed * speedMultiplier;
                        console.log(`🚀 LUDICROUS TIMER: Accelerated elapsed time to ${(elapsed / 1000 / 60).toFixed(1)} minutes (${speedMultiplier}x speed)`);
                    }
                    
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    
                    // Update duration display
                    const durationElement = document.getElementById('indexing-duration');
                    if (durationElement) {
                        durationElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                    
                    // Update progress (assuming 45-minute session)
                    const sessionDuration = 45 * 60 * 1000; // 45 minutes in milliseconds
                    const progress = Math.min((elapsed / sessionDuration) * 100, 100);
                    
                    const progressTextElement = document.getElementById('indexing-progress-text');
                    const progressBarElement = document.getElementById('indexing-progress-bar');
                    
                    if (progressTextElement) {
                        progressTextElement.textContent = `${Math.round(progress)}%`;
                    }
                    if (progressBarElement) {
                        progressBarElement.style.width = `${progress}%`;
                    }
                    
                    // Auto-complete session after 45 minutes (accelerated)
                    if (elapsed >= sessionDuration) {
                        console.log('🚀 LUDICROUS TIMER: Session duration reached, completing session');
                        completeIndexingSession();
                    }
                    
                    // Update debug button states to keep status current
                    updateDebugButtonStates();
                }
            }, 1000);
        }
        
        function stopIndexingTimer() {
            if (appState.indexingTimer) {
                clearInterval(appState.indexingTimer);
                appState.indexingTimer = null;
            }
        }
        
        function completeIndexingSession() {
            console.log('=== Completing Indexing Session ===');
            
            // Calculate session stats
            const sessionDuration = 45; // minutes
            const totalPoints = sessionDuration * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0);
            
            // Create receipt
            const receipt = {
                sessionId: `indexing_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDuration,
                numberOfShows: 1,
                playedContent: appState.playedContent || [],
                mode: 'indexing',
                fastMode: false
            };
            
            // Stop indexing
            stopIndexingSession();
            
            // Show receipt
            showSessionReceipt(receipt);
            
            console.log('Indexing session completed');
        }

        // NEW: Debug function to test genre channel autopopulation
        function testGenreChannelAutopopulation() {
            console.log('=== Testing Genre Channel Autopopulation ===');
            
            // Create a test show
            const testShow = {
                title: 'BREAKING BAD',
                genre: 'Thriller',
                service: 'NETFLIX',
                season: 'S5',
                episode: 'E16',
                duration: 47
            };
            
            // Set up the detection state
            appState.entryPoint = 'detection';
            appState.detectedShow = testShow;
            appState.pendingShowForGenreChannel = testShow;
            
            console.log('Test show set up:', testShow);
            
            // Switch to genre channel
            switchToGenreChannel();
            
            // Send show detection to genre channel
            setTimeout(() => {
                console.log('Sending show detection to genre channel...');
                sendShowDetection(testShow);
            }, 1000);
            
            // Check results after a delay
            setTimeout(() => {
                console.log('Checking genre channel autopopulation results...');
                checkGenreChannelContent();
            }, 3000);
        }

        // NEW: Comprehensive genre channel integration test
        function testGenreChannelIntegration() {
            console.log('=== Testing Complete Genre Channel Integration ===');
            
            // Test 1: Channel switching
            console.log('Test 1: Switching to genre channel...');
            switchToGenreChannel();
            
            // Test 2: Show detection
            const testShow = {
                title: 'STRANGER THINGS',
                genre: 'Thriller',
                service: 'NETFLIX',
                season: 'S4',
                episode: 'E9',
                duration: 51
            };
            
            console.log('Test 2: Sending show detection...');
            sendShowDetection(testShow);
            
            // Test 3: Content request
            setTimeout(() => {
                console.log('Test 3: Requesting content from genre channel...');
                const channelFrame = document.getElementById('channel-frame-indexing');
                if (channelFrame && channelFrame.contentWindow) {
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                }
            }, 2000);
            
            // Test 4: Verification
            setTimeout(() => {
                console.log('Test 4: Verifying integration...');
                console.log('Current automode content items:', appState.automodeContentItems);
                console.log('Current channel:', appState.currentChannel);
                console.log('Pending show for genre channel:', appState.pendingShowForGenreChannel);
                
                // Check if content was populated
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    console.log('✅ Genre channel integration successful - content populated');
                } else {
                    console.log('⚠️ Genre channel integration - no content yet, may need more time');
                }
            }, 4000);
        }

        // NEW: Test backend genre autopopulation specifically
        function testBackendGenreAutopopulation() {
            console.log('=== Testing Backend Genre Autopopulation ===');
            
            // Check if backend is ready
            if (!window.RumiBackend || !window.RumiBackend.isReady()) {
                console.log('❌ Backend not ready, cannot test genre autopopulation');
                return;
            }
            
            console.log('✅ Backend is ready, testing genre filtering...');
            
            // Test different genres
            const testGenres = ['drama', 'comedy', 'sci-fi', 'action', 'documentary'];
            
            testGenres.forEach(genre => {
                console.log(`\n--- Testing genre: ${genre} ---`);
                
                // Test genre filtering
                const filteredContent = window.RumiBackend.filterContentByGenre(genre);
                console.log(`Found ${filteredContent.length} items for genre: ${genre}`);
                
                if (filteredContent.length > 0) {
                    console.log('Sample items:');
                    filteredContent.slice(0, 3).forEach(item => {
                        console.log(`  - ${item.title} (${item.duration}min, ${item.service})`);
                    });
                }
                
                // Test genre session creation
                const genreSession = window.RumiBackend.createGenreSession(120, genre);
                console.log(`Created ${genreSession.content.length} items for ${genre} session`);
                console.log(`Total duration: ${genreSession.totalDuration} minutes`);
            });
            
            // Test with a specific detected show
            const testShow = {
                title: 'BREAKING BAD',
                genre: 'drama',
                service: 'NETFLIX',
                season: 'S5',
                episode: 'E16',
                duration: 47
            };
            
            console.log('\n--- Testing with detected show ---');
            console.log('Test show:', testShow);
            
            // Simulate the detection flow
            appState.entryPoint = 'detection';
            appState.detectedShow = testShow;
            
            const sessionDuration = 240; // 4 hours
            const contentItems = getShowDetectionContent(testShow, sessionDuration);
            
            console.log(`Generated ${contentItems.length} content items for detection mode`);
            console.log('Content items:', contentItems);
            
            console.log('✅ Backend genre autopopulation test complete');
        }

        // Simple test to verify message passing to genre channel
        function testMessagePassing() {
            console.log('=== Testing Message Passing ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            
            // Send a simple test message
            const testMessage = {
                type: 'test-message',
                payload: { test: 'Hello from main window' }
            };
            
            console.log('Sending test message:', testMessage);
            
            if (channelFrame.contentWindow) {
                try {
                    channelFrame.contentWindow.postMessage(testMessage, '*');
                    console.log('Test message sent successfully');
                } catch (e) {
                    console.error('Error sending test message:', e);
                }
            } else {
                console.log('Channel frame not ready');
            }
        }

        // Function to check if genre channel is actually loaded
        function checkGenreChannelLoaded() {
            console.log('=== Checking Genre Channel Loaded ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    console.log('Iframe document readyState:', iframeDocument.readyState);
                    
                    // Check if it's actually the genre channel
                    if (iframeDocument.title === 'Rumi Genre Channel') {
                        console.log('✅ Genre channel is loaded correctly');
                    } else {
                        console.log('❌ Wrong channel loaded:', iframeDocument.title);
                    }
                    
                    // Try to access a genre channel specific element
                    const genreSelect = iframeDocument.getElementById('genre-select');
                    if (genreSelect) {
                        console.log('✅ Genre select element found');
                    } else {
                        console.log('❌ Genre select element not found');
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            } else {
                console.log('❌ Channel frame not ready');
            }
        }

        // Expandable sections functionality
        function expandSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('expanded');
            }
        }

        function collapseSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.remove('expanded');
            }
        }

        function collapseAllSections() {
            const sections = document.querySelectorAll('.expandable-section');
            sections.forEach(section => {
                section.classList.remove('expanded');
            });
        }

        // ================================
        // LUDICROUS MODE SYSTEM (BACKEND INTEGRATED)
        // ================================
        
                // LUDICROUS SPEED MODE - Unified high-speed processing for all entry points
        function toggleLudicrousMode() {
            if (!appState.isIndexing) {
                console.log('🚀 Ludicrous Speed: Please start an indexing session first');
                alert('Please start an indexing session first to use Ludicrous Mode');
                return;
            }
            
            // Check cooldown
            if (appState.debugSkipCooldown > 0) {
                console.log('🚀 Ludicrous Speed: Still in cooldown');
                return;
            }

            // LUDICROUS SPEED MODE - Unified high-speed processing for all entry points
            console.log('🚀 LUDICROUS SPEED: Checking activation conditions...');
            
            // Check if LudicrousSpeedManager is available
            if (!window.LudicrousSpeedManager) {
                console.log('❌ LudicrousSpeedManager not available');
                alert('LudicrousSpeedManager not available');
                return;
            }
                
            // Set cooldown
            appState.debugSkipCooldown = 5;
            updateDebugButtonStates();

            if (!window.LudicrousSpeedManager.isActive) {
                // ACTIVATE LUDICROUS SPEED
                console.log('🚀 LUDICROUS SPEED: Activating for all content processing...');
                
                // Initialize fast mode state for compatibility
                appState.fastMode = {
                    active: true,
                    mode: appState.entryPoint,
                    speedMultiplier: 300,
                    ludicrousMode: true
                };
                
                // Activate LudicrousSpeedManager
                window.LudicrousSpeedManager.activate();
                
                // Activate backend integration for accelerated multiplier
                if (window.RumiIntegration && window.RumiIntegration.activateLudicrousMode) {
                    window.RumiIntegration.activateLudicrousMode();
                }
                
                // Start processing current content with ludicrous speed
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    console.log('🚀 LUDICROUS SPEED: Starting content processing...');
                    startLudicrousContentProcessing();
                }
                
                console.log('✅ LUDICROUS SPEED ACTIVATED: 300x speed processing with transition protection!');
                alert('🚀 LUDICROUS SPEED ACTIVATED! Session will complete in ~9 seconds instead of 45 minutes!');
                
            } else {
                // DEACTIVATE LUDICROUS SPEED
                console.log('🛑 LUDICROUS SPEED: Deactivating...');
                
                // Deactivate LudicrousSpeedManager
                window.LudicrousSpeedManager.deactivate();
                
                // Deactivate backend integration
                if (window.RumiIntegration && window.RumiIntegration.deactivateLudicrousMode) {
                    window.RumiIntegration.deactivateLudicrousMode();
                }
                
                // Clear fast mode state
                appState.fastMode = {
                    active: false,
                    mode: null,
                    ludicrousMode: false
                };
                
                console.log('✅ LUDICROUS SPEED DEACTIVATED: Returning to normal processing');
                alert('🛑 LUDICROUS SPEED DEACTIVATED: Returning to normal speed');
            }
            
            Tracker.logRumiAction('FAST_MODE_TOGGLED', { 
                timestamp: Date.now(),
                active: appState.fastMode?.active || false,
                mode: appState.fastMode?.mode || 'unknown',
                entryPoint: appState.entryPoint,
                currentShow: appState.detectedShow?.title || 'Unknown'
            });

            // Start cooldown countdown
            startDebugCooldown('skip');
        }

        // Ludicrous Mode - High-speed content processing
        function startLudicrousMode() {
            if (!appState.ludicrousMode || !appState.ludicrousMode.active) return;
            
            console.log('Ludicrous Mode: Starting 500x speed processing...');
            
            // Calculate accelerated session duration (500x faster)
            const originalDurationMs = (appState.ludicrousMode.originalSessionDuration || 45) * 60 * 1000;
            const acceleratedDurationMs = originalDurationMs / appState.ludicrousMode.speedMultiplier;
            
            console.log(`Ludicrous Mode: Original session ${appState.ludicrousMode.originalSessionDuration || 45} min, accelerated to ${(acceleratedDurationMs / 1000).toFixed(1)}s`);
            
            // Update session start time to simulate 500x speed
            const currentTime = Date.now();
            const elapsedTime = currentTime - appState.indexingStartTime;
            const acceleratedElapsedTime = elapsedTime * appState.ludicrousMode.speedMultiplier;
            
            // Adjust start time so that elapsed time appears much longer
            appState.indexingStartTime = currentTime - acceleratedElapsedTime;
            
            // Set up accelerated content updates
            appState.ludicrousMode.contentInterval = setInterval(() => {
                if (appState.ludicrousMode && appState.ludicrousMode.active) {
                    // Update content at 500x speed
                    if (appState.automodeContentItems && appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                        appState.currentContentIndex++;
                        console.log(`Ludicrous Mode: Advanced to content ${appState.currentContentIndex + 1}/${appState.automodeContentItems.length}`);
                    }
                    
                    // Update UI to show accelerated progress
                    const acceleratedElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    updateAnimationPanel(acceleratedElapsedTime);
                }
            }, 100); // Update every 100ms for ultra-fast acceleration
            
            // Set up completion timer
            const remainingTime = acceleratedDurationMs - (elapsedTime / appState.ludicrousMode.speedMultiplier);
            
            if (remainingTime > 0) {
                console.log(`Ludicrous Mode: Session will complete in ${(remainingTime / 1000).toFixed(1)}s`);
                
                appState.ludicrousMode.completionTimer = setTimeout(() => {
                    if (appState.ludicrousMode && appState.ludicrousMode.active) {
                        completeLudicrousModeSession();
                    }
                }, remainingTime);
            } else {
                // Session should complete immediately
                console.log('Ludicrous Mode: Session duration exceeded, completing immediately');
                setTimeout(() => completeLudicrousModeSession(), 100);
            }
        }

        // Stop Ludicrous Mode
        function stopLudicrousMode() {
            if (!appState.ludicrousMode || !appState.ludicrousMode.active) return;
            
            console.log('Ludicrous Mode: Stopping 500x speed...');
            
            // Clear completion timer
            if (appState.ludicrousMode.completionTimer) {
                clearTimeout(appState.ludicrousMode.completionTimer);
                appState.ludicrousMode.completionTimer = null;
            }
            
            // Clear content interval
            if (appState.ludicrousMode.contentInterval) {
                clearInterval(appState.ludicrousMode.contentInterval);
                appState.ludicrousMode.contentInterval = null;
            }
            
            // Restore original timing (calculate actual elapsed time at normal speed)
            if (appState.ludicrousMode.originalStartTime) {
                const currentTime = Date.now();
                const acceleratedElapsedTime = currentTime - appState.indexingStartTime;
                const normalElapsedTime = acceleratedElapsedTime / appState.ludicrousMode.speedMultiplier;
                
                // Set start time to reflect normal elapsed time
                appState.indexingStartTime = currentTime - normalElapsedTime;
                
                console.log(`Ludicrous Mode: Restored to normal timing, actual elapsed: ${(normalElapsedTime / 1000 / 60).toFixed(1)} min`);
            }
        }

        // NEW: Complete auto mode fast mode session
        function completeAutoModeFastModeSession() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Session completed - showing receipt...');
            
            // Deactivate fast mode
            appState.fastMode.active = false;
            
            // Calculate final session stats
            const sessionDurationMinutes = appState.sessionDuration || 45;
            const totalPoints = sessionDurationMinutes * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1);
            
            // Create receipt
            const receipt = {
                sessionId: `automode_fast_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDurationMinutes,
                numberOfShows: 1, // Auto mode typically has one continuous session
                playedContent: appState.playedContent || [],
                mode: 'automode',
                fastMode: true,
                speedMultiplier: 50
            };
            
            // Stop indexing
            stopIndexing();
            
            // Show receipt
            showSessionReceipt(receipt);
            
            // Clean up fast mode state
            appState.fastMode = null;
            
            console.log('Auto Mode Fast Mode: Receipt displayed, session complete');
        }

        // NEW: Complete detection mode fast mode session
        function completeFastModeSession() {
            if (!appState.fastMode || appState.fastMode.mode !== 'detection') return;
            
            console.log('Detection Fast Mode: Session completed - showing receipt...');
            
            // Deactivate fast mode
            appState.fastMode.active = false;
            
            // Calculate final session stats
            const sessionDurationMinutes = appState.sessionDuration || 45;
            const totalPoints = sessionDurationMinutes * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1);
            
            // Create receipt
            const receipt = {
                sessionId: `detection_fast_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDurationMinutes,
                numberOfShows: appState.playedContent ? appState.playedContent.length : 1,
                playedContent: appState.playedContent || [],
                mode: 'detection',
                fastMode: true,
                speedMultiplier: 10
            };
            
            // Stop indexing
            stopIndexing();
            
            // Show receipt
            showSessionReceipt(receipt);
            
            // Clean up fast mode state
            appState.fastMode = null;
            
            console.log('Detection Fast Mode: Receipt displayed, session complete');
        }
        
        // Make function globally accessible
        window.completeFastModeSession = completeFastModeSession;

        // NEW: Detection mode fast mode navigation
        function startFastModeNavigation() {
            if (!appState.fastMode || appState.fastMode.mode !== 'detection') return;
            
            console.log('Detection Fast Mode: Starting smart content navigation...');
            
            // Initialize transition system if not already done
            if (!window.transitionSystem) {
                console.log('Detection Fast Mode: Initializing transition system...');
                window.transitionSystem = new TransitionSystem();
            }
            
            // Set up fast mode navigation with transition system
            if (window.transitionSystem && appState.detectedShow) {
                console.log('Detection Fast Mode: Using transition system for smart navigation');
                
                // Initialize transition system with detected show
                window.transitionSystem.initialize(appState.detectedShow, {
                    baseRate: appState.baseRate || 0.1,
                    uiCallbacks: {
                        onStateChange: () => console.log('Fast Mode: State changed'),
                        onShowChange: () => console.log('Fast Mode: Show changed'),
                        onMultiplierChange: () => console.log('Fast Mode: Multiplier changed'),
                        onProgressUpdate: () => console.log('Fast Mode: Progress updated'),
                        onSessionComplete: () => {
                            console.log('Fast Mode: Session completed');
                            completeFastModeSession();
                        }
                    }
                });
                
                // Start accelerated session time updates
                appState.fastMode.navigationInterval = setInterval(() => {
                    if (appState.fastMode && appState.fastMode.active) {
                        // Update session time at 10x speed
                        const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        const acceleratedTime = elapsedTime * 10; // 10x speed
                        
                        window.transitionSystem.updateSessionTime(acceleratedTime);
                        
                        // Update indexing progress every 30 seconds (accelerated)
                        if (Math.floor(acceleratedTime) % 30 === 0) {
                            window.transitionSystem.updateIndexingProgress(5); // 5 minutes worth
                        }
                        
                        // Check if session should complete
                        const sessionDuration = calculateSessionDuration();
                        if (acceleratedTime >= sessionDuration) {
                            completeFastModeSession();
                        }
                    }
                }, 1000); // Update every second
                
            } else {
                console.log('Detection Fast Mode: Transition system not available, using basic navigation');
                // Fallback to basic fast mode
                appState.fastMode.fallbackInterval = setInterval(() => {
                    if (appState.fastMode && appState.fastMode.active) {
                        // Basic fast mode: just accelerate time
                        const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        const acceleratedTime = elapsedTime * 10; // 10x speed
                        
                        // Update UI to show accelerated progress
                        updateAnimationPanel(acceleratedTime);
                        
                        // Check if session should complete
                        const sessionDuration = calculateSessionDuration();
                        if (acceleratedTime >= sessionDuration) {
                            completeFastModeSession();
                        }
                    }
                }, 1000);
            }
        }

        // NEW: Start Ludicrous Speed content processing
        function startLudicrousContentProcessing() {
            if (!window.LudicrousSpeedManager || !window.LudicrousSpeedManager.isActive) {
                console.log('❌ LudicrousSpeedManager not active, cannot start processing');
                return;
            }
            
            if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                console.log('❌ No content items available for ludicrous processing');
                return;
            }
            
            console.log('🚀 LUDICROUS SPEED: Starting sequential content processing...');
            console.log(`📋 Content queue: ${appState.automodeContentItems.length} items`);
            
            // Process content starting from current index
            const startIndex = appState.currentContentIndex || 0;
            console.log(`🎯 Starting processing from index ${startIndex}`);
            
            // Start processing the current content item
            processCurrentContentWithLudicrous();
        }

        // Process current content item with Ludicrous Speed
        function processCurrentContentWithLudicrous() {
            if (!window.LudicrousSpeedManager || !window.LudicrousSpeedManager.isActive) {
                console.log('❌ LUDICROUS: LudicrousSpeedManager not active');
                return; // Ludicrous speed has been deactivated
            }
            
            if (!appState.automodeContentItems || appState.currentContentIndex >= appState.automodeContentItems.length) {
                console.log('🚀 Ludicrous Speed: All content processed - session complete!');
                window.LudicrousSpeedManager.deactivate();
                return;
            }
            
            const currentItem = appState.automodeContentItems[appState.currentContentIndex];
            if (!currentItem) {
                console.log('❌ LUDICROUS: No current item available');
                return;
            }
            
            console.log(`🎬 LUDICROUS: Processing item ${appState.currentContentIndex + 1}/${appState.automodeContentItems.length}: "${currentItem.title}"`);
            console.log(`🔍 LUDICROUS: Item details:`, currentItem);
            
            // Calculate expected seconds for timed content
            let expectedSeconds = null;
            if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                const parts = currentItem.duration.split(':');
                expectedSeconds = parseInt(parts[0]) * 60 + parseInt(parts[1]);
                console.log(`⏱️ LUDICROUS: Duration string "${currentItem.duration}" converted to ${expectedSeconds} seconds`);
            } else if (typeof currentItem.duration === 'number') {
                expectedSeconds = currentItem.duration * 60; // Convert minutes to seconds
                console.log(`⏱️ LUDICROUS: Duration number ${currentItem.duration} minutes converted to ${expectedSeconds} seconds`);
            } else {
                console.log(`⚠️ LUDICROUS: Unknown duration format: ${typeof currentItem.duration} = ${currentItem.duration}`);
            }
            
            // Process with LudicrousSpeedManager
            const processed = window.LudicrousSpeedManager.processContent(currentItem, expectedSeconds);
            
            if (processed) {
                console.log(`✅ LUDICROUS: Item "${currentItem.title}" submitted for processing`);
                // LudicrousSpeedManager handles completion and advancement automatically
            } else {
                console.log(`❌ LUDICROUS: Failed to process "${currentItem.title}"`);
            }
        }

        // NEW: Update content display for fast mode
        function updateContentDisplay() {
            console.log('Updating content display for fast mode...');
            // This would update the UI to show fast mode status
            // For now, just log the action
        }

        // NEW: Show session receipt function
        function showSessionReceipt(receipt) {
            console.log('Showing session receipt:', receipt);
            
            // Calculate correct points based on actual session data
            const actualSessionDuration = appState.isIndexing ? (Date.now() - appState.indexingStartTime) / 1000 / 60 : 0; // minutes
            const actualPoints = actualSessionDuration * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0);
            
            // Update receipt display elements
            const totalPointsElement = document.getElementById('receipt-total-points');
            const durationElement = document.getElementById('receipt-duration');
            const multiplierElement = document.getElementById('receipt-multiplier');
            const bonusElement = document.getElementById('receipt-bonus');
            
            if (totalPointsElement) {
                totalPointsElement.textContent = `+${actualPoints.toFixed(2)}`;
            }
            
            if (durationElement) {
                const minutes = Math.floor(actualSessionDuration);
                const seconds = Math.round((actualSessionDuration - minutes) * 60);
                durationElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            if (multiplierElement) {
                multiplierElement.textContent = `${appState.currentMultiplier || 1.0}x`;
            }
            
            if (bonusElement) {
                if (receipt.fastMode) {
                    bonusElement.textContent = `Fast Mode (${receipt.speedMultiplier}x)`;
                } else {
                    bonusElement.textContent = 'None';
                }
            }
            
            // Show the receipt view
            const receiptView = document.getElementById('receipt-view');
            const mainView = document.getElementById('main-view');
            const extensionPopup = document.querySelector('.extension-popup');
            
            if (receiptView && mainView && extensionPopup) {
                mainView.style.display = 'none';
                receiptView.style.display = 'block';
                extensionPopup.style.display = 'block';
            }
            
            console.log('Session receipt displayed successfully');
        }

        // NEW: Start debug cooldown function
        function startDebugCooldown(type) {
            if (type === 'skip') {
                // Start countdown for skip button
                const countdown = setInterval(() => {
                    appState.debugSkipCooldown--;
                    if (appState.debugSkipCooldown <= 0) {
                        clearInterval(countdown);
                        appState.debugSkipCooldown = 0;
                    }
                    updateDebugButtonStates();
                }, 1000);
            }
        }

        // NEW: Update debug button states function
        function updateDebugButtonStates() {
            const ludicrousModeBtn = document.getElementById('debug-ludicrous-mode-btn');
            
            // Update Ludicrous Speed button
            if (ludicrousModeBtn) {
                if (appState.debugSkipCooldown > 0) {
                    ludicrousModeBtn.textContent = `⚡ LUDICROUS SPEED (${appState.debugSkipCooldown}s)`;
                    ludicrousModeBtn.disabled = true;
                } else if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                    ludicrousModeBtn.textContent = '⚡ LUDICROUS SPEED (ACTIVE)';
                    ludicrousModeBtn.disabled = false;
                } else {
                    ludicrousModeBtn.textContent = '⚡ LUDICROUS SPEED (300x)';
                    ludicrousModeBtn.disabled = false;
                }
            }
            
            // Update indexing status to show Ludicrous Mode
            const statusElement = document.getElementById('indexing-status-text');
            if (statusElement) {
                if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                    statusElement.textContent = '🚀 LUDICROUS SPEED (300x)';
                    statusElement.style.color = '#00ff41';
                    statusElement.style.fontWeight = 'bold';
                } else if (appState.isIndexing) {
                    statusElement.textContent = 'Indexing';
                    statusElement.style.color = '#00ff41';
                    statusElement.style.fontWeight = 'normal';
                } else {
                    statusElement.textContent = 'Stopped';
                    statusElement.style.color = '#ff4444';
                    statusElement.style.fontWeight = 'normal';
                }
            }
        }

        // NEW: Calculate session duration function
        function calculateSessionDuration() {
            // Default session duration in minutes
            const defaultDuration = 45;
            
            // If we have a detected show, use its duration
            if (appState.detectedShow && appState.detectedShow.duration) {
                return appState.detectedShow.duration * 60; // Convert to seconds
            }
            
            // For automode, use default duration
            if (appState.entryPoint === 'automode') {
                return defaultDuration * 60; // Convert to seconds
            }
            
            // Fallback to default
            return defaultDuration * 60; // Convert to seconds
        }

        // NEW: Helper function to format running time display
        function formatRunningTime(elapsedTime) {
            const sessionDuration = calculateSessionDuration();
            const elapsedMinutes = Math.floor(elapsedTime / 60);
            const elapsedSeconds = Math.floor(elapsedTime % 60);
            const totalMinutes = Math.floor(sessionDuration / 60);
            const totalSeconds = Math.floor(sessionDuration % 60);
            return `${elapsedMinutes}:${elapsedSeconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
        }

        // NEW: Change bucket function
        function changeBucket(bucketName) {
            appState.currentBucket = bucketName;
            console.log('Rumi bucket set to:', bucketName);
            
            // Update the bucket in the channel if it's loaded
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            if (channelFrame && channelFrame.contentWindow) {
                channelFrame.contentWindow.postMessage({
                    type: 'rumi:setBucket',
                    payload: { bucket: bucketName }
                }, '*');
            }
            
            if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                channelFrameIndexing.contentWindow.postMessage({
                    type: 'rumi:setBucket',
                    payload: { bucket: bucketName }
                }, '*');
            }
            
            Tracker.logRumiAction('Bucket changed', { bucket: bucketName, project: 'Rumi Extension' });
        }

        // NEW: Change genre function
        function changeGenre(genreName) {
            console.log('Genre changed to:', genreName);
            
            // Update the detected show genre if we have one
            if (appState.detectedShow) {
                appState.detectedShow.genre = genreName;
                console.log('Updated detected show genre to:', genreName);
            }
            
            // Send genre change to genre channel
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            if (channelFrame && channelFrame.contentWindow) {
                channelFrame.contentWindow.postMessage({
                    type: 'genreChanged',
                    payload: { genre: genreName }
                }, '*');
            }
            
            if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                channelFrameIndexing.contentWindow.postMessage({
                    type: 'genreChanged',
                    payload: { genre: genreName }
                }, '*');
            }
            
            // If we have backend integration, get new content for this genre
            if (window.RumiBackend && window.RumiBackend.isReady()) {
                console.log('Getting new content for genre:', genreName);
                const sessionDuration = calculateSessionDuration();
                const remainingTime = sessionDuration - (appState.detectedShow?.duration || 45);
                
                if (remainingTime > 0) {
                    const relatedContent = window.RumiBackend.filterContentByGenre(genreName);
                    console.log(`Found ${relatedContent.length} items for genre: ${genreName}`);
                    
                    // Send new content to genre channel
                    if (channelFrame && channelFrame.contentWindow) {
                        channelFrame.contentWindow.postMessage({
                            type: 'populateWithContent',
                            payload: { 
                                content: relatedContent.slice(0, 10), // Send first 10 items
                                genre: genreName
                            }
                        }, '*');
                    }
                    
                    if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                        channelFrameIndexing.contentWindow.postMessage({
                            type: 'populateWithContent',
                            payload: { 
                                content: relatedContent.slice(0, 10), // Send first 10 items
                                genre: genreName
                            }
                        }, '*');
                    }
                }
            }
            
            Tracker.logRumiAction('Genre changed', { genre: genreName, project: 'Rumi Extension' });
        }



        // New Error Testing Functions

        // New Error Testing Functions
        function testSpeedError() {
            setErrorState('speed-error');
            updateMessageArea('speed-error');
            autoExpandSections('speed-error');
            Tracker.logRumiAction('SPEED_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSystemError() {
            setErrorState('system-error');
            updateMessageArea('system-error');
            autoExpandSections('system-error');
            Tracker.logRumiAction('SYSTEM_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testNetworkError() {
            setErrorState('network-error');
            updateMessageArea('network-error');
            autoExpandSections('network-error');
            Tracker.logRumiAction('NETWORK_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testBrowserError() {
            setErrorState('browser-error');
            updateMessageArea('browser-error');
            autoExpandSections('browser-error');
            Tracker.logRumiAction('BROWSER_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSettings() {
            setErrorState('settings');
            updateMessageArea('settings');
            autoExpandSections('settings');
            Tracker.logRumiAction('SETTINGS_PANEL_ACTIVATED', { timestamp: Date.now() });
        }

        function testIndexingPaused() {
            setErrorState('indexing-paused');
            updateMessageArea('indexing-paused');
            autoExpandSections('indexing-paused');
            Tracker.logRumiAction('INDEXING_PAUSED_ACTIVATED', { timestamp: Date.now() });
        }

        function testLanguageError() {
            setErrorState('language-error');
            updateMessageArea('language-error');
            autoExpandSections('language-error');
            Tracker.logRumiAction('LANGUAGE_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testShowInterrupt() {
            console.log('testShowInterrupt called');
            setErrorState('show-interrupt');
            updateMessageArea('show-interrupt');
            autoExpandSections('show-interrupt');
            
            // Ensure content info is populated after a longer delay to allow DOM to fully update
            setTimeout(() => {
                console.log('Attempting to populate content after delay');
                populateInterruptContentInfo();
                
                // Additional debugging to check visibility
                setTimeout(() => {
                    const contentElement = document.getElementById('interrupt-content-info');
                    const warningSection = document.getElementById('warning-details-section');
                    console.log('Content element after population:', contentElement);
                    console.log('Warning section:', warningSection);
                    console.log('Warning section display:', warningSection?.style.display);
                    console.log('Content element innerHTML:', contentElement?.innerHTML);
                    console.log('Content element computed style:', window.getComputedStyle(contentElement));
                }, 100);
            }, 200);
            
            Tracker.logRumiAction('SHOW_INTERRUPT_ACTIVATED', { timestamp: Date.now() });
        }

        function endSession() {
            // Clear any error states
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'fatal_error';
            
            // Log the session end action
            Tracker.logRumiAction('SESSION_ENDED_FATAL_ERROR', { 
                timestamp: Date.now(),
                reason: 'fatal_error'
            });
            
            // Navigate to receipt view
            showReceiptView();
            
            console.log('Session ended due to fatal error - navigating to receipt view');
        }

        // Pause indexing (called when errors occur)
        function pauseIndexing() {
            if (appState.isPaused) return; // Already paused
            
            appState.isPaused = true;
            appState.pauseStartTime = Date.now();
            
            // Add paused class to nokia-content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.classList.add('paused');
            }
            
            // Pause all intervals and animations
            if (pointAccrualInterval) {
                clearInterval(pointAccrualInterval);
                pointAccrualInterval = null;
            }
            if (indexingTimerInterval) {
                clearInterval(indexingTimerInterval);
                indexingTimerInterval = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            Tracker.logRumiAction('INDEXING_PAUSED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings
            });
            
            console.log('Indexing paused');
        }

        // Resume indexing (called when errors are resolved)
        function resumeIndexing() {
            if (!appState.isPaused) return; // Not paused
            
            // Calculate pause duration
            if (appState.pauseStartTime) {
                const pauseTime = Date.now() - appState.pauseStartTime;
                appState.pauseDuration += pauseTime;
                appState.pauseStartTime = null;
            }
            
            appState.isPaused = false;
            
            // Remove paused class from nokia-content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.classList.remove('paused');
            }
            
            // Resume intervals and animations
            startPointsEarning();
            
            Tracker.logRumiAction('INDEXING_RESUMED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings,
                totalPauseDuration: appState.pauseDuration
            });
            
            console.log('Indexing resumed');
        }

        // Enhanced message area update function
        function updateMessageArea(state) {
            const messageArea = document.querySelector('.message-area');
            const messageText = document.getElementById('message-summary-text');
            const errorDetails = document.getElementById('error-details');
            const errorDetailsContent = document.getElementById('error-details-content');
            const warningDetailsContent = document.getElementById('warning-details-content');
            const settingsPanelContent = document.getElementById('settings-panel-content');

            // Remove all error classes
            messageArea.classList.remove('error', 'warning', 'info');
            messageArea.classList.remove('collapsed', 'expanded');

            switch(state) {
                case 'user-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ VOLUME CHANGED - PLEASE RETURN VOLUME TO 100% TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - VOLUME DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Volume level has been detected below 100%. Rumi requires maximum volume for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Use your system volume controls<br>
                                2. Or use the volume slider below<br>
                                3. Ensure volume is at 100%<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Volume monitoring ensures optimal audio capture for content analysis.
                        </div>
                    `;
                    break;

                case 'speed-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ SPEED CHANGED - SET VIDEO SPEED TO 1X TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - SPEED DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Video playback speed has been detected above 1x. Rumi requires normal speed for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Set video speed to 1x (normal)<br>
                                2. Use player speed controls<br>
                                3. Ensure speed is not accelerated<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Speed monitoring ensures accurate content timing and analysis.
                        </div>
                    `;
                    break;

                case 'system-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '❌ INDEXING FAILED - CONNECTION TO RUMI SERVERS LOST <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: SYS-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Connection to Rumi indexing servers has been lost. This may be due to network issues or server maintenance.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your internet connection<br>
                                2. Try refreshing the page<br>
                                3. Contact support if issue persists
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your progress has been saved. You can resume indexing once connection is restored.
                        </div>
                    `;
                    break;

                case 'network-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🌐 NETWORK ERROR - INTERNET CONNECTION REQUIRED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: NET-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Network connectivity has been lost. Rumi requires an active internet connection to function properly.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your Wi-Fi or ethernet connection<br>
                                2. Try disconnecting and reconnecting<br>
                                3. Restart your router if necessary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your session data is saved locally and will sync when connection is restored.
                        </div>
                    `;
                    break;

                case 'browser-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🔧 BROWSER ERROR - COMPATIBILITY ISSUE DETECTED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: BRW-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Your browser is not compatible with Rumi's indexing technology. Please use a supported browser.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">SUPPORTED BROWSERS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                • Google Chrome (version 90+)<br>
                                • Mozilla Firefox (version 88+)<br>
                                • Microsoft Edge (version 90+)<br>
                                • Safari (version 14+)
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Please update your browser or switch to a supported browser to continue indexing.
                        </div>
                    `;
                    break;

                case 'warning':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ PLAYER MODIFIED - PLEASE USE THE CONTROLS BELOW INSTEAD OF PLAYER CONTROLS <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - PLAYER INTERACTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Direct interaction with the video player has been detected. Rumi requires controlled playback for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Avoid direct player interaction<br>
                                2. Use system controls if needed<br>
                                3. Let Rumi manage playback<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            This ensures accurate content tracking and optimal indexing performance.
                        </div>
                    `;
                    break;

                case 'settings':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '⚙️ SETTINGS CONFIGURATION - INDEXING PAUSED DURING SETTINGS <button class="message-button" onclick="simResolveError()">CANCEL</button> <button class="message-button primary" onclick="saveSettings()">SAVE</button>';
                    errorDetails.innerHTML = '';
                    settingsPanelContent.innerHTML = `
                        <!-- Account Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">ACCOUNT</div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 10px;">
                                <span style="color: #888;">Username</span>
                                <span style="color: #fff;">CRYPTO_MAVEN</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 10px;">
                                <span style="color: #888;">Member Since</span>
                                <span style="color: #fff;">Dec 2023</span>
                            </div>
                            <button class="secondary-button" style="width: 100%; margin-top: 8px; background: #ff4444; color: #fff; border-color: #ff4444;">LOGOUT</button>
                        </div>

                        <!-- Preferences Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PREFERENCES</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Desktop Notifications</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-start Indexing</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Disabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Audio Settings Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">AUDIO SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Volume Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-resume on Volume Fix</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Playback Settings Section -->
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PLAYBACK SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Speed Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                        </div>

                        <div style="font-size: 10px; color: #888; font-style: italic; text-align: center;">
                            Settings will be applied immediately. Indexing will resume when you save and close.
                        </div>
                    `;
                    break;

                case 'indexing-paused':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '⏸️ INDEXING PAUSED - READY TO RESUME WHEN ERROR IS RESOLVED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    break;

                case 'language-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🌍 LANGUAGE ERROR - CONTENT LANGUAGE NOT SUPPORTED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - LANGUAGE DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Content language has been detected as Japanese. Rumi currently supports English content only for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">SUPPORTED LANGUAGES</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                • English (Primary)<br>
                                • Spanish (Beta)<br>
                                • French (Beta)<br>
                                • German (Beta)
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Switch to English content<br>
                                2. Or select a supported language<br>
                                3. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Note: Language detection is automatic. Indexing will resume once supported content is detected.
                        </div>
                    `;
                    break;

                case 'show-interrupt':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '<span style="color: #0088ff;">🔄 SHOW INTERRUPT - DIFFERENT CONTENT DETECTED</span> <button class="inline-resume-button" onclick="confirmShowInterrupt()">CONTINUE INDEXING</button> <button class="inline-end-session-button" onclick="endSessionFromInterrupt()">GO TO RECEIPT</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">CONTENT CHANGE DETECTED</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                A different show or movie has been detected. You can continue indexing this new content for additional points.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">NEW CONTENT DETECTED</div>
                            <div id="interrupt-content-info" style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                <!-- Content info will be populated by JavaScript -->
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">YOUR OPTIONS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. <strong>Continue Indexing:</strong> Chain points for additional multiplier (+0.1)<br>
                                2. <strong>Go to Receipt:</strong> End session and view earnings summary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Continuing will add the new content to your session and increase your multiplier bonus.
                        </div>
                    `;
                    // Populate the content info with random show data
                    // populateInterruptContentInfo(); // Commented out - will be called with delay
                    break;

                default:
                    // Normal state - collapse all sections
                    messageText.textContent = 'System operational - Daily bonus in 2h 34m';
                    errorDetails.innerHTML = '';
                    collapseAllSections();
                    break;
            }
        }

        // Helper functions for error recovery
        function saveSettings() {
            clearErrorState();
            Tracker.logRumiAction('SETTINGS_SAVED', { timestamp: Date.now() });
        }

        // Universal error resolution function
        function simResolveError() {
            // Reset simulated volume level if this was a volume error
            if (appState.errorState === 'volume') {
                appState.volumeLevel = 100;
            }
            
            // Clear error state
            clearErrorState();
            
            // Resume indexing if it was paused
            if (appState.isPaused) {
                resumeIndexing();
            }
            
            Tracker.logRumiAction('ERROR_RESOLVED', { 
                timestamp: Date.now(),
                previousError: appState.errorState
            });
            
            console.log('Error resolved, indexing resumed');
        }

        // Helper function to populate interrupt content info with random show data
        function populateInterruptContentInfo() {
            console.log('populateInterruptContentInfo called');
            const contentInfoElement = document.getElementById('interrupt-content-info');
            console.log('Content info element found:', contentInfoElement);
            
            if (!contentInfoElement) {
                console.error('interrupt-content-info element not found');
                return;
            }

            // Get a random show that's different from the current one
            const currentShow = appState.detectedShow;
            console.log('Current show:', currentShow);
            const newShow = availableShows.find(s => s.title !== currentShow?.title) || availableShows[0];
            console.log('New show selected:', newShow);
            
            // Store the new show for later use
            appState.interruptNewShow = newShow;

            const contentHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #fff; font-weight: 600;">${newShow.title}</span>
                    <span style="color: #888;">${newShow.service}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Genre:</span>
                    <span style="color: #fff;">${newShow.genre}</span>
                </div>
                ${newShow.season !== 'N/A' ? `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Episode:</span>
                    <span style="color: #fff;">${newShow.season} ${newShow.episode}</span>
                </div>
                ` : `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Year:</span>
                    <span style="color: #fff;">${newShow.year || 'N/A'}</span>
                </div>
                `}
            `;
            
            console.log('Setting content HTML:', contentHTML);
            contentInfoElement.innerHTML = contentHTML;
            console.log('Content populated successfully');
        }

        // Function to handle confirming show interrupt and continuing indexing
        function confirmShowInterrupt() {
            const newShow = appState.interruptNewShow;
            if (!newShow) {
                console.error('No new show data available for interrupt');
                return;
            }

            // Store the original show for receipt display
            appState.originalShow = appState.detectedShow;
            
            // Record the timestamp when the interrupt occurred
            appState.showInterruptTimestamp = Date.now();

            // Update the detected show to the new one
            appState.detectedShow = newShow;
            detectedShow = newShow;

            // Add chain bonus to multiplier
            if (appState.currentMultiplier) {
                appState.currentMultiplier += 0.1;
            } else {
                appState.currentMultiplier = 1.1;
            }

            // Clear the interrupt state
            clearErrorState();

            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_CONFIRMED', { 
                timestamp: Date.now(),
                newShow: newShow.title,
                newMultiplier: appState.currentMultiplier,
                interruptTimestamp: appState.showInterruptTimestamp
            });

            // Resume indexing with the new show
            resumeIndexing();

            console.log(`Show interrupt confirmed. Continuing with ${newShow.title}. New multiplier: ${appState.currentMultiplier}`);
        }

        // Function to handle ending session from interrupt
        function endSessionFromInterrupt() {
            // Clear the interrupt state
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'show_interrupt_declined';
            
            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_DECLINED', { 
                timestamp: Date.now(),
                reason: 'user_declined_new_content'
            });
            
            // Calculate session duration and earnings
            const sessionDuration = appState.isIndexing ? Date.now() - appState.indexingStartTime : 0;
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Navigate to receipt view
            showReceiptView(sessionDuration, appState.currentMode || 'detection', finalMultiplier);
            
            console.log('Session ended due to show interrupt decline - navigating to receipt view');
        }

        // Helper function to get show detection content based on detected show
        function getShowDetectionContent(detectedShow, sessionDuration) {
            console.log('=== GET SHOW DETECTION CONTENT START ===');
            console.log('Detected show:', detectedShow);
            console.log('Session duration:', sessionDuration);
            
            // Create initial content array with the detected show
            const contentItems = [];
            
            // Add the detected show as the first item
            if (detectedShow) {
                const detectedShowItem = {
                    title: detectedShow.title,
                    duration: detectedShow.duration || 45,
                    type: 'detected_show',
                    service: detectedShow.service || 'DETECTED',
                    season: detectedShow.season || 'N/A',
                    episode: detectedShow.episode || 'N/A',
                    genre: detectedShow.genre || 'Drama'
                };
                contentItems.push(detectedShowItem);
                console.log('Added detected show to content:', detectedShowItem);
            }
            
            // Use backend genre filtering if available
            if (window.RumiBackend && window.RumiBackend.isReady()) {
                console.log('Using backend genre filtering for content population');
                
                // Get genre-filtered content from backend
                const genre = detectedShow?.genre || 'Drama';
                const remainingTime = sessionDuration - (detectedShow?.duration || 45);
                
                // Create genre session using backend
                const genreSession = window.RumiBackend.createGenreSession(remainingTime, genre);
                
                console.log('Backend genre session created:', genreSession);
                
                // Convert backend content to the format expected by the system
                genreSession.content.forEach(item => {
                    const contentItem = {
                        title: item.title,
                        duration: item.duration * 60, // Convert minutes to seconds
                        type: 'related_show',
                        service: item.service || 'GENRE_CHANNEL',
                        season: item.season || 'N/A',
                        episode: item.episode || 'N/A',
                        genre: item.genre || genre
                    };
                    contentItems.push(contentItem);
                });
                
                console.log(`Backend provided ${genreSession.content.length} genre-filtered items`);
            } else {
                console.log('Backend not available, using fallback genre content');
                
                // Fallback to existing genre content system
                const relatedContent = getRelatedContentWithPoints(detectedShow?.genre || 'Drama', sessionDuration - (detectedShow?.duration || 45), appState.baseRate || 0.1, appState.currentMultiplier || 1.0);
                
                // Convert related content to the format expected by the system
                relatedContent.forEach(item => {
                    const contentItem = {
                        title: item.title,
                        duration: parseFloat(item.duration) || 45, // Convert formatTime back to minutes
                        type: 'related_show',
                        service: 'GENRE_CHANNEL',
                        season: 'N/A',
                        episode: 'N/A',
                        genre: detectedShow?.genre || 'Drama'
                    };
                    contentItems.push(contentItem);
                });
            }
            
            console.log('Final content items:', contentItems);
            console.log('=== GET SHOW DETECTION CONTENT COMPLETE ===');
            
            return contentItems;
        }

        // NEW: Helper function to scroll text for current content item
        function scrollText(text, elapsedTime, visibleWidth) {
            if (!text) return '';
            
            // Only scroll if text is longer than visible width
            if (text.length <= visibleWidth) {
                return text;
            }
            
            // Calculate scroll position based on time within current content item
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Start scrolling after transition on is complete (0.5 seconds)
            const scrollStartTime = 0.5;
            const scrollEndTime = appState.contentItemDuration - 3.0; // Stop scrolling 3 seconds before end
            
            if (timeInCurrentItem < scrollStartTime || timeInCurrentItem > scrollEndTime) {
                // Don't scroll during transitions, just show the beginning of the text
                return text.substring(0, visibleWidth);
            }
            
            // Calculate effective scroll time (subtract transition periods)
            const effectiveScrollTime = timeInCurrentItem - scrollStartTime;
            const scrollSpeed = 1.6; // characters per second (doubled from 0.8)
            const scrollOffset = Math.floor(effectiveScrollTime * scrollSpeed) % text.length;
            
            // Scroll from right to left
            const startPos = scrollOffset;
            const endPos = Math.min(startPos + visibleWidth, text.length);
            let scrolledText = text.substring(startPos, endPos);
            
            // If we're near the end, wrap around
            if (endPos === text.length && startPos + visibleWidth > text.length) {
                const remainingChars = visibleWidth - (text.length - startPos);
                scrolledText += ' • ' + text.substring(0, remainingChars);
            }
            
            return scrolledText;
        }

        // Update points display
        
        // ================================
        // LUDICROUS SPEED MANAGER CLASS
        // ================================
        
        // LUDICROUS SPEED MANAGER - Comprehensive implementation with full debug logging
        class LudicrousSpeedManager {
            constructor() {
                this.isActive = false;
                this.startTime = null;
                this.currentSpeed = 1;
                this.totalAcceleratedTime = 0;
                this.lastUpdateTime = null;
                this.speedChangeCount = 0;
                this.transitionCooldownStart = null;
                this.transitionCooldownDuration = 5000; // 5 seconds
                this.safetyDelay = 3000; // 3 seconds safety delay
                this.safetyDelayStart = null;
                this.contentProcessingIndex = 0;
                this.sequentialProgressionMonitoring = false;
                this.channelExpansionLock = false;
                this.stateChangeCallbacks = [];
            }

            activate() {
                if (this.isActive) return;
                
                this.isActive = true;
                this.startTime = Date.now();
                this.lastUpdateTime = this.startTime;
                this.safetyDelayStart = this.startTime;
                this.currentSpeed = 1; // Start at normal speed for safety
                this.contentProcessingIndex = appState.currentContentIndex || 0;
                this.sequentialProgressionMonitoring = true;
                this.channelExpansionLock = true;
                
                console.log('🚀 Ludicrous Speed replacing FastModeManager functionality');
                console.log('✅ FastModeManager calls redirected to LudicrousSpeedManager');
                console.log('🚀 Ludicrous Speed activated! Starting with safe transitions...');
                console.log('⏱️ 3-second safety delay before acceleration...');
                console.log('🔒 LUDICROUS SPEED: Locking channel expansion during processing');
                
                // Start safety delay
                setTimeout(() => {
                    this.safetyDelayStart = null;
                    this.setSpeed(300); // Go to full speed after safety delay
                }, this.safetyDelay);
                
                this.updateDisplay();
                this.notifyStateChange('activated');
            }

            deactivate() {
                if (!this.isActive) return;
                
                // Final time calculation
                this.updateAcceleratedTime();
                
                this.isActive = false;
                this.currentSpeed = 1;
                this.transitionCooldownStart = null;
                this.safetyDelayStart = null;
                this.sequentialProgressionMonitoring = false;
                this.channelExpansionLock = false;
                
                console.log('🛑 LUDICROUS SPEED: Stopped sequential progression monitoring');
                console.log('🔓 LUDICROUS SPEED: Releasing channel expansion lock');
                console.log('🐌 Ludicrous Speed deactivated - returning to normal speed');
                console.log('🚀 Ludicrous Speed: Triggering immediate session completion');
                console.log(`📊 Final Statistics: Real=${this.getRealElapsedTime().toFixed(1)}s, Accelerated=${this.totalAcceleratedTime.toFixed(1)}s`);
                
                this.updateDisplay();
                this.notifyStateChange('deactivated');
            }

            setSpeed(newSpeed) {
                if (!this.isActive) return;
                
                this.updateAcceleratedTime(); // Update with old speed
                
                const oldSpeed = this.currentSpeed;
                this.currentSpeed = newSpeed;
                this.speedChangeCount++;
                
                console.log(`⚡ Speed adjusted to ${newSpeed}x - 🚀 LUDICROUS SPEED MODE`);
                this.updateDisplay();
            }

            detectTransition(message) {
                if (!this.isActive) return;
                
                console.log(`🔍 Detected transition: "${message}"`);
                
                // Slow down during transitions
                this.transitionCooldownStart = Date.now();
                this.setSpeed(10);
                
                console.log('🛑 Reduced speed to 10x for transition safety');
                console.log('⏱️ 5-second cooldown before returning to full speed...');
                
                // Return to full speed after cooldown
                setTimeout(() => {
                    if (this.isActive && this.transitionCooldownStart) {
                        this.transitionCooldownStart = null;
                        this.setSpeed(300);
                        console.log('🚀 Cooldown complete - returning to 300x speed');
                    }
                }, this.transitionCooldownDuration);
            }

            // Content processing methods with debug logging
            processContent(contentItem, expectedSeconds) {
                if (!this.isActive) return false;
                
                console.log(`🔍 DEBUG: LudicrousSpeedManager exists: true, isActive: ${this.isActive}, expectedSeconds: ${expectedSeconds}`);
                
                let result = false;
                if (expectedSeconds) {
                    console.log(`🚀 LUDICROUS SPEED COMPLETION: "${contentItem.title}" (state: ${this.getContentState(contentItem)})`);
                    result = this.handleTimedCompletion(contentItem, expectedSeconds);
                } else {
                    console.log(`🚀 LUDICROUS BYPASS: "${contentItem.title}" has no timing constraints (state: ${this.getContentState(contentItem)}) - allowing completion with visual pacing`);
                    result = this.handleVisualPacing(contentItem);
                }
                
                return result; // Return the result from the handler method
            }

            handleTimedCompletion(contentItem, expectedSeconds) {
                console.log(`🔄 LUDICROUS BLOCK STATE: "${contentItem.title}" current state: ${this.getContentState(contentItem)}`);
                
                // State progression: queued → indexing → indexed
                console.log(`⚡ LUDICROUS: Starting state progression for "${contentItem.title}"`);
                
                // Step 1: Mark as indexing
                this.updateBlockState(contentItem, 'indexing');
                
                const acceleratedTime = expectedSeconds / this.currentSpeed;
                const stateTransitionDelay = 200; // ms between state changes
                const completionDelay = 300; // ms before marking as indexed
                
                console.log(`🎬 LUDICROUS PROCESSING: "${contentItem.title}" will complete in ${acceleratedTime.toFixed(2)}s (accelerated from ${expectedSeconds}s)`);
                
                // Step 2: After processing time, mark as indexed
                setTimeout(() => {
                    console.log(`🏁 LUDICROUS: Marking "${contentItem.title}" as INDEXED`);
                    this.updateBlockState(contentItem, 'indexed');
                    
                    // Step 3: Brief delay before advancing to next content
                    setTimeout(() => {
                        console.log(`✅ LUDICROUS COMPLETION: "${contentItem.title}" fully processed`);
                        this.advanceToNextContent();
                    }, completionDelay);
                    
                }, acceleratedTime * 1000 + stateTransitionDelay);
                
                // Return true to indicate processing started successfully
                return true;
            }

            handleVisualPacing(contentItem) {
                console.log(`🔄 LUDICROUS BLOCK STATE: "${contentItem.title}" current state: ${this.getContentState(contentItem)}`);
                
                // State progression: queued → indexing → indexed
                console.log(`⚡ LUDICROUS: Starting visual pacing for "${contentItem.title}"`);
                
                // Step 1: Mark as indexing
                this.updateBlockState(contentItem, 'indexing');
                
                const completionCount = this.contentProcessingIndex + 1;
                const processingDelay = 300 + (completionCount * 50); // Slightly increasing delay per item
                const stateTransitionDelay = 150; // ms between state changes
                
                console.log(`🎬 LUDICROUS VISUAL PACING: "${contentItem.title}" processing for ${processingDelay}ms (item #${completionCount})`);
                
                // Step 2: After processing delay, mark as indexed
                setTimeout(() => {
                    console.log(`🏁 LUDICROUS: Marking "${contentItem.title}" as INDEXED`);
                    this.updateBlockState(contentItem, 'indexed');
                    
                    // Step 3: Brief delay before advancing to next content
                    setTimeout(() => {
                        console.log(`✅ LUDICROUS COMPLETION: "${contentItem.title}" visual pacing complete`);
                        this.advanceToNextContent();
                    }, stateTransitionDelay);
                    
                }, processingDelay);
                
                // Return true to indicate processing started successfully
                return true;
            }

            updateBlockState(contentItem, state) {
                // Send block state update to channel iframe via postMessage
                try {
                    const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                    const channelFrame = document.getElementById('channel-frame');
                    
                    const message = {
                        type: 'rumi:updateBlockState',
                        payload: {
                            title: contentItem.title,
                            state: state, // 'queued', 'indexing', 'indexed'
                            timestamp: Date.now(),
                            source: 'LudicrousSpeedManager'
                        }
                    };
                    
                    console.log(`🚀 LUDICROUS BLOCK STATE: Sending "${state}" update for "${contentItem.title}"`);
                    
                    // Send to both channel frames
                    if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                        channelFrameIndexing.contentWindow.postMessage(message, '*');
                        console.log(`✅ LUDICROUS: Sent block state to indexing channel frame`);
                    }
                    
                    if (channelFrame && channelFrame.contentWindow) {
                        channelFrame.contentWindow.postMessage(message, '*');
                        console.log(`✅ LUDICROUS: Sent block state to main channel frame`);
                    }
                    
                } catch (error) {
                    console.log(`❌ LUDICROUS: Error updating block state:`, error.message);
                }
            }

            advanceToNextContent() {
                this.contentProcessingIndex++;
                
                // CRITICAL: Update the main app state index to sync progression
                if (appState.currentContentIndex !== undefined) {
                    appState.currentContentIndex++;
                    console.log(`➡️ LUDICROUS: Advanced main index to ${appState.currentContentIndex}`);
                }
                
                // Check for session completion
                if (appState.automodeContentItems && this.contentProcessingIndex >= appState.automodeContentItems.length) {
                    console.log('🚀 Ludicrous Speed: Session completion detected - stopping to prevent loops');
                    this.deactivate();
                    
                    // Trigger session completion
                    setTimeout(() => {
                        if (typeof completeSession === 'function') {
                            completeSession();
                        }
                    }, 100);
                    return; // Don't process next item
                }
                
                // Continue processing next item
                setTimeout(() => {
                    if (this.isActive && typeof processCurrentContentWithLudicrous === 'function') {
                        console.log(`🔄 LUDICROUS: Triggering next content processing`);
                        processCurrentContentWithLudicrous();
                    }
                }, 100);
            }

            getContentState(contentItem) {
                // Try to determine content state
                try {
                    if (window.ContentBlockStateManager && window.ContentBlockStateManager.getState) {
                        return window.ContentBlockStateManager.getState(contentItem.title) || 'unknown';
                    }
                    return 'unknown';
                } catch (error) {
                    return 'unknown';
                }
            }

            updateAcceleratedTime() {
                if (!this.isActive || !this.lastUpdateTime) return;
                
        const now = Date.now();
                const realElapsed = (now - this.lastUpdateTime) / 1000;
                const acceleratedElapsed = realElapsed * this.currentSpeed;
                
                this.totalAcceleratedTime += acceleratedElapsed;
                this.lastUpdateTime = now;
            }

            getRealElapsedTime() {
                if (!this.startTime) return 0;
                return (Date.now() - this.startTime) / 1000;
            }

            getAcceleratedElapsedTime() {
                this.updateAcceleratedTime();
                return this.totalAcceleratedTime;
            }

            isInSafetyDelay() {
                return this.safetyDelayStart !== null;
            }

            isInTransitionCooldown() {
                return this.transitionCooldownStart !== null;
            }

            getStatus() {
                if (!this.isActive) return 'INACTIVE';
                if (this.isInSafetyDelay()) return 'SAFETY DELAY';
                if (this.isInTransitionCooldown()) return 'TRANSITION COOLDOWN';
                return 'PROCESSING';
            }

            updateDisplay() {
                // Update any UI elements if they exist
                const statusEl = document.getElementById('ludicrous-status');
                if (statusEl) {
                    const status = this.getStatus();
                    statusEl.textContent = status;
                    statusEl.className = `status ${status.toLowerCase().replace(' ', '-')}`;
                }
            }

            notifyStateChange(event) {
                this.stateChangeCallbacks.forEach(callback => {
                    try {
                        callback(event, this);
                    } catch (error) {
                        console.log('Error in LudicrousSpeedManager callback:', error);
                    }
                });
            }

            addStateChangeCallback(callback) {
                this.stateChangeCallbacks.push(callback);
            }
        }

        // Initialize global LudicrousSpeedManager
        window.LudicrousSpeedManager = new LudicrousSpeedManager();
        console.log('🚀 LudicrousSpeedManager initialized and available globally');
        
        // Initialize CSV bucket content and populate dropdown
        initializeCSVBuckets();
        
        // ================================
        // SESSION COMPLETION FUNCTIONS
        // ================================
        
        // Complete session function for Ludicrous Speed
        function completeSession() {
            console.log('=== COMPLETING SESSION ===');
            
            // Stop indexing
            if (appState.isIndexing) {
                appState.isIndexing = false;
                console.log('Session indexing stopped');
            }
            
            // Calculate final session stats
            const sessionDurationMinutes = appState.sessionDuration || 45;
            const totalPoints = sessionDurationMinutes * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0);
            
            // Create receipt
            const receipt = {
                sessionId: `ludicrous_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDurationMinutes,
                numberOfShows: 1,
                playedContent: appState.playedContent || [],
                mode: 'ludicrous',
                fastMode: true,
                speedMultiplier: 300
            };
            
            // Show receipt
            showSessionReceipt(receipt);
            
            console.log('Session completed successfully');
        }
        
        // Show session receipt function
        function showSessionReceipt(receipt) {
            console.log('=== SESSION RECEIPT ===');
            console.log('Session ID:', receipt.sessionId);
            console.log('Total Points:', receipt.totalPoints);
            console.log('Total Time:', receipt.totalTimeIndexed);
            console.log('Mode:', receipt.mode);
            console.log('Speed Multiplier:', receipt.speedMultiplier);
            console.log('=====================');
            
            // TODO: Implement UI display for receipt
            // This could be a modal, overlay, or dedicated receipt view
        }
    </script>
</body>
</html>
