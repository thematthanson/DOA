<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlap Investigation - All Genre Channels</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=SF+Mono:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            background: #111;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #00ff41;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #888;
            font-size: 14px;
        }
        
        .controls {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 12px;
        }
        
        .control-group select, .control-group input {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            width: 200px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .btn.primary {
            background: #00ff41;
            border-color: #00ff41;
            color: #000;
        }
        
        .btn.primary:hover {
            background: #00cc33;
            border-color: #00cc33;
        }
        
        .btn.warning {
            background: #ffaa00;
            border-color: #ffaa00;
            color: #000;
        }
        
        .btn.warning:hover {
            background: #ff8800;
            border-color: #ff8800;
        }
        
        .btn.danger {
            background: #ff4444;
            border-color: #ff4444;
            color: #fff;
        }
        
        .btn.danger:hover {
            background: #ff6666;
            border-color: #ff6666;
        }
        
        .channel-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .channel-frame {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .channel-frame iframe {
            width: 100%;
            height: 400px;
            border: none;
            background: transparent;
        }
        
        .results {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .results h3 {
            color: #00ff41;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .result-item {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .result-item.success {
            border-color: #00ff41;
            background: #1a2a1a;
        }
        
        .result-item.warning {
            border-color: #ffaa00;
            background: #2a1a1a;
        }
        
        .result-item.error {
            border-color: #ff4444;
            background: #2a1a1a;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .result-details {
            font-size: 11px;
            color: #888;
            line-height: 1.4;
        }
        
        .log-area {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.3;
        }
        
        .status-bar {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.active {
            background: #00ff41;
        }
        
        .status-indicator.inactive {
            background: #666;
        }
        
        .status-indicator.error {
            background: #ff4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Overlap Investigation</h1>
            <p>Comprehensive testing of overlapping blocks across all genre channels</p>
        </div>
        
        <div class="status-bar">
            <div>
                <span class="status-indicator" id="monitor-status"></span>
                <span id="monitor-text">Change Monitor: Initializing...</span>
            </div>
            <div>
                <span class="status-indicator" id="overlap-status"></span>
                <span id="overlap-text">Overlap Detector: Initializing...</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Test Genre:</label>
                <select id="genre-select">
                    <option value="drama">Drama</option>
                    <option value="comedy">Comedy</option>
                    <option value="action">Action</option>
                    <option value="sci-fi">Sci-Fi</option>
                    <option value="horror">Horror</option>
                    <option value="romance">Romance</option>
                    <option value="thriller">Thriller</option>
                    <option value="documentary">Documentary</option>
                    <option value="animation">Animation</option>
                    <option value="reality">Reality</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Test Mode:</label>
                <select id="test-mode">
                    <option value="auto">Auto Test</option>
                    <option value="manual">Manual Test</option>
                    <option value="stress">Stress Test</option>
                </select>
            </div>
            
            <div class="button-group">
                <button class="btn primary" onclick="startInvestigation()">Start Investigation</button>
                <button class="btn" onclick="testCurrentChannel()">Test Current Channel</button>
                <button class="btn warning" onclick="simulateOverlap()">Simulate Overlap</button>
                <button class="btn" onclick="clearResults()">Clear Results</button>
                <button class="btn" onclick="exportResults()">Export Results</button>
            </div>
        </div>
        
        <div class="channel-container">
            <div class="channel-frame">
                <h3>Channel 1 - Main</h3>
                <iframe id="channel1" src="Genre-channel_v2.html" sandbox="allow-scripts allow-same-origin"></iframe>
            </div>
            <div class="channel-frame">
                <h3>Channel 2 - Test</h3>
                <iframe id="channel2" src="Genre-channel_v2.html" sandbox="allow-scripts allow-same-origin"></iframe>
            </div>
        </div>
        
        <div class="results">
            <h3>Investigation Results</h3>
            <div id="results-container">
                <div class="result-item">
                    <div class="result-title">Ready to investigate</div>
                    <div class="result-details">Click "Start Investigation" to begin testing for overlapping blocks across all genre channels.</div>
                </div>
            </div>
        </div>
        
        <div class="results">
            <h3>Debug Log</h3>
            <div class="log-area" id="debug-log"></div>
        </div>
    </div>

    <script src="change-monitor.js"></script>
    <script src="overlap-detector.js"></script>
    <script>
        // Investigation state
        let investigationState = {
            isRunning: false,
            currentGenre: 'drama',
            testMode: 'auto',
            results: [],
            channels: ['channel1', 'channel2'],
            testGenres: ['drama', 'comedy', 'action', 'sci-fi', 'horror', 'romance', 'thriller', 'documentary', 'animation', 'reality']
        };

        // Initialize investigation
        function initializeInvestigation() {
            log('üîç Initializing overlap investigation...');
            
            // Initialize change monitor
            if (window.changeMonitor) {
                window.changeMonitor.enable();
                updateStatus('monitor', 'active', 'Change Monitor: Active');
            } else {
                updateStatus('monitor', 'error', 'Change Monitor: Not Found');
            }
            
            // Initialize overlap detector
            if (window.overlapDetector) {
                window.overlapDetector.enable();
                updateStatus('overlap', 'active', 'Overlap Detector: Active');
            } else {
                updateStatus('overlap', 'error', 'Overlap Detector: Not Found');
            }
            
            log('‚úÖ Investigation initialized');
        }

        // Start comprehensive investigation
        function startInvestigation() {
            if (investigationState.isRunning) {
                log('‚ö†Ô∏è Investigation already running');
                return;
            }

            investigationState.isRunning = true;
            investigationState.results = [];
            
            log('üöÄ Starting comprehensive overlap investigation...');
            
            const testMode = document.getElementById('test-mode').value;
            investigationState.testMode = testMode;
            
            switch (testMode) {
                case 'auto':
                    runAutoTest();
                    break;
                case 'manual':
                    runManualTest();
                    break;
                case 'stress':
                    runStressTest();
                    break;
            }
        }

        // Run automatic test across all genres
        async function runAutoTest() {
            log('üîÑ Running automatic test across all genres...');
            
            for (const genre of investigationState.testGenres) {
                log(`üì∫ Testing genre: ${genre}`);
                
                // Test both channels
                for (const channelId of investigationState.channels) {
                    await testGenreInChannel(genre, channelId);
                }
                
                // Wait between tests
                await sleep(1000);
            }
            
            log('‚úÖ Automatic test completed');
            investigationState.isRunning = false;
            generateReport();
        }

        // Run manual test for current genre
        function runManualTest() {
            const genre = document.getElementById('genre-select').value;
            log(`üîß Running manual test for genre: ${genre}`);
            
            testGenreInChannel(genre, 'channel1');
        }

        // Run stress test
        async function runStressTest() {
            log('üí• Running stress test...');
            
            // Rapidly switch between genres
            for (let i = 0; i < 20; i++) {
                const genre = investigationState.testGenres[i % investigationState.testGenres.length];
                log(`üî• Stress test iteration ${i + 1}: ${genre}`);
                
                await testGenreInChannel(genre, 'channel1');
                await sleep(200); // Very fast switching
            }
            
            log('‚úÖ Stress test completed');
            investigationState.isRunning = false;
            generateReport();
        }

        // Test a specific genre in a specific channel
        async function testGenreInChannel(genre, channelId) {
            try {
                const iframe = document.getElementById(channelId);
                const frameWindow = iframe.contentWindow;
                
                if (!frameWindow) {
                    log(`‚ùå Cannot access ${channelId} window`);
                    return;
                }
                
                // Send genre selection message
                frameWindow.postMessage({
                    type: 'rumi:setGenre',
                    payload: { genre: genre }
                }, '*');
                
                // Wait for channel to update
                await sleep(500);
                
                // Check for overlaps
                const overlaps = await checkOverlapsInFrame(frameWindow);
                
                // Record result
                const result = {
                    timestamp: Date.now(),
                    genre: genre,
                    channel: channelId,
                    overlaps: overlaps,
                    overlapCount: overlaps.length,
                    blockCount: await getBlockCountInFrame(frameWindow)
                };
                
                investigationState.results.push(result);
                displayResult(result);
                
                log(`üìä ${genre} in ${channelId}: ${overlaps.length} overlaps detected`);
                
            } catch (error) {
                log(`‚ùå Error testing ${genre} in ${channelId}: ${error.message}`);
            }
        }

        // Check for overlaps in an iframe
        async function checkOverlapsInFrame(frameWindow) {
            try {
                // Try to access the overlap detector in the frame
                if (frameWindow.overlapDetector) {
                    return frameWindow.overlapDetector.detectOverlaps();
                }
                
                // Fallback: manual overlap detection
                const blocks = frameWindow.document.querySelectorAll('.program-slot:not(.empty)');
                const overlaps = [];
                
                for (let i = 0; i < blocks.length; i++) {
                    for (let j = i + 1; j < blocks.length; j++) {
                        const block1 = blocks[i];
                        const block2 = blocks[j];
                        
                        const left1 = parseFloat(block1.style.left) || 0;
                        const width1 = parseFloat(block1.style.width) || 0;
                        const right1 = left1 + width1;
                        
                        const left2 = parseFloat(block2.style.left) || 0;
                        const width2 = parseFloat(block2.style.width) || 0;
                        const right2 = left2 + width2;
                        
                        // Check for overlap
                        if (left1 < right2 && left2 < right1) {
                            overlaps.push({
                                block1: {
                                    title: block1.querySelector('.program-title')?.textContent || 'Unknown',
                                    left: left1,
                                    width: width1,
                                    right: right1
                                },
                                block2: {
                                    title: block2.querySelector('.program-title')?.textContent || 'Unknown',
                                    left: left2,
                                    width: width2,
                                    right: right2
                                }
                            });
                        }
                    }
                }
                
                return overlaps;
                
            } catch (error) {
                log(`‚ùå Error checking overlaps in frame: ${error.message}`);
                return [];
            }
        }

        // Get block count in an iframe
        async function getBlockCountInFrame(frameWindow) {
            try {
                const blocks = frameWindow.document.querySelectorAll('.program-slot:not(.empty)');
                return blocks.length;
            } catch (error) {
                return 0;
            }
        }

        // Test current channel
        function testCurrentChannel() {
            const genre = document.getElementById('genre-select').value;
            log(`üîç Testing current channel with genre: ${genre}`);
            
            if (window.overlapDetector) {
                const result = window.overlapDetector.test();
                log(`üìä Current channel test: ${result.overlapCount} overlaps in ${result.blockCount} blocks`);
            } else {
                log('‚ùå Overlap detector not available');
            }
        }

        // Simulate overlap for testing
        function simulateOverlap() {
            log('üé≠ Simulating overlap for testing...');
            
            // Create overlapping blocks for testing
            const programTrack = document.getElementById('program-track');
            if (programTrack) {
                // Create test blocks with intentional overlap
                const block1 = document.createElement('div');
                block1.className = 'program-slot';
                block1.style.left = '10%';
                block1.style.width = '30%';
                block1.innerHTML = '<div class="program-title">Test Block 1</div>';
                
                const block2 = document.createElement('div');
                block2.className = 'program-slot';
                block2.style.left = '25%'; // Overlaps with block1
                block2.style.width = '30%';
                block2.innerHTML = '<div class="program-title">Test Block 2</div>';
                
                programTrack.appendChild(block1);
                programTrack.appendChild(block2);
                
                log('‚úÖ Test overlap created');
            } else {
                log('‚ùå Program track not found');
            }
        }

        // Display a test result
        function displayResult(result) {
            const container = document.getElementById('results-container');
            
            const resultElement = document.createElement('div');
            resultElement.className = `result-item ${result.overlapCount > 0 ? 'error' : 'success'}`;
            
            resultElement.innerHTML = `
                <div class="result-title">
                    ${result.genre.toUpperCase()} - ${result.channel}
                    ${result.overlapCount > 0 ? ` (${result.overlapCount} overlaps)` : ' (No overlaps)'}
                </div>
                <div class="result-details">
                    Blocks: ${result.blockCount} | 
                    Overlaps: ${result.overlapCount} | 
                    Time: ${new Date(result.timestamp).toLocaleTimeString()}
                </div>
            `;
            
            container.appendChild(resultElement);
        }

        // Generate investigation report
        function generateReport() {
            const totalTests = investigationState.results.length;
            const totalOverlaps = investigationState.results.reduce((sum, r) => sum + r.overlapCount, 0);
            const genresWithOverlaps = [...new Set(investigationState.results.filter(r => r.overlapCount > 0).map(r => r.genre))];
            
            log('üìã Investigation Report:');
            log(`   Total tests: ${totalTests}`);
            log(`   Total overlaps: ${totalOverlaps}`);
            log(`   Genres with overlaps: ${genresWithOverlaps.join(', ') || 'None'}`);
            
            if (totalOverlaps > 0) {
                log('‚ö†Ô∏è OVERLAPS DETECTED - Investigation needed!');
            } else {
                log('‚úÖ No overlaps detected across all tests');
            }
        }

        // Clear results
        function clearResults() {
            document.getElementById('results-container').innerHTML = `
                <div class="result-item">
                    <div class="result-title">Results cleared</div>
                    <div class="result-details">Click "Start Investigation" to begin new testing.</div>
                </div>
            `;
            investigationState.results = [];
            log('üóëÔ∏è Results cleared');
        }

        // Export results
        function exportResults() {
            const data = {
                timestamp: Date.now(),
                investigation: investigationState,
                results: investigationState.results
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `overlap-investigation-${Date.now()}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            log('üíæ Results exported');
        }

        // Update status indicators
        function updateStatus(type, status, text) {
            const statusElement = document.getElementById(`${type}-status`);
            const textElement = document.getElementById(`${type}-text`);
            
            statusElement.className = `status-indicator ${status}`;
            textElement.textContent = text;
        }

        // Log function
        function log(message) {
            const logArea = document.getElementById('debug-log');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Utility function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeInvestigation, 1000);
        });
    </script>
</body>
</html> 