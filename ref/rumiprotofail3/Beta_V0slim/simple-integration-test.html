<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Transition System Integration Test</title>
    <style>
        body {
            font-family: 'SF Mono', monospace;
            background: #000;
            color: #00ff41;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #111;
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 20px;
        }

        .test-button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            font-weight: bold;
            margin: 5px;
        }

        .status-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }

        .log-panel {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-entry.info { color: #00ff41; }
        .log-entry.warn { color: #ffaa00; }
        .log-entry.error { color: #ff4444; }
        .log-entry.test { color: #00aaff; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Transition System Integration Test</h1>
        <p>This demonstrates how to safely integrate the transition system into the main application.</p>

        <!-- Test Controls -->
        <div>
            <button class="test-button" onclick="runUnitTests()">Run Unit Tests</button>
            <button class="test-button" onclick="testIntegration()">Test Integration</button>
            <button class="test-button" onclick="simulateMainApp()">Simulate Main App</button>
            <button class="test-button" onclick="clearLog()">Clear Log</button>
        </div>

        <!-- Status Display -->
        <div class="status-panel">
            <h3>Current State</h3>
            <div id="status-display">
                <p>Current Show: <span id="current-show">None</span></p>
                <p>Multiplier: <span id="multiplier">1.0x</span></p>
                <p>Time Indexed: <span id="time-indexed">0/0 minutes</span></p>
                <p>Session Time: <span id="session-time">0:00:00</span></p>
            </div>
        </div>

        <!-- Test Log -->
        <div class="status-panel">
            <h3>Test Log</h3>
            <div class="log-panel" id="log-panel">
                <div class="log-entry info">Integration test ready. Click "Run Unit Tests" to start.</div>
            </div>
        </div>
    </div>

    <script>
        // Mock Transition System (simplified version for testing)
        class MockTransitionSystem {
            constructor() {
                this.state = {
                    currentShow: null,
                    isIndexing: false,
                    isTransitioning: false,
                    multiplier: 1.0,
                    sessionTime: 0,
                    totalSessionLength: 0,
                    timeIndexed: 0,
                    multiplierThresholds: [
                        { time: 60, multiplier: 1.2 },
                        { time: 120, multiplier: 1.5 },
                        { time: 180, multiplier: 2.0 }
                    ],
                    completedContent: new Set(),
                    playedContent: [],
                    baseRate: 0.1,
                    sessionId: Date.now(),
                    uiCallbacks: {
                        onStateChange: null,
                        onShowChange: null,
                        onMultiplierChange: null,
                        onProgressUpdate: null
                    }
                };
            }

            initialize(show, options = {}) {
                log('Initializing transition system', 'info');
                
                this.state.currentShow = show;
                this.state.isIndexing = true;
                this.state.totalSessionLength = show.duration || 0;
                this.state.timeIndexed = 0;
                this.state.sessionTime = 0;
                this.state.multiplier = 1.0;
                
                if (options.uiCallbacks) {
                    this.state.uiCallbacks = { ...this.state.uiCallbacks, ...options.uiCallbacks };
                }
                
                log(`Initialized with: ${show.title} (${show.duration}min)`, 'info');
                this.triggerUIUpdate('state');
            }

            updateSessionTime(seconds) {
                const oldMultiplier = this.state.multiplier;
                this.state.sessionTime = seconds;
                this.state.multiplier = this.calculateMultiplier(seconds);
                
                if (this.state.multiplier !== oldMultiplier) {
                    log(`Multiplier changed: ${oldMultiplier.toFixed(1)}x → ${this.state.multiplier.toFixed(1)}x`, 'info');
                    this.triggerUIUpdate('multiplier');
                }
            }

            updateIndexingProgress(minutes) {
                this.state.timeIndexed += minutes;
                log(`Indexed ${minutes} minutes. Total: ${this.state.timeIndexed}/${this.state.totalSessionLength}`, 'info');
                this.triggerUIUpdate('progress');
            }

            calculateMultiplier(sessionTime) {
                let multiplier = 1.0;
                for (const threshold of this.state.multiplierThresholds) {
                    if (sessionTime >= threshold.time * 60) {
                        multiplier = threshold.multiplier;
                    }
                }
                return multiplier;
            }

            async transitionToShow(newShow) {
                if (!this.state.currentShow) {
                    throw new Error('No current show to transition from');
                }

                log('=== SHOW TRANSITION STARTED ===', 'info');
                log(`From: ${this.state.currentShow.title}`, 'info');
                log(`To: ${newShow.title}`, 'info');

                this.state.isTransitioning = true;
                this.triggerUIUpdate('state');

                if (this.state.timeIndexed > 0) {
                    const points = this.state.timeIndexed * this.state.baseRate * this.state.multiplier;
                    this.state.playedContent.push({
                        title: this.state.currentShow.title,
                        timeIndexed: this.state.timeIndexed,
                        points: points,
                        multiplier: this.state.multiplier,
                        duration: this.state.currentShow.duration
                    });
                    log(`Recorded: ${this.state.currentShow.title} - ${this.state.timeIndexed}min, ${points.toFixed(2)} points`, 'info');
                }

                this.state.currentShow = newShow;
                this.state.totalSessionLength += newShow.duration || 0;
                this.state.timeIndexed = 0;

                await this.delay(1000);

                this.state.isTransitioning = false;
                this.triggerUIUpdate('show');
                log('=== SHOW TRANSITION COMPLETED ===', 'info');
            }

            getCurrentState() {
                return {
                    currentShow: this.state.currentShow,
                    isIndexing: this.state.isIndexing,
                    isTransitioning: this.state.isTransitioning,
                    multiplier: this.state.multiplier,
                    sessionTime: this.state.sessionTime,
                    totalSessionLength: this.state.totalSessionLength,
                    timeIndexed: this.state.timeIndexed,
                    completedContent: Array.from(this.state.completedContent),
                    playedContent: [...this.state.playedContent]
                };
            }

            triggerUIUpdate(type) {
                const callbacks = this.state.uiCallbacks;
                
                switch (type) {
                    case 'state':
                        if (callbacks.onStateChange) {
                            callbacks.onStateChange(this.getCurrentState());
                        }
                        break;
                    case 'show':
                        if (callbacks.onShowChange) {
                            callbacks.onShowChange(this.state.currentShow, this.getCurrentState());
                        }
                        break;
                    case 'multiplier':
                        if (callbacks.onMultiplierChange) {
                            callbacks.onMultiplierChange(this.state.multiplier, this.getCurrentState());
                        }
                        break;
                    case 'progress':
                        if (callbacks.onProgressUpdate) {
                            callbacks.onProgressUpdate(this.state.timeIndexed, this.state.totalSessionLength, this.getCurrentState());
                        }
                        break;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            getSessionReceipt() {
                const totalPoints = this.state.playedContent.reduce((sum, item) => sum + item.points, 0);
                const totalTimeIndexed = this.state.playedContent.reduce((sum, item) => sum + item.timeIndexed, 0);

                return {
                    sessionId: this.state.sessionId,
                    totalPoints: totalPoints,
                    totalTimeIndexed: totalTimeIndexed,
                    numberOfShows: this.state.playedContent.length,
                    finalMultiplier: this.state.multiplier,
                    sessionDuration: this.state.sessionTime,
                    playedContent: [...this.state.playedContent],
                    timestamp: Date.now()
                };
            }
        }

        // Global variables
        let transitionSystem = null;
        let testResults = [];

        // Logging function
        function log(message, type = 'info') {
            const logPanel = document.getElementById('log-panel');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logPanel.appendChild(logEntry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        // Clear log
        function clearLog() {
            document.getElementById('log-panel').innerHTML = '';
            log('Log cleared.');
        }

        // Update UI state display
        function updateStateDisplay() {
            if (!transitionSystem) return;
            
            const state = transitionSystem.getCurrentState();
            
            document.getElementById('current-show').textContent = state.currentShow ? state.currentShow.title : 'None';
            document.getElementById('multiplier').textContent = `${state.multiplier.toFixed(1)}x`;
            document.getElementById('time-indexed').textContent = `${state.timeIndexed}/${state.totalSessionLength} minutes`;
            document.getElementById('session-time').textContent = formatTime(state.sessionTime);
        }

        // Format time
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // UI Callbacks for integration testing
        const uiCallbacks = {
            onStateChange: (state) => {
                log('UI Callback: State changed', 'test');
                updateStateDisplay();
            },
            onShowChange: (show, state) => {
                log(`UI Callback: Show changed to ${show.title}`, 'test');
                updateStateDisplay();
            },
            onMultiplierChange: (multiplier, state) => {
                log(`UI Callback: Multiplier changed to ${multiplier.toFixed(1)}x`, 'test');
                updateStateDisplay();
            },
            onProgressUpdate: (timeIndexed, totalLength, state) => {
                log(`UI Callback: Progress updated - ${timeIndexed}/${totalLength} minutes`, 'test');
                updateStateDisplay();
            }
        };

        // Test functions
        function runUnitTests() {
            log('=== RUNNING UNIT TESTS ===', 'test');
            
            const tests = [
                {
                    name: 'System Initialization',
                    test: () => {
                        transitionSystem = new MockTransitionSystem();
                        const testShow = { title: 'Test Show', duration: 120, id: 'test-show' };
                        transitionSystem.initialize(testShow, { uiCallbacks });
                        
                        const state = transitionSystem.getCurrentState();
                        if (state.currentShow.title !== 'Test Show') throw new Error('Show title mismatch');
                        if (state.totalSessionLength !== 120) throw new Error('Session length mismatch');
                        if (state.multiplier !== 1.0) throw new Error('Initial multiplier mismatch');
                        
                        log('✓ System initialization test passed', 'test');
                    }
                },
                {
                    name: 'Multiplier Progression',
                    test: () => {
                        transitionSystem.updateSessionTime(90 * 60); // 90 minutes
                        if (transitionSystem.state.multiplier !== 1.2) throw new Error('Multiplier progression failed');
                        
                        transitionSystem.updateSessionTime(150 * 60); // 150 minutes
                        if (transitionSystem.state.multiplier !== 1.5) throw new Error('Multiplier progression failed');
                        
                        log('✓ Multiplier progression test passed', 'test');
                    }
                },
                {
                    name: 'Show Transition',
                    test: async () => {
                        const newShow = { title: 'New Show', duration: 90, id: 'new-show' };
                        await transitionSystem.transitionToShow(newShow);
                        
                        const state = transitionSystem.getCurrentState();
                        if (state.currentShow.title !== 'New Show') throw new Error('Show transition failed');
                        if (state.timeIndexed !== 0) throw new Error('Time indexed not reset');
                        if (state.totalSessionLength !== 210) throw new Error('Total session length not updated');
                        
                        log('✓ Show transition test passed', 'test');
                    }
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach(async (testCase) => {
                try {
                    await testCase.test();
                    passed++;
                    testResults.push({ name: testCase.name, status: 'PASS' });
                } catch (error) {
                    failed++;
                    testResults.push({ name: testCase.name, status: 'FAIL', error: error.message });
                    log(`✗ ${testCase.name} failed: ${error.message}`, 'error');
                }
            });

            log(`Unit tests completed: ${passed} passed, ${failed} failed`, 'test');
        }

        function testIntegration() {
            log('=== TESTING INTEGRATION ===', 'test');
            
            // Simulate main app state
            const mainAppState = {
                currentShow: { title: 'Blade Runner 2049', duration: 164, id: 'blade-runner-2049' },
                sessionTime: 0,
                automodeContentItems: [
                    { title: 'Blade Runner 2049', duration: 164 },
                    { title: 'Dune', duration: 155 },
                    { title: 'Arrival', duration: 116 }
                ]
            };
            
            // Initialize transition system with main app data
            transitionSystem = new MockTransitionSystem();
            transitionSystem.initialize(mainAppState.currentShow, { uiCallbacks });
            
            log('✓ Integration with main app state successful', 'test');
            log('✓ UI callback integration successful', 'test');
            
            // Test state synchronization
            transitionSystem.updateSessionTime(90 * 60);
            transitionSystem.updateIndexingProgress(30);
            log('✓ State synchronization successful', 'test');
            
            log('=== INTEGRATION TEST COMPLETED ===', 'test');
        }

        function simulateMainApp() {
            log('=== SIMULATING MAIN APP INTEGRATION ===', 'test');
            
            // Simulate the main app's show detection and content management
            const mainAppSimulation = {
                detectedShow: { title: 'Blade Runner 2049', duration: 164, id: 'blade-runner-2049' },
                contentItems: [
                    { title: 'Blade Runner 2049', duration: 164, type: 'movie' },
                    { title: 'Dune', duration: 155, type: 'movie' },
                    { title: 'Arrival', duration: 116, type: 'movie' }
                ],
                sessionStartTime: Date.now()
            };
            
            // Initialize transition system
            transitionSystem = new MockTransitionSystem();
            transitionSystem.initialize(mainAppSimulation.detectedShow, { uiCallbacks });
            
            // Simulate session progression
            let sessionTime = 0;
            const sessionInterval = setInterval(() => {
                sessionTime += 60; // 1 minute increments
                transitionSystem.updateSessionTime(sessionTime);
                
                // Simulate indexing progress
                if (sessionTime % 15 === 0) { // Every 15 minutes
                    transitionSystem.updateIndexingProgress(15);
                }
                
                // Simulate show transition after 90 minutes
                if (sessionTime === 90) {
                    clearInterval(sessionInterval);
                    const nextShow = mainAppSimulation.contentItems[1];
                    transitionSystem.transitionToShow(nextShow);
                    
                    // Show receipt after transition
                    setTimeout(() => {
                        const receipt = transitionSystem.getSessionReceipt();
                        log('=== SESSION RECEIPT ===', 'test');
                        log(`Total points: ${receipt.totalPoints.toFixed(2)}`, 'test');
                        log(`Total time indexed: ${receipt.totalTimeIndexed} minutes`, 'test');
                        log(`Number of shows: ${receipt.numberOfShows}`, 'test');
                        log('=== END RECEIPT ===', 'test');
                    }, 2000);
                }
            }, 1000); // 1 second intervals for faster testing
            
            log('Main app simulation started - will transition after 90 seconds', 'test');
        }

        // Initialize test environment
        document.addEventListener('DOMContentLoaded', function() {
            log('Integration test environment initialized', 'info');
            log('Ready to test transition system integration', 'info');
        });
    </script>
</body>
</html> 