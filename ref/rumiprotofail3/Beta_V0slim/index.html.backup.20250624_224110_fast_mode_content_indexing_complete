<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumi Extension - Beta V0</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=SF+Mono:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #111;
            color: #fff;
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 50px;
            min-height: 100vh;
        }

        .simulation-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .entry-point-panel {
            width: 220px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .entry-point-header {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }

        .stream-detector {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stream-detector:hover {
            border-color: #00ff41;
            background: #2a2a2a;
        }

        .stream-detector .status {
            font-size: 14px;
            color: #00ff41;
            font-weight: bold;
        }

        .stream-detector .subtext {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .automode-button {
            background: #333;
            color: #ffff00;
            border: 2px solid #ffff00;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .automode-button:hover {
            background: #444;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 0, 0.3);
        }

        .holistic-panel {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .holistic-section {
            width: 100%;
        }

        #holistic-show-info {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        #holistic-animation pre {
            margin: 0;
            padding: 0;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
        }

        #holistic-animation pre.automode {
            color: #ffff00 !important;
        }

        #holistic-progress {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
        }

        .settings-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .message-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 8px;
            transition: all 0.2s ease;
        }

        .message-button:hover {
            background: #333;
            border-color: #666;
            color: #fff;
        }

        .message-button.primary {
            background: #ffff00;
            border-color: #ffff00;
            color: #000;
        }

        .message-button.primary:hover {
            background: #cccc00;
            border-color: #cccc00;
        }

        .inline-resume-button {
            background: #2a2a2a;
            border: 1px solid #ffff00;
            color: #ffff00;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-resume-button:hover {
            background: #333;
            border-color: #cccc00;
            color: #cccc00;
        }

        .inline-end-session-button {
            background: #2a2a2a;
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-end-session-button:hover {
            background: #333;
            border-color: #ff6666;
            color: #ff6666;
        }

        .channel-switcher {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .channel-switcher:hover {
            border-color: #ffff00;
            color: #ffff00;
        }

        .channel-switcher.active {
            background: #ffff00;
            color: #000;
            border-color: #ffff00;
        }

        .popup-balance {
            font-size: 11px;
            color: #666;
        }

        /* Message Area */
        .message-area {
            background: #2a2a2a; /* Darker grey background */
            color: #cccccc; /* Light grey text */
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            max-height: 46px;
            overflow: hidden;
            transition: all 0.3s ease;
            border-radius: 8px; /* Rounded corners to match extension */
        }

        .message-area.error {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff0000; /* Red text for terminal errors */
        }

        .message-area.warning {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff6600; /* Orange text for non-terminal warnings */
        }

        .message-area.info {
            background: #2a2a2a; /* Same darker grey as default */
            color: #8b5cf6; /* Purple text for settings */
        }

        .message-area.collapsed {
            padding: 6px 18px;
            font-size: 12px;
        }

        .message-area.expanded {
            max-height: none;
            padding: 14px 18px;
            font-size: 14px;
        }

        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }

        .collapsed .collapse-icon {
            transform: rotate(180deg);
        }

        /* Popup Body */
        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        /* Points Section */
        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: none;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        /* Automode-specific button styling */
        .primary-cta.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .primary-cta.automode:hover {
            background: #ffff00;
            color: #000;
        }

        .secondary-button.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .cta-subtitle {
            font-size: 12px;
            color: #888;
            margin-bottom: 16px;
            text-align: center;
        }

        /* Queue Section */
        .queue-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .queue-header {
            padding: 8px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .queue-item {
            padding: 6px 12px;
            border-bottom: 1px solid #333;
            font-size: 10px;
        }

        .queue-item:last-child {
            border-bottom: none;
        }

        .queue-item.next {
            background: #1a1000;
            border-left: 3px solid #ffaa00;
        }

        /* Responsive Breakpoints */
        @media (max-height: 600px) {
            .extension-popup {
                height: 450px;
            }
        }

        @media (max-height: 450px) {
            .extension-popup {
                height: 350px;
            }
        }

        @media (max-height: 350px) {
            .extension-popup {
                height: 250px;
            }
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00ff41;
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 10000;
            min-width: 200px;
            display: none; /* Hidden by default */
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-trigger {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            color: #666;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 8px;
            cursor: pointer;
            z-index: 9999;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .debug-trigger:hover {
            border-color: #00ff41;
            color: #00ff41;
            opacity: 1;
        }

        .debug-panel-header {
            color: #00ff41;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .debug-panel-toggle {
            background: none;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-panel-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section {
            margin-bottom: 8px;
            border-top: 1px solid #333;
            padding-top: 8px;
        }

        .debug-section:first-child {
            border-top: none;
            padding-top: 0;
        }

        .debug-section-header {
            color: #888;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-section-toggle {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 10px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .debug-section-content.collapsed {
            max-height: 0;
        }

        .debug-button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 2px;
            font-size: 9px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
        }

        .debug-button.error {
            background: #ff4444;
            color: #fff;
        }

        .debug-button.warning {
            background: #ffaa00;
            color: #000;
        }

        .debug-button.info {
            background: #a985ff;
            color: #000;
        }

        .debug-button.blue {
            background: #0088ff;
            color: #fff;
        }

        .debug-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .debug-button.cooldown {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Progress Bars */
        .progress-bars {
            display: flex;
            gap: 2px;
            height: 28px;
            margin: 8px 0;
            position: relative;
        }

        .progress-bar {
            border-radius: 2px;
        }

        /* Stop Button Styles */
        .primary-cta.stop {
            background: #000000;
            color: #00ff41;
            border: 2px solid #00ff41;
        }

        .primary-cta.stop:hover {
            background: #00ff41;
            color: #000000;
        }

        .primary-cta.stop.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .primary-cta.stop.automode:hover {
            background: #ffff00;
            color: #000000;
        }

        /* Leaderboard Section */
        .leaderboard-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .leaderboard-section:hover {
            border-color: #555;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
        }

        .leaderboard-header .title {
            color: #00ff41;
            font-weight: 600;
            text-transform: uppercase;
        }

        .leaderboard-header .user-rank {
            color: #00ff41;
        }

        /* Automode-specific leaderboard styling */
        .automode .leaderboard-header .title {
            color: #ffff00;
        }

        .automode .leaderboard-header .user-rank {
            color: #ffff00;
        }

        .leaderboard-expand-icon {
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #666;
        }

        .leaderboard-section.is-expanded .leaderboard-expand-icon {
            transform: rotate(180deg);
        }

        .leaderboard-full-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            margin-top: 0;
            border-top: none;
            font-size: 9px;
        }

        .leaderboard-section.is-expanded .leaderboard-full-list {
            max-height: 200px; /* Adjust as needed */
            padding-top: 8px;
            margin-top: 8px;
            border-top: 1px solid #333;
        }

        /* Error States */
        .error-state {
            display: none;
        }

        .error-content {
            padding: 12px;
        }

        .status-indicator-terminal {
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 12px;
            margin: 15px 0;
            border: 2px solid;
            background: #111111;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
        }

        .status-indicator-terminal.warning {
            border-color: #ffaa00;
            color: #ffaa00;
            background: #1a1000;
        }

        .status-indicator-terminal.error {
            border-color: #ff4444;
            color: #ff4444;
            background: #1a0000;
        }

        /* Pulse animation for loading */
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .pulse { 
            animation: pulse 1.5s infinite; 
        }

        /* Indexing Details Section */
        .indexing-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 15px;
            padding: 0 5px;
        }

        .indexing-progress-bar-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 80px;
            margin-bottom: 15px;
            gap: 2px;
        }

        .progress-bar-segment {
            background-color: #00ff41;
            width: 12px;
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .automode .progress-bar-segment {
            background-color: #ffff00;
        }
        
        .progress-bar-segment.grey {
            background-color: #444;
        }

        .progress-bar-divider {
            width: 1px;
            height: 60%;
            background: #555;
            margin: 0 5px;
        }

        .progress-bar-annotation {
            color: #fff;
            font-size: 8px;
            text-align: center;
            line-height: 1.1;
        }
        
        .progress-bar-segment.special-segment {
            width: 30px;
            height: 90%;
            background-color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
        }

        .progress-bar-annotation.top-annotation {
            color: #fff;
        }

        .progress-bar-annotation.bottom-annotation {
            color: #888;
        }

        .indexing-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .now-playing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .now-playing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .stats-info {
            text-align: right;
        }

        .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        /* Remove old separated layout styles */
        .now-next-container, .now-playing-card, .next-up-card, .reward-info, .progress-time {
            all: unset; /* Reset properties from old layout */
        }
        
        .card-header span:nth-child(2) {
            margin: 0 4px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        /* New Indexing UI */
        .indexing-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .indexing-content .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        .indexing-content .indexing-info {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
            margin-bottom: 10px;
        }

        .indexing-content .indexing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .indexing-content .indexing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .indexing-content .stats-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 10px;
        }

        .indexing-content .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .indexing-content .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }

        /* New Horizontal Progress Bar */
        .horizontal-progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .horizontal-progress-bar-fill {
            height: 100%;
            background: #00ff41;
            transition: width 0.5s ease;
        }

        /* New Flippable Card */
        .card-flipper {
            perspective: 1000px;
            width: 100%;
            height: 100px;
            position: relative;
        }

        .card-flipper .card {
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            position: absolute;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card-flipper .card.front {
            transform: rotateY(0deg);
        }

        .card-flipper .card.back {
            transform: rotateY(180deg);
        }

        .card-flipper.is-flipped .card.front {
            transform: rotateY(-180deg);
        }

        .card-flipper.is-flipped .card.back {
            transform: rotateY(0deg);
        }

        .card-flipper .card-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .card-flipper .card-content .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-flipper .card-content .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .card-flipper .card-content .flip-button {
            background: transparent;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        /* Indexing Details Section */
        .nokia-section {
            background: #080808;
            border-radius: 8px;
            padding: 15px;
        }

        .indexing-window, .session-stats-panel {
            background: #111;
            border: 1px solid #333;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-shadow: 0 0 2px #00ff41;
        }
        
        .indexing-window pre, .session-stats-panel pre {
            margin: 0;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
            color: #00ff41;
            font-weight: bold;
        }
        
        .bonus-glint {
            color: #a985ff;
            font-weight: 700;
        }
        
        .now-playing-section {
            background: #1c1c1c;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
        }

        .now-playing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-title {
            font-size: 15px;
            font-weight: 600;
        }

        .show-queue-button {
            width: 100%;
            background: #2a2a2a;
            color: #a985ff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
            text-align: center;
        }
        
        .queue-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            border-top: 1px solid #333;
        }

        .queue-details.is-expanded {
            max-height: 200px;
            padding-top: 10px;
            margin-top: 10px;
        }

        .queue-item {
            font-size: 12px;
            color: #ccc;
            padding: 4px 0;
        }

        /* Settings View */
        .settings-section {
            background: #1c1c1c;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .settings-section-header {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .settings-item:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            color: #ccc;
        }

        .settings-value {
            color: #00ff41;
            font-weight: 600;
        }

        .settings-logout-button {
            width: 100%;
            background: #4d0000;
            color: #ff4444;
            border: 1px solid #ff4444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
        }

        /* Toggle Switch CSS */
        .switch {
          position: relative;
          display: inline-block;
          width: 34px;
          height: 20px;
        }

        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #333;
          transition: .4s;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 14px;
          width: 14px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          transition: .4s;
        }

        input:checked + .slider {
          background-color: #00ff41;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #00ff41;
        }

        input:checked + .slider:before {
          transform: translateX(14px);
        }

        .slider.round {
          border-radius: 20px;
        }

        .slider.round:before {
          border-radius: 50%;
        }

        /* Remove ALL old layout styles */
        .points-and-progress, .nokia-visualizer, .horizontal-progress-bar-container, .horizontal-progress-bar,
        .indexing-info, .now-playing-info, .stats-info, .card-flipper, .card-front, .card-back, .card-footer, .now-next-container,
        .now-playing-card, .next-up-card, .reward-info, .progress-time, .top-stats, .bottom-stats {
            all: unset;
        }

        /* Bonus Glint Animation */
        .bonus-glint {
            color: #ffaa00;
            animation: glint 2s ease-in-out infinite;
        }

        @keyframes glint {
            0%, 100% { 
                opacity: 0.3; 
                color: #ffaa00;
            }
            50% { 
                opacity: 1; 
                color: #ffdd00;
                text-shadow: 0 0 4px #ffaa00;
            }
        }

        /* Smooth animation transitions */
        .indexing-window pre {
            transition: all 0.1s ease-out;
        }

        .session-stats-panel pre {
            transition: all 0.2s ease-out;
        }

        /* NEW: Styles for channel view to be flexible */
        #channels-view .popup-body {
            height: 100%;
        }

        .extension-popup {
            width: 700px;
            margin: 0 auto;
            background-color: #0d0d0d;
            border: none;
            border-radius: 12px;
            overflow: hidden;
            display: none;
            flex-direction: column;
            align-items: stretch;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            position: relative;
        }

        .popup-header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1100;
        }

        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            width: 100%;
            box-sizing: border-box;
        }

        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 20px;
            /* border: 2px solid #00ff41; */
            width: 100%;
            box-sizing: border-box;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        /* Expandable Sections */
        .expandable-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            background: #111111;
            border: 1px solid #333333;
            margin: 8px 0;
        }

        .expandable-section.expanded {
            max-height: 800px; /* Increased to accommodate comprehensive settings content */
        }

        .expandable-content {
            padding: 12px;
            font-size: 10px;
            line-height: 1.4;
        }

        .expandable-title {
            font-size: 11px;
            font-weight: 600;
            color: #00ff41;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Paused State Styles */
        .paused .points-total,
        .paused .points-pending,
        .paused .holistic-progress,
        .paused .animation-panel-content,
        .paused .nokia-visual,
        .paused .progress-bar-segment,
        .paused .horizontal-progress-bar-fill,
        .paused .holistic-show-info,
        .paused .holistic-section,
        .paused .holistic-panel,
        .paused #animation-panel-content,
        .paused #holistic-show-info,
        .paused #holistic-progress,
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .primary-cta,
        .paused .secondary-button,
        .paused .channel-switcher,
        .paused .expandable-section,
        .paused .expandable-content,
        .paused .leaderboard-section,
        .paused .leaderboard-header,
        .paused .queue-item,
        .paused .settings-section,
        .paused .settings-item,
        .paused .settings-label,
        .paused .settings-value,
        .paused .popup-header,
        .paused .popup-body,
        .paused .points-section,
        .paused .points-header,
        .paused .nokia-section,
        .paused .holistic-panel,
        .paused .holistic-section,
        .paused .holistic-show-info,
        .paused .holistic-animation,
        .paused .holistic-progress,
        .paused .detected-show-ui-indexing,
        .paused .expandable-channel-section-indexing,
        .paused .expand-channel-header-indexing,
        .paused .channel-iframe-container-indexing {
            color: #888 !important;
            opacity: 0.6;
        }

        /* Paused state for buttons - change border colors too */
        .paused .primary-cta,
        .paused .secondary-button {
            border-color: #666 !important;
            color: #888 !important;
            opacity: 0.6;
        }

        /* Stronger specificity for points display */
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .points-total,
        .paused .points-pending {
            color: #888 !important;
            opacity: 0.6 !important;
        }

        .paused .progress-bar-segment {
            background-color: #666 !important;
        }

        .paused .horizontal-progress-bar-fill {
            background: #666 !important;
        }

        .paused .nokia-visual {
            border-color: #666 !important;
            color: #666 !important;
        }

        .paused .animation-panel-content {
            animation-play-state: paused !important;
        }

        /* Pause indicator */
        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 10;
            display: none;
        }

        .paused .pause-indicator {
            display: block;
        }

        /* Activation step styles */
        .extension-popup.deactivated {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        .activation-circle {
            position: fixed;
            top: calc(50% - 350px); /* higher above the popup */
            left: 50%;
            transform: translate(-50%, 0);
            width: 56px;
            height: 56px;
            border: 4px solid #0066ff;
            border-radius: 50%;
            background: #fff; /* white background for contrast */
            cursor: pointer;
            z-index: 99999;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 0 0 4px rgba(0,102,255,0.08);
            transition: all 0.3s ease;
            display: none; /* Temporarily hidden for testing */
        }

        .activation-circle:hover {
            border-color: #0099ff;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.5);
        }

        .activation-circle.activated {
            background: #0066ff;
            border-color: #0066ff;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.8);
        }

        .activation-circle.activated::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Activation Circle (completely outside the popup) -->
    <div class="activation-circle" id="activation-circle" onclick="activateExtension()"></div>

    <!-- Debug Trigger -->
    <div class="debug-trigger" onclick="toggleDebugPanel()" title="Debug Panel (Ctrl+Shift+D)">
        Debug
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-panel-header" onclick="toggleDebugPanel()">
            <span>Rumi Debug</span>
            <button class="debug-panel-toggle" id="debug-panel-toggle">‚ñº</button>
        </div>
        
        <div class="debug-panel-content" id="debug-panel-content">
            <!-- Basic Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('basic-testing')">
                    <span>Basic Testing</span>
                    <button class="debug-section-toggle" id="basic-testing-toggle">‚ñº</button>
                </div>
                <div class="debug-section-content" id="basic-testing-content">
        <button class="debug-button" onclick="Tracker.showDebugOverlay()">Show Tracker</button>
        <!-- <button class="debug-button" onclick="testHomeScreen()">Test Home</button> -->
        <!-- <button class="debug-button" onclick="testChannels()">Test Channels</button> -->
        <!-- <button class="debug-button" onclick="testReceipt()">Test Receipt</button> -->
        <button class="debug-button" onclick="showState()">Show State</button>
        <!-- <button class="debug-button info" onclick="testShowDetection()">Test Show Detection</button> -->
        <!-- <button class="debug-button info" onclick="debugChannelState()">Debug Channel State</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelContent()">Check Genre Channel</button> -->
        <!-- <button class="debug-button info" onclick="testPlanetEarthDetection()">Test Planet Earth II</button> -->
        <!-- <button class="debug-button info" onclick="testMessagePassing()">Test Message Passing</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelLoaded()">Check Channel Loaded</button> -->
                </div>
            </div>

            <!-- Error Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('error-testing')">
                    <span>Error Testing</span>
                    <button class="debug-section-toggle" id="error-testing-toggle">‚ñº</button>
                </div>
                <div class="debug-section-content" id="error-testing-content">
                    <button class="debug-button warning" onclick="testVolumeError()">Volume Error</button>
                    <button class="debug-button warning" onclick="testSpeedError()">Speed Error</button>
                    <button class="debug-button warning" onclick="testLanguageError()">Language Error</button>
                    <button class="debug-button error" onclick="testSystemError()">System Error</button>
                    <button class="debug-button error" onclick="testNetworkError()">Network Error</button>
                    <button class="debug-button error" onclick="testBrowserError()">Browser Error</button>
                    <button class="debug-button blue" onclick="testShowInterrupt()">Show Interrupt</button>
                </div>
            </div>

            <!-- Session Management Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('session-management')">
                    <span>Session Management</span>
                    <button class="debug-section-toggle" id="session-management-toggle">‚ñº</button>
                </div>
                <div class="debug-section-content" id="session-management-content">
                                            <button class="debug-button info" id="debug-fast-mode-btn" onclick="toggleFastMode()">Fast Mode (10s)</button>
                    <button class="debug-button info" id="debug-skip-tomorrow-btn" onclick="debugSkipToTomorrow()">Skip to Tomorrow</button>
                    <button class="debug-button info" id="debug-content-tracking-btn" onclick="debugContentTracking()">Debug Content Tracking</button>
                    <button class="debug-button warning" onclick="testEndOfContentReceipt()">Test End-of-Content Receipt</button>
                    <button class="debug-button info" onclick="testDynamicTimelineScaling()">Test Dynamic Timeline Scaling</button>
                    <button class="debug-button warning" onclick="validateContentBlockSizing()">Validate Block Sizing</button>
                    <button class="debug-button warning" onclick="debugShowDetectionState()">Debug Show Detection</button>
                    <button class="debug-button warning" onclick="debugChannelContent()">Debug Channel Content</button>
                    <button class="debug-button danger" onclick="debugResetShowDetection()">Reset Show Detection</button>
                </div>
            </div>
        </div>
    </div>

    <div class="simulation-container">
        <div class="entry-point-panel">
            <div class="entry-point-header">SIMULATED ENTRY POINTS</div>
            <div id="stream-detector-entry" class="stream-detector">
                <!-- Content will be populated by JS -->
            </div>
            <button class="automode-button" onclick="launchWithAutomode()">
                Automode Campaign
            </button>
            <button id="user-changes-content-btn" class="secondary-button" onclick="simulateShowChange()" style="display: none; margin-top: 10px;">
                User Changes Content
            </button>
            <button id="cache-control-btn" class="secondary-button" onclick="toggleCacheControl()" style="margin-top: 10px; background: #1a1a1a; border-color: #666; color: #ccc;">
                üóÇÔ∏è Disable Cache
            </button>

    </div>

        <!-- Extension Popup (centered, always one header at top) -->
    <div class="extension-popup" style="display: none;">
        <div class="popup-header">
            <div class="popup-logo">RUMI</div>
            <div class="header-controls">
                <button class="settings-button" onclick="testSettings()">‚öô SETTINGS</button>
            </div>
        </div>
        <!-- Receipt View (Initially Hidden) -->
        <div id="receipt-view" style="display: none;">
            <div class="popup-body">
                <div style="background: #0d0d0d; border: 1px solid #333; border-radius: 12px; padding: 20px; max-width: 520px; margin: 0 auto; box-sizing: border-box; width: 100%;">
                    <div style="text-align: center; margin-bottom: 12px;">
                        <div style="font-size: 14px; color: #888; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span>SESSION COMPLETED for</span>
                            <span style="font-size: 24px; font-weight: 700; color: #ffff00;" id="receipt-total-points">+0.00</span>
                            <span>POINTS</span>
                        </div>
                        <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span id="receipt-total-pending" style="font-size: 13px; color: #ffaa00; font-weight: 600;"></span>
                            <span>PENDING FROM TODAY</span>
            </div>
        </div>

                        <!-- Session Details -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">SESSION DETAILS</div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Duration:</span>
                                <span style="color: #fff;" id="receipt-duration">0:00</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Multiplier:</span>
                                <span style="color: #fff;" id="receipt-multiplier">1.0x</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Base Rate:</span>
                                <span style="color: #fff;">0.5 pts/5s</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; font-size: 11px;">
                                <span style="color: #888;">Bonus Applied:</span>
                                <span style="color: #ffaa00;" id="receipt-bonus">None</span>
                            </div>
                        </div>

                        <!-- Indexed Content Summary -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">INDEXED CONTENT</div>
                            
                            <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Content detected and processed during this session:</div>
                            
                            <div id="receipt-content-list" style="font-size: 10px; max-height: 120px; overflow-y: auto;">
                                <!-- --- Indexed Content View: Show actual indexed content with 3 visible lines and auto-scroll (ping-pong) ---
                                if (appState.indexedContent && appState.indexedContent.length > 0) {
                                    const indexed = appState.indexedContent;
                                    // Generate HTML for all items
                                    const contentHTML = indexed.map(item => `
                                        <div class="indexed-content-item" style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #1a1a1a; border-radius: 3px; height: 24px; align-items: center;">
                                            <span style="color: #fff;">${item.title}</span>
                                            <span style="color: #888;">${item.duration}m</span>
                                </div>
                                    `).join('');
                                    contentList.innerHTML = `<div id="indexed-content-scroll" style="overflow: hidden; height: 76px; position: relative;">${contentHTML}</div>`;
                                    // Animate auto-scroll if more than 3 items
                                    if (indexed.length > 3) {
                                        setTimeout(() => {
                                            const scrollDiv = document.getElementById('indexed-content-scroll');
                                            let scrollPos = 0;
                                            let direction = 1;
                                            const itemHeight = 28; // px (24px + 4px margin)
                                            const maxScroll = (indexed.length * itemHeight) - (3 * itemHeight);
                                            function scrollStep() {
                                                scrollPos += direction;
                                                if (scrollPos >= maxScroll) {
                                                    scrollPos = maxScroll;
                                                    direction = -1;
                                                } else if (scrollPos <= 0) {
                                                    scrollPos = 0;
                                                    direction = 1;
                                                }
                                                scrollDiv.scrollTop = scrollPos;
                                                requestAnimationFrame(scrollStep);
                                            }
                                            scrollStep();
                                        }, 500);
                                    }
                                    // Return early so the rest of the function doesn't overwrite this view
                                    return;
                                } -->
                            </div>
                        </div>

                        <!-- Next Steps -->
                        <div style="background: #1a1000; border: 1px solid #ffaa00; border-radius: 6px; padding: 12px; margin-bottom: 20px;">
                            <div style="font-size: 12px; color: #ffaa00; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">NEXT STEPS</div>
                            <div style="font-size: 11px; color: #ccc; line-height: 1.4;">
                                Your points are now pending validation. They will be added to your total balance within 24 hours. Continue indexing to earn more points!
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 8px; margin-top: 16px;">
                            <button class="primary-cta" onclick="returnToEntryPoint()" style="flex: 1; background: #222; color: #ffff00; border: 2px solid #ffff00;">
                                DONE
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main View -->
        <div id="main-view">
            <!-- Message Area -->
            <div class="message-area collapsed">
                    <span id="message-summary-text">System operational - Daily bonus in 2h 34m</span>
                    <div id="error-details"></div>
                    <!-- Expandable Error Details Section -->
                    <div class="expandable-section" id="error-details-section">
                        <div class="expandable-content">
                            <div class="expandable-title">ERROR DETAILS</div>
                            <div id="error-details-content">
                                <!-- Error details will be populated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Expandable Warning Details Section -->
                    <div class="expandable-section" id="warning-details-section">
                        <div class="expandable-content" id="warning-details-content">
                            <!-- Warning details will be populated here -->
                        </div>
                    </div>
                    <!-- Expandable Settings Panel Section -->
                    <div class="expandable-section" id="settings-panel-section">
                        <div class="expandable-content">
                            <div class="expandable-title">SETTINGS CONFIGURATION</div>
                            <div id="settings-panel-content">
                                <!-- Settings content will be populated here -->
                            </div>
                        </div>
                    </div>
            </div>

            <!-- Points Section -->
            <div class="points-section">
                <div style="text-align: center; margin-bottom: 12px;">
                        <div id="points-primary-display" class="points-total">4349 LIFETIME POINTS</div>
                        <div id="points-secondary-display" class="points-pending">+200 pending from today</div>
                </div>
                
                <!-- Dynamic Content: Changes based on indexing state -->
                <div id="dynamic-content">
                        <!-- NEW HOME CONTENT (replaces channel iframe) -->
                        <div id="home-content">
                            <!-- Compact, Expandable Leaderboard -->
                            <div id="leaderboard-section" class="leaderboard-section" onclick="toggleLeaderboard()">
                                <div class="leaderboard-header">
                                    <div>
                                        <span class="title">WEEKLY LEADERS</span>
                                        <span class="user-rank">üî• YOU: #23</span>
                        </div>
                                    <span class="leaderboard-expand-icon">‚ñº</span>
                                </div>
                                <div class="leaderboard-full-list">
                                    <!-- Full leaderboard content from before -->
                                <div style="font-size: 9px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: #ffaa00;">ü•á CRYPTO_MAVEN</span>
                                        <span style="color: #ffaa00;">12,847</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: #888;">ü•à BINGE_LORD</span>
                                        <span style="color: #888;">11,203 (proj.)</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <span style="color: #888;">ü•â STORY_HUNTER</span>
                                        <span style="color: #888;">9,876</span>
                                    </div>
                                    <div style="border-top: 1px solid #333; padding-top: 3px;">
                                        <div style="display: flex; justify-content: space-between; background: rgba(0,255,65,0.1); padding: 2px 4px; border: 1px solid #00ff41;">
                                            <span style="color: #00ff41; font-weight: 600;">üî• YOU (#23)</span>
                                            <span style="color: #00ff41;">4,349 (4,549 proj.)</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                            <!-- Detected Show UI -->
                            <div id="detected-show-ui" style="display: none; margin-top: 12px; background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; border: 1px solid #00ff41;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">üéØ SHOW DETECTED</div>
                                        <div id="detected-show-title" style="font-size: 11px; font-weight: 600;">Loading...</div>
                                        <div id="detected-show-meta" style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">Processing...</div>
                                </div>
                                    <button onclick="dismissDetectedShow()" style="background: none; border: none; color: #000; font-size: 16px; cursor: pointer; padding: 4px; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">√ó</button>
                                        </div>
                                        </div>

                            <!-- CTA Button positioned above channel -->
                            <div style="margin-top: 12px;">
                                <button id="cta-button" class="primary-cta" onclick="toggleIndexing()">
                                    START WATCHING
                                </button>
                                    
                                    <!-- Expandable Channel Section -->
                                    <div id="expandable-channel-section" style="margin-top: 12px; display: none;">
                                        <div id="expand-channel-header" onclick="toggleChannelExpansion()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                            <span id="expand-channel-text" style="flex: none;">WATCH YOUR NEXT SHOW WITH US</span>
                                            <span id="expand-channel-icon" style="font-size: 16px; margin-left: 10px; flex: none;">‚ñº</span>
                                        </div>
                                        <!-- Channel Container (initially hidden) -->
                                        <div id="channel-expanded-container" style="display: none; margin-top: 4px;">
                                            <div id="channel-iframe-container" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                                <div id="channel-loading" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Channel...</div>
                                <iframe id="channel-frame" src="rumi-channel.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onload="console.log('Home channel frame loaded:', this.src); resizeIframe(this); initializeChannelTitle();" onerror="showChannelError()"></iframe>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    </div>

                    <!-- Top Section: Points and Progress (shown when indexing) -->
                    <div id="nokia-content" class="nokia-section" style="display: none; position: relative;">
                        <!-- Pause indicator -->
                        <div class="pause-indicator">‚è∏Ô∏è INDEXING PAUSED</div>
                        
                        <!-- NEW: Holistic Indexing Panel -->
                        <div id="holistic-indexing-panel" class="holistic-panel">
                            <div id="holistic-show-info" class="holistic-section"></div>
                            <div id="holistic-animation" class="holistic-section">
                            <pre id="animation-panel-content"></pre>
                        </div>
                            <div id="holistic-progress" class="holistic-section"></div>
                        </div>

                        <!-- STOP INDEXING Button positioned between holistic panel and channel -->
                        <div style="margin-top: 16px;">
                            <button id="stop-indexing-button" class="primary-cta" onclick="toggleIndexing()">
                                START INDEXING
                            </button>
                            <!-- Subtitle removed -->
                        </div>

                        <!-- Channel Section (replaces now-playing) -->
                        <div style="margin-top: 16px;">
                            <!-- Detected Show UI for Indexing View -->
                            <div id="detected-show-ui-indexing" style="display: none; margin-bottom: 12px; background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; border: 1px solid #00ff41;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">üéØ SHOW DETECTED</div>
                                        <div id="detected-show-title-indexing" style="font-size: 11px; font-weight: 600;">Loading...</div>
                                        <div id="detected-show-meta-indexing" style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">Processing...</div>
                                    </div>
                                    <button onclick="dismissDetectedShowIndexing()" style="background: none; border: none; color: #000; font-size: 16px; cursor: pointer; padding: 4px; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">√ó</button>
                                </div>
                            </div>
                                
                                <!-- Expandable Channel Section for Indexing View -->
                                <div id="expandable-channel-section-indexing" style="margin-top: 12px; display: none;">
                                    <div id="expand-channel-header-indexing" onclick="toggleChannelExpansionIndexing()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-channel-text-indexing" style="flex: none;">WATCH YOUR NEXT SHOW WITH US</span>
                                        <span id="expand-channel-icon-indexing" style="font-size: 16px; margin-left: 10px; flex: none;">‚ñº</span>
                                    </div>
                                    <!-- Channel Container (initially hidden) -->
                                    <div id="channel-expanded-container-indexing" style="display: none; margin-top: 4px;">
                                        <div id="channel-iframe-container-indexing" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="channel-loading-indexing" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Channel...</div>
                                            <iframe id="channel-frame-indexing" src="rumi-channel.html" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onload="console.log('Indexing channel frame loaded:', this.src); resizeIframeIndexing(this); initializeChannelTitleIndexing();" onerror="showChannelErrorIndexing()"></iframe>
                                        </div>
                                    </div>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>

        <!-- Settings View (Initially Hidden) -->
        <div id="settings-view" style="display: none;">
            <div class="popup-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="font-size: 16px;">SETTINGS</h2>
                </div>
                
                <!-- Account Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Account</h3>
                    <div class="settings-item">
                        <span class="settings-label">Username</span>
                        <span class="settings-value">CRYPTO_MAVEN</span>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Member Since</span>
                        <span class="settings-value">Dec 2023</span>
                    </div>
                    <button class="settings-logout-button">LOGOUT</button>
                </div>

                <!-- Preferences Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Preferences</h3>
                    <div class="settings-item">
                        <span class="settings-label">Desktop Notifications</span>
                        <label class="switch">
                            <input type="checkbox" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Auto-start Indexing</span>
                        <label class="switch">
                            <input type="checkbox">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error State Views -->
        <!-- (Removed: error-state panels are now handled in the message area) -->
    </div>


    <!-- Scripts -->
    <script src="tracker.js"></script>
    <!-- Optional: Transition System Enhancement (can be disabled) -->
    <script src="transition-system.js"></script>
    <script>
        // Debug: Check if tracker loaded
        console.log('Tracker loaded:', typeof Tracker !== 'undefined');
        console.log('RUMI_PROJECT loaded:', typeof RUMI_PROJECT !== 'undefined');

        // App State
        const appState = {
            pendingShowForGenreChannel: null, // Corrected syntax
            pendingEntryPoint: null, // NEW: Store pending entry point for activation
            pendingDetectedShow: null, // NEW: Store pending detected show for activation
            view: 'home',
            pointsEarned: 4349,
            totalPendingPoints: 200,
            sessionEarnings: 0,
            currentMultiplier: 1.0,
            currentContent: null,
            isIndexing: false,
            indexingStartTime: null,
            sortMode: 'points', // 'points' or 'channel'
            currentBucket: 'Rumi Internal Audiences', // NEW: To store the selected bucket
            // Error States
            errorState: null, // null, 'volume', 'connection', 'loading', 'offline'
            volumeLevel: 100,
            connectionStatus: 'connected', // 'connected', 'lost', 'offline'
            isLoading: false,
            // NEW: Automode content tracking
            automodeContentItems: [], // Array of content items for current session
            currentContentIndex: 0, // Index of current content item
            contentItemStartTime: 0, // When current content item started
            contentItemDuration: 0, // Duration of current content item in seconds
            contentTransitionProgress: 0, // Smooth transition between content items
            channelExpanded: false, // Add to appState
            userInitiatedChannelChange: false, // Track if channel change was user-initiated
            simResolved: false, // Prevents error re-trigger after SIM RESOLVE
            // NEW: Pause state tracking
            isPaused: false, // Whether indexing is currently paused
            pauseStartTime: null, // When the pause started
            pauseDuration: 0, // Total time paused in this session
            sessionEndReason: null, // 'normal', 'fatal_error', 'user_stop'
            // NEW: Debug button cooldowns
            debugSkipCooldown: 0, // Cooldown timer for skip to end button
            debugTomorrowCooldown: 0, // Cooldown timer for skip to tomorrow button
            // NEW: Session management
            userChoice: null, // 'rumi' or 'streamer' - user's choice for content control
            showChoicePrompt: false, // Whether to show the choice prompt
            sessionCompleted: false, // Whether the current session has been completed
            indexedContent: [], // Array to track actual content indexed during this session
            // NEW: Content tracking to prevent duplicates
            playedContent: new Set(), // Set of content IDs that have been played
            channelContent: new Map(), // Map of channel name -> Set of content IDs in that channel
            globalContentQueue: [], // Global queue across all channels
            contentHistory: [], // Array of recently played content for recommendations
            cachedSessionDuration: null, // Cache for session duration
            cachedSessionDurationTimestamp: null, // Timestamp for cache expiration
            showInterruptTimestamp: null, // Timestamp when show interrupt occurred
        };

        // NEW: Content tracking utility functions
        function generateContentId(content) {
            // Generate a unique ID for content based on title, type, and episode info
            let id = content.title || content.name || '';
            
            // Add episode information if available
            if (content.season && content.episode) {
                id += `-S${content.season}E${content.episode}`;
            } else if (content.episode) {
                id += `-E${content.episode}`;
            }
            
            // Add type if available
            if (content.type) {
                id += `-${content.type}`;
            }
            
            // Add service if available
            if (content.service) {
                id += `-${content.service}`;
            }
            
            return id.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        }

        function isContentPlayed(contentId) {
            return appState.playedContent.has(contentId);
        }

        function markContentAsPlayed(content) {
            const contentId = generateContentId(content);
            appState.playedContent.add(contentId);
            
            // Add to content history (keep last 50 items)
            appState.contentHistory.unshift({
                id: contentId,
                content: content,
                playedAt: Date.now()
            });
            if (appState.contentHistory.length > 50) {
                appState.contentHistory.pop();
            }
            
            Tracker.logRumiAction('Content marked as played', { contentId, title: content.title });
        }

        function isContentInChannel(contentId, channelName) {
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            return appState.channelContent.get(channelName).has(contentId);
        }

        function addContentToChannel(content, channelName) {
            const contentId = generateContentId(content);
            
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            
            appState.channelContent.get(channelName).add(contentId);
            Tracker.logRumiAction('Content added to channel', { contentId, channelName, title: content.title });
        }

        function removeContentFromChannel(contentId, channelName) {
            if (appState.channelContent.has(channelName)) {
                appState.channelContent.get(channelName).delete(contentId);
                Tracker.logRumiAction('Content removed from channel', { contentId, channelName });
            }
        }

        function addToGlobalQueue(content, channelName) {
            const contentId = generateContentId(content);
            
            // Check if content is already in global queue
            const existingIndex = appState.globalContentQueue.findIndex(item => generateContentId(item.content) === contentId);
            if (existingIndex !== -1) {
                return false; // Already in queue
            }
            
            appState.globalContentQueue.push({
                content: content,
                channelName: channelName,
                addedAt: Date.now(),
                contentId: contentId
            });
            
            Tracker.logRumiAction('Content added to global queue', { contentId, channelName, title: content.title });
            return true;
        }

        function removeFromGlobalQueue(contentId) {
            const index = appState.globalContentQueue.findIndex(item => item.contentId === contentId);
            if (index !== -1) {
                const removed = appState.globalContentQueue.splice(index, 1)[0];
                Tracker.logRumiAction('Content removed from global queue', { contentId, channelName: removed.channelName });
                return removed;
            }
            return null;
        }

        function getFilteredContentForChannel(contentList, channelName, excludeContentIds = new Set()) {
            // Filter out content that's already been played, is in the channel, or is in excludeContentIds
            return contentList.filter(content => {
                const contentId = generateContentId(content);
                return !isContentPlayed(contentId) && !isContentInChannel(contentId, channelName) && !excludeContentIds.has(contentId);
            });
        }

        function getContentRecommendations(excludePlayed = true, limit = 10) {
            // Get content recommendations based on history
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && (!excludePlayed || !isContentPlayed(contentId))) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        function clearContentTracking() {
            // Clear all content tracking (useful for testing or reset)
            appState.playedContent.clear();
            appState.channelContent.clear();
            appState.globalContentQueue = [];
            appState.contentHistory = [];
            Tracker.logRumiAction('Content tracking cleared');
        }

        // NEW: Debug function to test content tracking
        function debugContentTracking() {
            console.log('=== CONTENT TRACKING DEBUG ===');
            console.log('Played Content Count:', appState.playedContent.size);
            console.log('Played Content IDs:', Array.from(appState.playedContent));
            
            console.log('Channel Content:');
            appState.channelContent.forEach((contentSet, channelName) => {
                console.log(`  ${channelName}: ${contentSet.size} items`);
                console.log(`    IDs:`, Array.from(contentSet));
            });
            
            console.log('Global Queue Count:', appState.globalContentQueue.length);
            console.log('Global Queue Items:', appState.globalContentQueue.map(item => ({
                title: item.content.title,
                channelName: item.channelName,
                contentId: item.contentId
            })));
            
            console.log('Content History Count:', appState.contentHistory.length);
            console.log('Recent History:', appState.contentHistory.slice(0, 5).map(item => ({
                title: item.content.title,
                playedAt: new Date(item.playedAt).toLocaleTimeString()
            })));
            
            // Test content ID generation
            const testContent = {
                title: 'Test Show',
                season: 'S1',
                episode: 'E1',
                type: 'show',
                service: 'netflix'
            };
            console.log('Test Content ID:', generateContentId(testContent));
            
            // Test filtering
            const testContentList = [
                { title: 'Show 1', type: 'show' },
                { title: 'Show 2', type: 'movie' },
                { title: 'Show 3', type: 'show' }
            ];
            const filtered = getFilteredContentForChannel(testContentList, 'test-channel');
            console.log('Filtered Content for test-channel:', filtered.length, 'items');
            
            console.log('=== END CONTENT TRACKING DEBUG ===');
        }

        // NEW: Debug function to inspect show detection state
        function debugShowDetectionState() {
            console.log('=== SHOW DETECTION DEBUG STATE ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Is Indexing:', appState.isIndexing);
            console.log('Indexing Start Time:', appState.indexingStartTime);
            console.log('Detected Show:', appState.detectedShow);
            
            if (appState.isIndexing && appState.indexingStartTime) {
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                console.log('Elapsed Time:', elapsedTime.toFixed(2) + 's');
            }
            
            console.log('Content Items Count:', appState.automodeContentItems ? appState.automodeContentItems.length : 0);
            console.log('Current Content Index:', appState.currentContentIndex);
            console.log('Content Item Start Time:', appState.contentItemStartTime);
            console.log('Content Item Duration:', appState.contentItemDuration);
            
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                console.log('Current Content Item:', appState.automodeContentItems[appState.currentContentIndex]);
                if (appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                    console.log('Next Content Item:', appState.automodeContentItems[appState.currentContentIndex + 1]);
                }
            }
            
            // Show session duration info without causing overflow
            console.log('Cached Session Duration:', appState.cachedSessionDuration);
            console.log('Cache Timestamp:', appState.cachedSessionDurationTimestamp);
            if (appState.cachedSessionDurationTimestamp) {
                const cacheAge = Date.now() - appState.cachedSessionDurationTimestamp;
                console.log('Cache Age:', (cacheAge / 1000).toFixed(1) + 's');
            }
            console.log('Chained Session Duration:', appState.chainedSessionDuration);
            if (appState.detectedShow && appState.detectedShow.duration) {
                console.log('Detected Show Duration:', appState.detectedShow.duration + ' minutes');
            }
            console.log('Base Rate:', appState.baseRate);
            console.log('Current Multiplier:', appState.currentMultiplier);
            console.log('=== END SHOW DETECTION DEBUG ===');
        }

        // NEW: Debug function to inspect channel content
        function debugChannelContent() {
            console.log('=== CHANNEL CONTENT DEBUG ===');
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (channelFrame && channelFrame.contentWindow) {
                console.log('Channel frame found, requesting content...');
                try {
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                } catch (e) {
                    console.log('Error requesting channel content:', e.message);
                }
        } else {
                console.log('Channel frame not found or not accessible');
            }
            console.log('=== END CHANNEL CONTENT DEBUG ===');
        }

        // NEW: Debug function to reset show detection state
        function debugResetShowDetection() {
            console.log('=== RESETTING SHOW DETECTION STATE ===');
            appState.automodeContentItems = [];
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = 0;
            appState.contentTransitionProgress = 0;
            console.log('Show detection state reset');
            console.log('=== END RESET ===');
        }

        // NEW: Function to clear session duration cache
        function clearSessionDurationCache() {
            appState.cachedSessionDuration = null;
            appState.cachedSessionDurationTimestamp = null;
            console.log('Session duration cache cleared');
        }

        // NEW: Channel integration functions
        function integrateContentTrackingWithChannels() {
            // Send content tracking data to all loaded channels
            const channelFrames = [
                document.getElementById('channel-frame'),
                document.getElementById('channel-frame-indexing')
            ];
            
            channelFrames.forEach(frame => {
                if (frame && frame.contentWindow) {
                    try {
                        // Send played content data to channel
                        frame.contentWindow.postMessage({
                            type: 'contentTracking',
                            playedContent: Array.from(appState.playedContent),
                            channelContent: Object.fromEntries(appState.channelContent),
                            globalQueue: appState.globalContentQueue
                        }, '*');
                    } catch (e) {
                        console.log('Could not send content tracking to channel:', e.message);
                    }
                }
            });
        }

        function handleChannelContentAdded(content, channelName) {
            // Called when content is added to a channel
            addContentToChannel(content, channelName);
            
            // Also add to global queue if not already there
            addToGlobalQueue(content, channelName);
            
            Tracker.logRumiAction('Content added to channel from tracking', { 
                contentId: generateContentId(content), 
                channelName, 
                title: content.title 
            });
        }

        function handleChannelContentPlayed(content, channelName) {
            // Called when content is played from a channel
            markContentAsPlayed(content);
            
            // Remove from channel content (since it's now played)
            const contentId = generateContentId(content);
            removeContentFromChannel(contentId, channelName);
            
            // Remove from global queue
            removeFromGlobalQueue(contentId);
            
            Tracker.logRumiAction('Content played from channel', { 
                contentId, 
                channelName, 
                title: content.title 
            });
        }

        // NEW: Function to get filtered content for channels
        function getChannelContentRecommendations(channelName, limit = 10) {
            // Get content recommendations that haven't been played and aren't in this channel
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && 
                    !isContentPlayed(contentId) && 
                    !isContentInChannel(contentId, channelName)) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        // NEW: Function to export content tracking data
        function exportContentTrackingData() {
            return {
                playedContent: Array.from(appState.playedContent),
                channelContent: Object.fromEntries(appState.channelContent),
                globalQueue: appState.globalContentQueue,
                contentHistory: appState.contentHistory.map(item => ({
                    id: item.id,
                    title: item.content.title,
                    playedAt: item.playedAt
                }))
            };
        }

        // NEW: Function to import content tracking data
        function importContentTrackingData(data) {
            if (data.playedContent) {
                appState.playedContent = new Set(data.playedContent);
            }
            if (data.channelContent) {
                appState.channelContent = new Map(Object.entries(data.channelContent).map(([key, value]) => [key, new Set(value)]));
            }
            if (data.globalQueue) {
                appState.globalContentQueue = data.globalQueue;
            }
            if (data.contentHistory) {
                appState.contentHistory = data.contentHistory;
            }
            
            Tracker.logRumiAction('Content tracking data imported', { 
                playedCount: appState.playedContent.size,
                channelCount: appState.channelContent.size,
                queueCount: appState.globalContentQueue.length
            });
        }

        // Initialize app
        function initApp() {
            // If we have already launched from an entry point, don't re-initialize.
            if (appState.entryPoint) {
                return;
            }

            console.log('Initializing app...');
            
            if (typeof Tracker === 'undefined') {
                console.error('Tracker not loaded!');
                return;
            }

            Tracker.startFlow(RUMI_PROJECT.flows.HOME_SCREEN);
            Tracker.logRumiAction('App initialized');
            Tracker.logRumiState(appState);
            
            // Initialize UI based on current state
            updateUI();
            updatePointsDisplay();
            
            // Test home screen checkpoints
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.HOME_LOADED, true, 'Home screen loaded');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.POINTS_DISPLAYED, true, 'Points displayed correctly');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.CTA_POSITIONED, true, 'CTA positioned correctly');
            
            Tracker.endFlow();
            console.log('App initialized successfully');

            // Start error monitoring
            monitorVolume();
            // monitorConnection(); // Disabled - was causing false connection errors during indexing
        }

        // Toggle indexing state
        function toggleIndexing() {
            if (appState.isIndexing) {
                stopIndexing();
            } else {
                // Always use enhanced transition system version for detection mode
                if (appState.entryPoint === 'detection') {
                    startIndexingWithTransitionSystem();
                } else {
                    // Use regular start for other modes
                startIndexing();
                }
            }
        }

        // Start indexing
       function startIndexing() {
            // If session is already running, do nothing.
            if (appState.indexingStartTime) return;

            // Ensure state and view are correct, even if called directly.
            if (!appState.isIndexing) {
                appState.isIndexing = true;
                updateUI();
            }

            // Reset session state
            appState.sessionEndReason = null;
            appState.isPaused = false;
            appState.pauseStartTime = null;
            appState.pauseDuration = 0;
            appState.sessionCompleted = false; // Reset session completion flag
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for new session

            // Set base rate for this session
            appState.baseRate = (appState.entryPoint === 'automode') ? 0.25 : 0.1;
            appState.indexingStartTime = Date.now();
            appState.sessionEarnings = 0;

            // Initialize automode content tracking
            if (appState.entryPoint === 'automode') {
                // Generate content items for the session (30 minutes = 1800 seconds)
                appState.automodeContentItems = getAutomodeContent(appState.currentBucket, 1800, appState.baseRate, appState.currentMultiplier);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // Calculate duration for first content item
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                    console.log(`Initial setup - First item: ${firstItem.title}, duration string: "${firstItem.duration}"`);
                    // Parse duration string (e.g., "1:23") to seconds
                    const durationParts = firstItem.duration.split(':');
                    console.log(`Initial setup - Duration parts:`, durationParts);
                    appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    console.log(`Initial setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                }
            } else if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // Initialize content items for show detection mode
                const sessionDuration = calculateSessionDuration();
                appState.automodeContentItems = getShowDetectionContent(appState.detectedShow, sessionDuration);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // Calculate duration for first content item if we have content
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                    console.log(`Show detection setup - First item: ${firstItem.title}, duration: ${firstItem.duration}`);
                    
                    // Handle both duration strings and numeric durations
                    if (typeof firstItem.duration === 'string' && firstItem.duration.includes(':')) {
                        // Parse duration string (e.g., "0:45") to seconds
                        const durationParts = firstItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        console.log(`Show detection setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                    } else {
                        // Use duration as-is (already in seconds)
                        appState.contentItemDuration = firstItem.duration;
                        console.log(`Show detection setup - Using duration as-is: ${appState.contentItemDuration} seconds`);
                    }
                } else {
                    // No content yet - will be populated when channel responds
                    console.log('Show detection setup - No content items yet, waiting for channel response');
                    // Set a default duration until content arrives
                    appState.contentItemDuration = 45 * 60; // 45 minutes default
                }
            }

            // Always initialize transition system for detection mode
            if (appState.entryPoint === 'detection') {
                if (!window.transitionSystem) {
                    console.log('Initializing transition system for detection mode...');
                    initializeTransitionSystem();
                } else {
                    console.log('Transition system already available for detection mode');
                }
                
                // Initialize with current detected show if available
                if (appState.detectedShow) {
                    setTimeout(() => {
                        updateButtonWithCurrentShow(appState.detectedShow);
                        // Don't trigger content display update immediately - let the channel keep its existing content
                        // triggerContentDisplayUpdate('session_start'); // Removed to prevent content clearing
                    }, 100);
                }
            }

            // Start animation loop
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animateSessionStats();
            
            Tracker.logRumiAction('Indexing session activated');
            updatePointsDisplay(); // Switch to session view in points panel
            appState.simResolved = false;
            updateDebugButtonStates(); // Update debug button states when indexing starts
        }
// Helper to record actual indexed content before showing receipt
function recordActualIndexedContentBeforeReceipt() {
    try {
        // If already populated, do nothing
        if (appState.indexedContent && appState.indexedContent.length > 0) return;

        // Only proceed if in detection mode and a show is detected
        if (appState.entryPoint !== 'detection') return;
        if (!appState.detectedShow || !appState.detectedShow.title) {
            console.warn('No detectedShow available for indexed content recording.');
            return;
        }
        const sessionDuration = calculateSessionDuration();
        const sessionDurationMinutes = Math.floor(sessionDuration / 60);
        const totalElapsedTime = Math.floor((Date.now() - appState.indexingStartTime) / 60000);
        const actualDuration = Math.min(sessionDurationMinutes, totalElapsedTime);

        if (appState.originalShow && appState.interruptNewShow) {
            // If there was a show transition, split time using interrupt timestamp if available
            let originalShowTime, chainedShowTime;
            if (appState.showInterruptTimestamp) {
                const interruptTimeMinutes = Math.floor((appState.showInterruptTimestamp - appState.indexingStartTime) / 60000);
                originalShowTime = Math.min(interruptTimeMinutes, actualDuration);
                chainedShowTime = Math.max(0, actualDuration - originalShowTime);
            } else {
                const interruptTime = Math.floor(actualDuration * 0.75);
                originalShowTime = interruptTime;
                chainedShowTime = actualDuration - interruptTime;
            }
            // Record original show
            const originalShowItem = {
                title: `${appState.originalShow.title} ${appState.originalShow.season !== 'N/A' ? `S${appState.originalShow.season} E${appState.originalShow.episode}` : '(Film)'}`,
                duration: originalShowTime,
                type: 'detected_show',
                points: Math.round((originalShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(originalShowItem);
            // Record chained show
            const chainedShowItem = {
                title: `${appState.interruptNewShow.title} ${appState.interruptNewShow.season !== 'N/A' ? `S${appState.interruptNewShow.season} E${appState.interruptNewShow.episode}` : '(Film)'} (Chained)`,
                duration: chainedShowTime,
                type: 'chained_show',
                points: Math.round((chainedShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(chainedShowItem);
            markContentAsPlayed(originalShowItem);
            markContentAsPlayed(chainedShowItem);
            console.log('Indexed content recorded (transition):', appState.indexedContent);
        } else {
            // No show transition - just record the current show
            const indexedContentItem = {
                title: `${appState.detectedShow.title} ${appState.detectedShow.season !== 'N/A' ? `S${appState.detectedShow.season} E${appState.detectedShow.episode}` : '(Film)'}`,
                duration: actualDuration,
                type: 'detected_show',
                points: Math.round((actualDuration * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(indexedContentItem);
            markContentAsPlayed(indexedContentItem);
            console.log('Indexed content recorded:', appState.indexedContent);
        }
    } catch (e) {
        console.error('Error in recordActualIndexedContentBeforeReceipt:', e);
    }
}
        function stopIndexing() {
            if (!appState.isIndexing) {
                return;
            }
            // Only record indexed content for detection mode
            if (appState.entryPoint === 'detection') {
                recordActualIndexedContentBeforeReceipt();
            }
            // Record automode indexed content
            if (appState.entryPoint === 'automode') {
                // Only include items that were actually shown (up to currentContentIndex)
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    appState.indexedContent = appState.automodeContentItems
                        .slice(0, appState.currentContentIndex + 1)
                        .map(item => ({
                            title: item.title,
                            duration: 1, // Each item represents ~1 minute of content
                            points: (appState.baseRate || 0.25) * (appState.currentMultiplier || 1.0) * 60, // 1 minute worth of points
                            type: 'automode'
                        }));
                }
            }
            appState.isIndexing = false;
            appState.totalPendingPoints += appState.sessionEarnings;
            
            // Set session end reason
            appState.sessionEndReason = 'user_stop';
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Calculate any remaining real-time points before showing the receipt
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.sessionEarnings = (appState.baseRate || 0.1) * appState.currentMultiplier * elapsedTime;
            // Calculate session data and show receipt
            const sessionDuration = Math.floor(elapsedTime);
            const finalMultiplier = appState.currentMultiplier;
            showReceiptView(appState.sessionEarnings, sessionDuration, finalMultiplier);

            // Reset session state
            appState.indexingStartTime = null;
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for next session
            
            Tracker.logRumiAction('Indexing stopped');
            updatePointsDisplay();
            updateDebugButtonStates(); // Update debug button states when indexing stops
        }

        // Show receipt view with session results
        function showReceiptView(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt view shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint,
                sessionEndReason: appState.sessionEndReason
            });
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Check if transition system has data and use it
            let receiptData = {
                totalPoints: sessionEarnings,
                totalPending: appState.totalPendingPoints + sessionEarnings,
                duration: sessionDuration,
                multiplier: finalMultiplier,
                numberOfShows: 1,
                playedContent: []
            };
            
            // Use transition system data if available
            if (window.transitionSystem && window.transitionSystem.getSessionData) {
                const transitionData = window.transitionSystem.getSessionData();
                if (transitionData.totalPoints > 0) {
                    receiptData = {
                        totalPoints: transitionData.totalPoints,
                        totalPending: appState.totalPendingPoints + transitionData.totalPoints,
                        duration: transitionData.totalTimeIndexed * 60, // Convert to seconds
                        multiplier: finalMultiplier,
                        numberOfShows: transitionData.numberOfShows,
                        playedContent: window.transitionSystem.state.playedContent || []
                    };
                }
            }
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${receiptData.totalPoints.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${receiptData.totalPending.toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(receiptData.duration);
            document.getElementById('receipt-multiplier').textContent = `${receiptData.multiplier.toFixed(1)}x`;
            
            // Enhanced bonus text based on transition system data
            const bonusElement = document.getElementById('receipt-bonus');
            if (receiptData.numberOfShows > 2) {
                bonusElement.textContent = `Multi-Show Bonus (${receiptData.numberOfShows} shows)`;
                bonusElement.style.color = '#ffaa00';
            } else if (appState.interruptNewShow && finalMultiplier >= 1.1) {
                bonusElement.textContent = 'Chained Content Bonus';
                bonusElement.style.color = '#ffaa00';
            } else if (finalMultiplier >= 1.2) {
                bonusElement.textContent = 'Time Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Set the correct base rate in the receipt
            const baseRateValue = appState.entryPoint === 'automode' ? '0.25 pts/s' : '0.1 pts/s';
            const baseRateSpans = document.querySelectorAll('#receipt-view span[style*="color: #fff"]');
            baseRateSpans.forEach(span => {
                if (span.textContent.includes('pts/')) {
                    span.textContent = baseRateValue;
                }
            });
            
            // Generate enhanced content list
            generateEnhancedReceiptContentList(receiptData);
            
            appState.view = 'receipt';
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // NEW: Enhanced receipt content list with transition system data
        function generateEnhancedReceiptContentList(receiptData) {
            const contentList = document.getElementById('receipt-content-list');
            const contentItems = [];
            
            // Use transition system content if available
            if (receiptData.playedContent && receiptData.playedContent.length > 0) {
                receiptData.playedContent.forEach((content, index) => {
                    const pointsEarned = (content.duration * 60 * 0.1 * receiptData.multiplier);
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration} min`,
                        points: pointsEarned.toFixed(1),
                        isTransition: index > 0,
                        service: content.service || 'Unknown'
                    });
                });
            } else {
                // Fallback to original content generation
                generateReceiptContentList(receiptData.duration, appState.entryPoint, appState.sessionEndReason);
                return;
            }
            
            // Generate HTML for enhanced content items
            const contentHTML = contentItems.map((item, index) => `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 6px; background: ${item.isTransition ? '#1a1a00' : '#1a1a1a'}; border-radius: 4px; border: ${item.isTransition ? '1px solid #ffaa00' : 'none'};">
                    <div style="flex: 1;">
                        <div style="color: ${item.isTransition ? '#ffaa00' : '#fff'}; font-size: 11px; font-weight: 600;">${item.title}</div>
                        <div style="color: #888; font-size: 9px; margin-top: 2px;">${item.service}${item.isTransition ? ' ‚Ä¢ Transition Bonus' : ''}</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                        <span style="color: #888; font-size: 10px;">${item.duration}</span>
                        <span style="color: ${item.isTransition ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points}</span>
                    </div>
                </div>
            `).join('');
            
            // Add session summary at the top
            const summaryHTML = `
                <div style="background: #0a0a0a; border: 1px solid #333; border-radius: 6px; padding: 8px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="color: #fff; font-size: 12px; font-weight: 600;">Session Summary</div>
                        <div style="color: #ffaa00; font-size: 11px;">${receiptData.numberOfShows} show${receiptData.numberOfShows > 1 ? 's' : ''}</div>
                    </div>
                    <div style="color: #888; font-size: 10px; margin-top: 4px;">
                        ${Math.floor(receiptData.duration / 60)} minutes ‚Ä¢ ${receiptData.multiplier.toFixed(1)}x multiplier ‚Ä¢ +${receiptData.totalPoints.toFixed(2)} points
                    </div>
                </div>
            `;
            
            contentList.innerHTML = summaryHTML + contentHTML;
            
            // Handle scrolling for many items
            if (contentItems.length > 3) {
                contentList.style.maxHeight = '160px';
                contentList.style.overflowY = 'auto';
            } else {
                contentList.style.maxHeight = 'none';
                contentList.style.overflowY = 'visible';
            }
        }

        // Generate content list for receipt based on session duration and mode
        function generateReceiptContentList(sessionDuration, mode, sessionEndReason) {
            const contentList = document.getElementById('receipt-content-list');
            const contentItems = [];
            
            // Calculate base rate and multiplier for points calculation
            const baseRate = appState.entryPoint === 'automode' ? 0.25 : 0.1; // points per second
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Add session end reason if it was a fatal error
            if (sessionEndReason === 'fatal_error') {
                contentItems.push({
                    title: 'Session ended by terminal error',
                    duration: '--',
                    points: '--',
                    isError: true
                });
            }
            
            // Use actual indexed content if available
            if (appState.indexedContent && appState.indexedContent.length > 0) {
                appState.indexedContent.forEach(content => {
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration} min`,
                        points: content.points.toFixed(1),
                        isChained: content.type === 'chained' || content.title.includes('(Chained)')
                    });
                });
            } else if (mode === 'detection' || mode === 'showDetection') {
                // Fallback: Show detection mode: show the detected show and related content
                if (appState.detectedShow) {
                    // Use original show if available (for chained content), otherwise use current detected show
                    const show = appState.originalShow || appState.detectedShow;
                    
                    // Use dynamic session duration instead of hardcoded 45 minutes
                    const sessionDurationMinutes = Math.floor(calculateSessionDuration() / 60);
                    const showTime = Math.min(sessionDuration, sessionDurationMinutes); // Use calculated duration
                    const showTimeSeconds = showTime * 60; // Convert to seconds
                    const showPoints = Math.round((showTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                    
                    contentItems.push({
                        title: `${show.title} ${show.season !== 'N/A' ? `S${show.season} E${show.episode}` : '(Film)'}`,
                        duration: formatTime(showTime),
                        points: showPoints.toFixed(1)
                    });
                    
                    // Add related content based on genre
                    const remainingTime = sessionDuration - showTime;
                    if (remainingTime > 0) {
                        // Check if there was a show interrupt and add the chained content
                        if (appState.interruptNewShow) {
                            const chainedShow = appState.interruptNewShow;
                            const chainedTime = Math.min(remainingTime, 30); // Assume 30 min for chained content
                            if (chainedTime > 0) {
                                const chainedTimeSeconds = chainedTime * 60;
                                const chainedPoints = Math.round((chainedTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                                
                                contentItems.push({
                                    title: `${chainedShow.title} ${chainedShow.season !== 'N/A' ? `S${chainedShow.season} E${chainedShow.episode}` : '(Film)'} (Chained)`,
                                    duration: formatTime(chainedTime),
                                    points: chainedPoints.toFixed(1),
                                    isChained: true
                                });
                                
                                // Add related content for the chained show if there's remaining time
                                const finalRemainingTime = remainingTime - chainedTime;
                                if (finalRemainingTime > 0) {
                                    const relatedContent = getRelatedContentWithPoints(chainedShow.genre, finalRemainingTime, baseRate, finalMultiplier);
                                    contentItems.push(...relatedContent);
                                }
                            }
                        } else {
                            const relatedContent = getRelatedContentWithPoints(show.genre, remainingTime, baseRate, finalMultiplier);
                            contentItems.push(...relatedContent);
                        }
                    }
                }
            } else if (mode === 'automode') {
                // Automode: show content from the current bucket
                const bucketContent = getAutomodeContentWithPoints(appState.currentBucket, sessionDuration, baseRate, finalMultiplier);
                contentItems.push(...bucketContent);
            } else {
                // Fallback: generic content
                const genericContent = getGenericContentWithPoints(sessionDuration, baseRate, finalMultiplier);
                contentItems.push(...genericContent);
            }
            
            // Generate HTML for content items with points
            const contentHTML = contentItems.map(item => `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: ${item.isError ? '#1a0000' : item.isChained ? '#1a1a00' : '#1a1a1a'}; border-radius: 3px; border: ${item.isError ? '1px solid #ff4444' : item.isChained ? '1px solid #ffaa00' : 'none'};">
                    <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'};">${item.title}</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #888;">${item.duration}</span>
                        <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points} pts</span>
                    </div>
                </div>
            `).join('');
            
            contentList.innerHTML = contentHTML;
            
            // Handle display based on number of items
            if (contentItems.length <= 3) {
                // For 3 or fewer items: show all items without scrolling
                contentList.style.maxHeight = 'none';
                contentList.style.overflowY = 'visible';
                contentList.style.height = 'auto';
            } else {
                // For more than 3 items: create movie credits style auto-scroll
                const itemHeight = 32; // Height per item (28px + 4px margin)
                const visibleHeight = itemHeight * 3; // Show exactly 3 items
                
                contentList.style.height = `${visibleHeight}px`;
                contentList.style.maxHeight = `${visibleHeight}px`;
                contentList.style.overflowY = 'hidden'; // Hide scrollbar for smooth effect
                contentList.style.position = 'relative';
                
                // Create movie credits auto-scroll effect
                setTimeout(() => {
                    let scrollPosition = 0;
                    const maxScroll = (contentItems.length - 3) * itemHeight;
                    const scrollSpeed = 0.5; // pixels per frame (adjust for speed)
                    const pauseAtTop = 1000; // ms to pause at top
                    const pauseAtBottom = 2000; // ms to pause at bottom
                    
                    let isPaused = false;
                    let pauseTimer = 0;
                    let direction = 1; // 1 for down, -1 for up
                    
                    function movieCreditsScroll() {
                        if (isPaused) {
                            pauseTimer -= 16; // ~60fps
                            if (pauseTimer <= 0) {
                                isPaused = false;
                            }
                        } else {
                            scrollPosition += (scrollSpeed * direction);
                            
                            // Check boundaries and handle pauses
                            if (scrollPosition >= maxScroll && direction === 1) {
                                scrollPosition = maxScroll;
                                direction = -1;
                                isPaused = true;
                                pauseTimer = pauseAtBottom;
                            } else if (scrollPosition <= 0 && direction === -1) {
                                scrollPosition = 0;
                                direction = 1;
                                isPaused = true;
                                pauseTimer = pauseAtTop;
                            }
                            
                            contentList.scrollTop = scrollPosition;
                        }
                        
                        // Continue animation
                        requestAnimationFrame(movieCreditsScroll);
                    }
                    
                    // Start with a pause at the top
                    isPaused = true;
                    pauseTimer = pauseAtTop;
                    movieCreditsScroll();
                }, 1000); // Start after 1 second delay
                
                // Add subtle indicator that there's more content
                const moreContentIndicator = document.createElement('div');
                moreContentIndicator.style.cssText = `
                    font-size: 8px; 
                    color: #444; 
                    text-align: center; 
                    padding: 2px; 
                    font-style: italic;
                    position: absolute;
                    bottom: -16px;
                    left: 0;
                    right: 0;
                `;
                moreContentIndicator.textContent = `${contentItems.length} items ‚Ä¢ Auto-scrolling`;
                contentList.style.position = 'relative';
                contentList.parentNode.style.position = 'relative';
                contentList.parentNode.appendChild(moreContentIndicator);
            }
        }

        // Show main view (from settings only now)
        function showMainView() {
            Tracker.logRumiAction('Main view shown');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="showSettingsView()">‚öô SETTINGS</button>';
            // }
            
            // Hide settings view and show settings view
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'none';
            
            // Reset entry point state to return to home screen
            appState.entryPoint = null;
            appState.detectedShow = null;
            
            // Update UI based on current state
            updateUI();
            updatePointsDisplay();
        }

        // Update UI based on current state
        function updateUI() {
            const ctaButton = document.getElementById('cta-button');
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            const stopIndexingButton = document.getElementById('stop-indexing-button');
            const stopIndexingSubtitle = stopIndexingButton ? stopIndexingButton.nextElementSibling : null;
            const mainView = document.getElementById('main-view');
            
            // Add/remove automode class based on entry point
            if (mainView) {
                if (appState.entryPoint === 'automode') {
                    mainView.classList.add('automode');
                } else {
                    mainView.classList.remove('automode');
                }
            }

            if (appState.isIndexing) {
                // Show stop button and indexing content
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `STOP LEARNING ABOUT "${bucketName}"`;
                } else {
                ctaButton.textContent = 'STOP INDEXING';
                }
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'none';
                if(nokiaContent) nokiaContent.style.display = 'block';
                
                // Update indexing screen button
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `STOP LEARNING ABOUT "${bucketName}"`;
                    } else {
                    stopIndexingButton.textContent = 'STOP INDEXING';
                }
                    stopIndexingButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                }
            } else if (appState.entryPoint) {
                // Show indexing screen but with START INDEXING button (idle state)
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `START WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `HELP RUMI LEARN ABOUT "${bucketName}"`;
                } else {
                ctaButton.textContent = 'START INDEXING';
                }
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                // Show home content (leaderboard) when not indexing yet
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
                
                // Update indexing screen button (this will be shown when indexing starts)
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `START WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `HELP RUMI LEARN ABOUT "${bucketName}"`;
                    } else {
                    stopIndexingButton.textContent = 'START INDEXING';
                    }
                    stopIndexingButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                }
            } else {
                // Show start button and home content (leaderboard/queue)
                ctaButton.textContent = 'START WATCHING';
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
            }
            updateDebugButtonStates(); // Update debug button states when UI changes
        }

        // Indexing timer for status panel
        let pointAccrualInterval;
        let indexingTimerInterval;
        let animationFrameId;
        
        // Point accrual and timer logic
        function startPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            appState.sessionStartTime = Date.now();
            appState.sessionEarnings = 0;
            appState.currentMultiplier = 1.0;
            
            // Start the animation loop
            animateSessionStats();

            // Set different base rates based on entry point
            let baseRate;
            let interval;
            
            if (appState.entryPoint === 'automode') {
                baseRate = 0.25; // 0.25 points per second for automode
                interval = 1000; // Update every second
            } else {
                baseRate = 0.1; // 0.1 points per second for show detection
                interval = 1000; // Update every second
            }

            pointAccrualInterval = setInterval(() => {
                const pointsThisInterval = baseRate * appState.currentMultiplier;
                appState.sessionEarnings += pointsThisInterval;
                Tracker.logRumiAction('Points accrued in session', {
                    amount: pointsThisInterval,
                    sessionTotal: appState.sessionEarnings,
                    baseRate: baseRate,
                    mode: appState.entryPoint
                });
                
                // Update the points display in real-time
                updatePointsDisplay();
                // Also update the holistic-progress counter in real-time
                updateAnimationPanel((Date.now() - appState.indexingStartTime) / 1000);
            }, interval);
        }

        function stopPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        }

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Enhanced Nokia animation with show indexing integration
        let currentIndexingShow = null;
        let animationUpdateInterval = null;
        let lastShowUpdate = 0;
        let lastUpdateTime = 0;

        const getTonalCharacter = (originalChar, revealProgress) => {
            if (originalChar === '#') {
                if (revealProgress > 0.85) return '#';
                if (revealProgress > 0.7) return 'X';
                if (revealProgress > 0.55) return 'O';
                if (revealProgress > 0.4) return 'o';
                return '.';
            }
            if (originalChar === '=' || originalChar === '|' || originalChar === '+' || originalChar === '/' || originalChar === '~' || originalChar === '<' || originalChar === '>' || originalChar === ':' || originalChar === '{' || originalChar === '}' || originalChar === '[' || originalChar === ']' || originalChar === '^' || originalChar === 'v' || originalChar === 'W' || originalChar === '8' || originalChar === '@' || originalChar === '0' || originalChar === '%' || originalChar === '&' || originalChar === '$') {
                 if (revealProgress > 0.8) return 'X';
                if (revealProgress > 0.65) return 'O';
                if (revealProgress > 0.5) return 'o';
                if (revealProgress > 0.35) return '.';
                return '.';
            }
            return originalChar;
        };

        function renderReveal(template, progress, width, height) {
            let display = Array(height).fill('.'.repeat(width));
            if (!template) return display;

            const allTemplateChars = [];
            for (let y = 0; y < height; y++) {
                const row = template[y] || '';
                for (let x = 0; x < width; x++) {
                    if (row[x] && row[x] !== ' ') {
                        allTemplateChars.push({ char: row[x], x, y });
                    }
                }
            }
            allTemplateChars.sort((a, b) => a.y - b.y || a.x - b.x);

            const totalPixels = allTemplateChars.length;
            const pixelsToShow = Math.floor(totalPixels * progress);
            
            for (let i = 0; i < pixelsToShow; i++) {
                const { char, x, y } = allTemplateChars[i];
                const pixelProgress = pixelsToShow > 1 ? (i / (pixelsToShow - 1)) : 1;
                let rowArray = display[y].split('');
                rowArray[x] = getTonalCharacter(char, pixelProgress);
                display[y] = rowArray.join('');
            }
            return display;
        }

        function renderCrossfade(oldTemplate, newTemplate, progress, width, height) {
            // Add null checks to prevent TypeError
            if (!oldTemplate || !newTemplate || !Array.isArray(oldTemplate) || !Array.isArray(newTemplate)) {
                return Array(height).fill('.'.repeat(width));
            }
            
            let display = Array(height).fill('.'.repeat(width));
            for (let y = 0; y < height; y++) {
                let rowArray = display[y].split('');
                for (let x = 0; x < width; x++) {
                    const oldChar = oldTemplate[y]?.[x] || ' ';
                    const newChar = newTemplate[y]?.[x] || ' ';
                    
                    const oldCharRender = (oldChar !== ' ' && oldChar !== '.') ? getTonalCharacter(oldChar, 1 - progress) : '.';
                    const newCharRender = (newChar !== ' ' && newChar !== '.') ? getTonalCharacter(newChar, progress) : '.';
                    
                    rowArray[x] = (newCharRender !== '.') ? newCharRender : oldCharRender;
                }
                display[y] = rowArray.join('');
            }
            return display;
        }

        function updateAnimationPanel(elapsedTime) {
            const holisticInfo = document.getElementById('holistic-show-info');
            const panel = document.getElementById('animation-panel-content');
            const holisticProgress = document.getElementById('holistic-progress');

            if (!panel || !holisticInfo || !holisticProgress) return;
            
            // Apply automode styling if no show is detected
            if (detectedShow) {
                panel.classList.remove('automode');
            } else {
                panel.classList.add('automode');
            }
            
            const width = 28;
            const height = 6;
            
            const detectedShowUI = document.getElementById('detected-show-ui-indexing');
            let showTitle = 'INDEXING';
            let showType = 'data';
            let showDetails = `Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;

            if (detectedShowUI && detectedShowUI.style.display !== 'none' && detectedShow && detectedShow.title) {
                showTitle = detectedShow.title.toUpperCase();
                showType = detectedShow.genre ? detectedShow.genre.toLowerCase() : 'data';
                
                if (detectedShow.season !== 'N/A') {
                    showDetails = `S${detectedShow.season} E${detectedShow.episode} | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                } else {
                    showDetails = `FILM | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                }
            }
            
            holisticInfo.innerHTML = `<strong>INDEXING</strong>`;

            const asciiTemplates = {
                drama: [
                    ["    ################    ","   ##<<<<<<<<<<<<##   ","  ####################  "," ##>>>>>>>>>>>>## ","########################"," ##<<<<<<<<<<<<## "],
                    ["  ####################  "," ##////////////## ","########################"," ##\\\\\\\\\\\\## "," ##////////////## "," ###################### "]
                ],
                scifi: [
                    ["  ########################  ","    ##||||||||||||||||##    ","   ##..####....####....##   ","     ##<<<<<<>>>>>>##     ","   ##..####....####....##   ","  ########################  "],
                    ["          ########          ","        ##========##        ","    ####################    ","      ##////////////##      ","      ##~~~~~~~~~~~~##      ","          ########          "]
                ],
                comedy: [
                    ["    ################    ","   ##~~~~~~~~~~~~##   ","  ####################  "," ##^^^^^^^^^^^^## ","########################"," ##vvvvvvvvvvvv## "],
                    ["  ####################  "," ##{{{{{{{{{{{{## ","########################"," ##}}}}}}}}}}}}## "," ##[[[[[[[[[[[[## "," ###################### "]
                ],
                general: [
                    ["    ################    ","   ##WWWWWWWWWWWW##   ","  ####################  "," ################## ","########################"," ##888888888888## "],
                    ["  ####################  "," ##@@@@@@@@@@@@@@@@## ","########################"," ##000000000000## "," ##%%%%%%%%%%%%## "," ###################### "]
                ],
                data: [
                    ["      ##########        ","    ##&&&&&&##      ","  ##################    "," ##$$$$$$$$$$$$## ","  ##++++++++++++##    ","    ################      "],
                    ["########################","##==============##","##....................##","##>>>>>>>>>>>>##","##::::::::::::##","########################"]
                ],
                automode: [
                    ["  ########################  ","    ##||||||||||||||||##    ","   ##..####....####....##   ","     ##<<<<<<>>>>>>##     ","   ##..####....####....##   ","  ########################  "],
                    ["          ########          ","        ##========##        ","    ####################    ","      ##////////////##      ","      ##~~~~~~~~~~~~##      ","          ########          "],
                    ["    ################    ","   ##WWWWWWWWWWWW##   ","  ####################  "," ################## ","########################"," ##888888888888## "]
                ]
            };
            
            // Choose templates based on whether we're in automode or show detection
            let currentTemplates;
            if (detectedShow) {
                // Show detection: use genre-based templates
                currentTemplates = asciiTemplates[showType] || asciiTemplates.general;
            } else {
                // Automode: use automode-specific templates
                currentTemplates = asciiTemplates.automode;
            }
            
            // Function to shift animation patterns from right to left for automode
            function shiftPatternRightToLeft(pattern, shiftAmount) {
                return pattern.map(row => {
                    const shift = Math.floor(shiftAmount) % row.length;
                    return row.substring(shift) + row.substring(0, shift);
                });
            }
            
            const templateDuration = 3.0;
            const revealDuration = 2.0;
            const holdDuration = 0.5;
            const transitionDuration = 0.5;

            const cycleTime = elapsedTime % templateDuration;
            const currentTemplateIndex = Math.floor(elapsedTime / templateDuration) % currentTemplates.length;
            const nextTemplateIndex = (currentTemplateIndex + 1) % currentTemplates.length;

            let currentTemplate = currentTemplates[currentTemplateIndex];
            let nextTemplate = currentTemplates[nextTemplateIndex];
            
            // Apply right-to-left movement for automode
            if (!detectedShow) {
                const shiftSpeed = 0.3; // characters per second
                const shiftAmount = elapsedTime * shiftSpeed;
                currentTemplate = shiftPatternRightToLeft(currentTemplate, shiftAmount);
                nextTemplate = shiftPatternRightToLeft(nextTemplate, shiftAmount);
            }

            let displayGrid;

            if (cycleTime < revealDuration) {
                const revealProgress = cycleTime / revealDuration;
                displayGrid = renderReveal(currentTemplate, revealProgress, width, height);
            } else if (cycleTime < revealDuration + holdDuration) {
                displayGrid = renderReveal(currentTemplate, 1.0, width, height);
                            } else {
                const transitionProgress = (cycleTime - (revealDuration + holdDuration)) / transitionDuration;
                displayGrid = renderCrossfade(currentTemplate, nextTemplate, transitionProgress, width, height);
            }

            let bottomText = '';
            if (detectedShow) {
                // Show detection mode: handle content transitions
                if (appState.entryPoint === 'detection') {
                    // For show detection, we need to create content items from the detected show
                    // and any additional content from the genre channel
                    if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                        // Create content items from detected show and genre channel content
                        const detectedShowItem = {
                            title: detectedShow.title,
                            duration: detectedShow.duration || 60,
                            type: 'detected_show'
                        };
                        
                        // Add detected show as first item
                        appState.automodeContentItems = [detectedShowItem];
                        appState.currentContentIndex = 0;
                        appState.contentItemStartTime = 0;
                        appState.contentItemDuration = detectedShowItem.duration * 60; // Convert to seconds
                    }
                    
                    // Use the same content item transition logic as automode
                    updateCurrentContentItem(elapsedTime);
                    
                    // Get current and next content items
                    const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                    const nextItem = appState.automodeContentItems[appState.currentContentIndex + 1];
                    
                    if (currentItem && currentItem.title) {
                        // Calculate time within current content item
                        const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
                        
                        // Define transition timing
                        const transitionDuration = 2.0; // 2 seconds for sliding transition
                        const transitionStart = Math.max(0, appState.contentItemDuration - transitionDuration);
                        
                        if (timeInCurrentItem < transitionStart) {
                            // Normal display phase - just scroll the current item
                            bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                        } else if (timeInCurrentItem >= transitionStart && timeInCurrentItem < appState.contentItemDuration) {
                            // Sliding transition phase
                            const transitionProgress = (timeInCurrentItem - transitionStart) / transitionDuration;
                            
                            const currentTitle = currentItem.title;
                            const nextTitle = nextItem && nextItem.title ? nextItem.title : 'Session complete';
                            
                            // Create sliding effect: current title slides left, next title slides in from right
                            const slideDistance = Math.floor(transitionProgress * (width - 2));
                            const currentText = currentTitle.padEnd(width - 2).substring(slideDistance);
                            const nextText = nextTitle.padStart(width - 2).substring(0, slideDistance);
                            
                            // Combine for sliding effect
                            bottomText = (currentText + nextText).substring(0, width - 2);
                        } else if (timeInCurrentItem >= appState.contentItemDuration) {
                            // Item finished, move to next
                            moveToNextContentItem(elapsedTime);
                            
                            // After moving to next item, show the current item (which is now the new episode)
                            const updatedCurrentItem = appState.automodeContentItems[appState.currentContentIndex];
                            if (updatedCurrentItem && updatedCurrentItem.title) {
                                bottomText = scrollText(updatedCurrentItem.title, elapsedTime, width - 2);
                            } else {
                                bottomText = "Session complete";
                            }
                        } else {
                            // Fallback
                            bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                        }
                    } else {
                        bottomText = 'No content available';
                    }
                } else {
                    // For automode, use existing logic
                    if (appState.automodeContentItems.length > 0) {
                        // Use the same content item transition logic as automode
                        updateCurrentContentItem(elapsedTime);
                        
                        // Get current and next content items
                        const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                        const nextItem = appState.automodeContentItems[appState.currentContentIndex + 1];
                        
                        if (currentItem && currentItem.title) {
                            // Calculate time within current content item
                            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
                            
                            // Define transition timing
                            const transitionDuration = 2.0; // 2 seconds for sliding transition
                            const transitionStart = Math.max(0, appState.contentItemDuration - transitionDuration);
                            
                            if (timeInCurrentItem < transitionStart) {
                                // Normal display phase - just scroll the current item
                                bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                            } else if (timeInCurrentItem >= transitionStart && timeInCurrentItem < appState.contentItemDuration) {
                                // Sliding transition phase
                                const transitionProgress = (timeInCurrentItem - transitionStart) / transitionDuration;
                                
                                const currentTitle = currentItem.title;
                                const nextTitle = nextItem && nextItem.title ? nextItem.title : 'Session complete';
                                
                                // Create sliding effect: current title slides left, next title slides in from right
                                const slideDistance = Math.floor(transitionProgress * (width - 2));
                                const currentText = currentTitle.padEnd(width - 2).substring(slideDistance);
                                const nextText = nextTitle.padStart(width - 2).substring(0, slideDistance);
                                
                                // Combine for sliding effect
                                bottomText = (currentText + nextText).substring(0, width - 2);
                            } else if (timeInCurrentItem >= appState.contentItemDuration) {
                                // Item finished, move to next
                                moveToNextContentItem(elapsedTime);
                                
                                // After moving to next item, show the current item (which is now the new episode)
                                const updatedCurrentItem = appState.automodeContentItems[appState.currentContentIndex];
                                if (updatedCurrentItem && updatedCurrentItem.title) {
                                    bottomText = scrollText(updatedCurrentItem.title, elapsedTime, width - 2);
                                } else {
                                    bottomText = "Session complete";
                                }
                            } else {
                                // Fallback
                                bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                            }
                        } else {
                            bottomText = 'No content available';
                        }
                    } else {
                        // Fallback to original show detection display
                        bottomText = detectedShow && detectedShow.title ? scrollText(detectedShow.title, elapsedTime, width - 2) : '';
                    }
                }
            } else {
                // For automode, just use the scrolling text as-is
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                    if (currentItem && currentItem.title) {
                        bottomText = scrollText(currentItem.title, elapsedTime, width - 2);
                    } else {
                        bottomText = '';
                    }
                } else {
                    bottomText = '';
                }
            }

            if (displayGrid && displayGrid.length === height) {
                displayGrid[height - 1] = bottomText;
            }
            
            panel.innerHTML = displayGrid.join('\n');

            // --- Progress Bar Logic ---
            const sessionDuration = calculateSessionDuration();
            const barWidth = 28;

            // Calculate progress
            const progress = Math.min(elapsedTime / sessionDuration, 1);
            const filledWidth = Math.floor(progress * barWidth);
            let progressBar = '‚ñà'.repeat(filledWidth);
            let placeholder = '‚ñë'.repeat(barWidth - filledWidth);
            
            // Define multiplier milestones dynamically based on session duration
            const multiplierMilestones = calculateDynamicMultiplierMilestones(sessionDuration);
            
            // Add glints for each milestone with multiplier-based colors
            let glintColors = [];
            multiplierMilestones.forEach((milestone, index) => {
                if (index === 0) return; // Skip the starting milestone
                
                const milestonePosition = Math.floor(milestone.time * barWidth);
                
                // Determine glint color based on multiplier value and mode
                let glintColor;
                if (appState.entryPoint === 'automode') {
                    // Use yellow colors for automode
                    if (milestone.multiplier <= 1.0) {
                        glintColor = '#ffff00'; // Yellow for 1.0x in automode
                    } else if (milestone.multiplier <= 1.5) {
                        glintColor = '#ffaa00'; // Orange for low-mid multipliers
                    } else {
                        glintColor = '#a985ff'; // Purple for high multipliers
                    }
                } else {
                    // Use green colors for other modes
                    if (milestone.multiplier <= 1.0) {
                        glintColor = '#00ff41'; // Green for 1.0x
                    } else if (milestone.multiplier <= 1.5) {
                        glintColor = '#ffaa00'; // Orange for low-mid multipliers
                    } else {
                        glintColor = '#a985ff'; // Purple for high multipliers
                    }
                }
                
                if (elapsedTime < (milestone.time * sessionDuration)) {
                    // Milestone not yet reached - show glint in placeholder
                    if (milestonePosition > filledWidth) {
                let placeholderArray = placeholder.split('');
                        const glintIndex = milestonePosition - filledWidth - 1;
                if (glintIndex >= 0 && glintIndex < placeholderArray.length) {
                            placeholderArray[glintIndex] = '‚óÜ';
                            glintColors[filledWidth + glintIndex] = glintColor;
                }
                placeholder = placeholderArray.join('');
            }
                } else {
                    // Milestone reached - show glint in filled bar
                    if (milestonePosition <= filledWidth) {
                let barArray = progressBar.split('');
                        if (milestonePosition - 1 < barArray.length) {
                            barArray[milestonePosition - 1] = '‚óÜ';
                            glintColors[milestonePosition - 1] = glintColor;
                }
                progressBar = barArray.join('');
            }
                }
            });
            
            progressBar += placeholder;

            const runningTime = formatRunningTime(elapsedTime);
            
            // Create colored progress bar with individual character spans
            let visualProgressBar = '';
            const defaultColor = (appState.entryPoint === 'automode') ? '#ffff00' : '#00ff41'; // Yellow for automode, green for others
            for (let i = 0; i < progressBar.length; i++) {
                const char = progressBar[i];
                const color = glintColors[i] || defaultColor;
                
                if (char === '‚óÜ') {
                    // Glint character with specific color
                    visualProgressBar += `<span style="color: ${color}; text-shadow: 0 0 3px ${color};">${char}</span>`;
                } else {
                    // Regular progress character
                    visualProgressBar += `<span style="color: ${color};">${char}</span>`;
                }
            }
            
            // Show timeline scaling info for long sessions
            const sessionDurationMinutes = sessionDuration / 60;
            let timelineInfo = '';
            if (sessionDurationMinutes > 180) {
                const scaleFactor = sessionDurationMinutes / 180;
                const maxMultiplier = Math.min(1.0 + (scaleFactor * 0.8), 3.0);
                timelineInfo = `<div style='text-align:center; font-size:10px; color: #ffaa00; margin-top: 2px;'>Extended Timeline: ${sessionDurationMinutes.toFixed(0)}min (Max ${maxMultiplier.toFixed(1)}x)</div>`;
            }
            
            holisticProgress.innerHTML = `
                <div style='text-align:center; font-size:13px; font-weight:bold; margin-bottom: 4px;'>${runningTime}</div>
                <div style='text-align:center; font-family: monospace; font-size: 12px;'>${visualProgressBar}</div>
                ${timelineInfo}
            `;
        }

        // Update points display
        function updatePointsDisplay() {
            const primaryDisplay = document.getElementById('points-primary-display');
            const secondaryDisplay = document.getElementById('points-secondary-display');
            
            if (!primaryDisplay || !secondaryDisplay) return;

            if (appState.isIndexing) {
                // Calculate real-time session points during indexing with fast mode support
                let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Handle fast mode time calculation (same logic as animation loop)
                if (appState.fastMode && appState.fastMode.active) {
                    if (appState.fastMode.mode === 'automode') {
                        // Auto mode fast mode: time is already accelerated via indexingStartTime adjustment
                        elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    } else if (appState.fastMode.mode === 'detection') {
                        // Detection mode fast mode: calculate accelerated time based on content navigation
                        const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        
                        if (appState.fastMode.isInFinalSeconds) {
                            // During final seconds, show normal time progression
                            elapsedTime = baseElapsedTime;
                        } else {
                            // When skipping through content, show accelerated time
                            const contentIndex = appState.fastMode.currentContentIndex || 0;
                            const averageContentDuration = 45 * 60; // 45 minutes in seconds
                            const timeFromFastSkipping = contentIndex * averageContentDuration;
                            elapsedTime = baseElapsedTime + timeFromFastSkipping;
                        }
                    }
                }
                
                const realTimeSessionPoints = (appState.baseRate || 0.1) * appState.currentMultiplier * elapsedTime;
                
                // In-session view: Pending validation is primary
                const totalPending = appState.totalPendingPoints + realTimeSessionPoints;
                primaryDisplay.textContent = `${totalPending.toFixed(2)} PENDING VALIDATION`;
                
                const sessionStr = `Current: +${realTimeSessionPoints.toFixed(2)} @ ${appState.currentMultiplier.toFixed(1)}x`;
                const earnedStr = `Lifetime: ${Math.floor(appState.pointsEarned).toLocaleString()}`;
                secondaryDisplay.textContent = `${sessionStr} | ${earnedStr}`;

            } else {
                // Default view: Total earned is primary
                primaryDisplay.textContent = `${Math.floor(appState.pointsEarned).toLocaleString()} LIFETIME POINTS`;
                secondaryDisplay.textContent = `+${Math.floor(appState.totalPendingPoints).toLocaleString()} pending from today`;
            }
        }

        // Legacy function for compatibility
        function startWatching() {
            toggleIndexing();
        }

        // Test functions
        function testHomeScreen() {
            console.log('testHomeScreen called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testHomeScreenFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        function testChannels() {
            console.log('testChannels called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testChannelsFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        // NEW: Test function to verify end-of-content receipt functionality
        function testEndOfContentReceipt() {
            console.log('üß™ Testing end-of-content receipt functionality...');
            
            if (!appState.isIndexing) {
                console.log('‚ùå Test requires active indexing session');
                return;
            }
            
            // Simulate reaching the end of content by setting current index to last item
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                const originalIndex = appState.currentContentIndex;
                const lastIndex = appState.automodeContentItems.length - 1;
                
                console.log(`üìä Current content index: ${originalIndex}, Last index: ${lastIndex}`);
                console.log(`üìä Total content items: ${appState.automodeContentItems.length}`);
                
                // Set to last item and trigger completion
                appState.currentContentIndex = lastIndex;
                appState.contentItemStartTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Simulate finishing the last item by calling moveToNextContentItem
                console.log('üé¨ Simulating completion of last content item...');
                moveToNextContentItem((Date.now() - appState.indexingStartTime) / 1000);
                
                console.log('‚úÖ End-of-content test completed - receipt should appear in 2 seconds');
            } else {
                console.log('‚ùå No content items available for testing');
            }
        }

        // NEW: Test function to verify dynamic timeline scaling
        function testDynamicTimelineScaling() {
            console.log('üß™ Testing dynamic timeline scaling...');
            
            // Test different session durations
            const testDurations = [
                { minutes: 90, description: "Short session (90 min)" },
                { minutes: 180, description: "Standard session (180 min)" },
                { minutes: 300, description: "Long session (300 min)" },
                { minutes: 480, description: "Very long session (480 min)" }
            ];
            
            testDurations.forEach((test, index) => {
                setTimeout(() => {
                    const sessionDurationSeconds = test.minutes * 60;
                    const milestones = calculateDynamicMultiplierMilestones(sessionDurationSeconds);
                    
                    console.log(`\nüéØ ${test.description}:`);
                    console.log(`   Duration: ${test.minutes} minutes`);
                    console.log(`   Milestones: ${milestones.length}`);
                    console.log(`   Max multiplier: ${Math.max(...milestones.map(m => m.multiplier)).toFixed(1)}x`);
                    
                    milestones.forEach((milestone, i) => {
                        const timeMinutes = (milestone.time * test.minutes).toFixed(0);
                        console.log(`   ${timeMinutes}min: ${milestone.multiplier.toFixed(1)}x`);
                    });
                    
                    if (index === testDurations.length - 1) {
                        console.log('\n‚úÖ Dynamic timeline scaling test completed');
                    }
                }, index * 1000);
            });
        }

        // NEW: Comprehensive test for fast mode progress updates
        function testFastModeProgressUpdates() {
            console.log('üß™ Testing Fast Mode Progress Updates...');
            
            if (!appState.isIndexing) {
                console.log('‚ùå Test requires active indexing session. Start indexing first.');
                return;
            }
            
            const originalFastMode = appState.fastMode;
            const originalIndexingStartTime = appState.indexingStartTime;
            const testStartTime = Date.now();
            
            console.log('üìä Initial State:');
            console.log(`   Current multiplier: ${appState.currentMultiplier}x`);
            console.log(`   Elapsed time: ${((Date.now() - appState.indexingStartTime) / 1000 / 60).toFixed(1)} min`);
            console.log(`   Fast mode active: ${appState.fastMode?.active || false}`);
            
            // Test 1: Auto Mode Fast Mode
            console.log('\nüöÄ Test 1: Auto Mode Fast Mode (500x speed)');
            appState.fastMode = {
                active: true,
                mode: 'automode',
                speedMultiplier: 500
            };
            
            // Simulate 500x acceleration by adjusting indexing start time
            const simulatedElapsedSeconds = 30 * 60; // Simulate 30 minutes elapsed
            const acceleratedTime = simulatedElapsedSeconds / 500; // 500x faster
            appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            
            // Force update animation and points
            let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            console.log(`   Simulated elapsed time: ${(elapsedTime / 60).toFixed(1)} min`);
            console.log(`   Expected display time: ${(simulatedElapsedSeconds / 60).toFixed(1)} min`);
            
            updateAnimationPanel(elapsedTime);
            updatePointsDisplay();
            updateCurrentMultiplier(elapsedTime);
            
            console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
            console.log(`   Points calculated for: ${(elapsedTime / 60).toFixed(1)} min`);
            
            // Test 2: Detection Mode Fast Mode
            setTimeout(() => {
                console.log('\nüéØ Test 2: Detection Mode Fast Mode (Content Navigation)');
                appState.fastMode = {
                    active: true,
                    mode: 'detection',
                    currentContentIndex: 5, // Simulate being on 5th piece of content
                    isInFinalSeconds: false
                };
                
                // Reset indexing start time for detection mode test
                appState.indexingStartTime = testStartTime - (2 * 60 * 1000); // 2 minutes ago
                
                // Calculate expected accelerated time
                const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                const contentIndex = appState.fastMode.currentContentIndex;
                const averageContentDuration = 45 * 60; // 45 minutes
                const expectedAcceleratedTime = baseElapsedTime + (contentIndex * averageContentDuration);
                
                console.log(`   Base elapsed time: ${(baseElapsedTime / 60).toFixed(1)} min`);
                console.log(`   Content index: ${contentIndex}`);
                console.log(`   Expected accelerated time: ${(expectedAcceleratedTime / 60).toFixed(1)} min`);
                
                // Force update with detection mode logic
                elapsedTime = expectedAcceleratedTime;
                updateAnimationPanel(elapsedTime);
                updatePointsDisplay();
                updateCurrentMultiplier(elapsedTime);
                
                console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
                console.log(`   Points calculated for: ${(elapsedTime / 60).toFixed(1)} min`);
                
                // Test 3: Detection Mode Final Seconds
                setTimeout(() => {
                    console.log('\n‚è∞ Test 3: Detection Mode Final Seconds (Normal Speed)');
                    appState.fastMode.isInFinalSeconds = true;
                    
                    // In final seconds, should use normal time progression
                    const normalElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    console.log(`   Normal elapsed time: ${(normalElapsedTime / 60).toFixed(1)} min`);
                    
                    updateAnimationPanel(normalElapsedTime);
                    updatePointsDisplay();
                    updateCurrentMultiplier(normalElapsedTime);
                    
                    console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
                    console.log(`   Points calculated for: ${(normalElapsedTime / 60).toFixed(1)} min`);
                    
                    // Restore original state
                    setTimeout(() => {
                        console.log('\nüîÑ Restoring original state...');
                        appState.fastMode = originalFastMode;
                        appState.indexingStartTime = originalIndexingStartTime;
                        
                        // Final update with restored state
                        const restoredElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        updateAnimationPanel(restoredElapsedTime);
                        updatePointsDisplay();
                        updateCurrentMultiplier(restoredElapsedTime);
                        
                        console.log('‚úÖ Fast Mode Progress Updates Test Complete!');
                        console.log(`   Restored to normal timing: ${(restoredElapsedTime / 60).toFixed(1)} min`);
                        console.log(`   Final multiplier: ${appState.currentMultiplier}x`);
                    }, 1000);
                }, 1000);
            }, 1000);
        }

        // NEW: Test function to manually trigger fast mode scenarios
        function activateFastModeTest(mode = 'automode') {
            console.log(`üöÄ Manually activating ${mode} fast mode...`);
            
            if (!appState.isIndexing) {
                console.log('‚ùå Fast mode requires active indexing session. Start indexing first.');
                return;
            }
            
            if (mode === 'automode') {
                appState.fastMode = {
                    active: true,
                    mode: 'automode',
                    speedMultiplier: 500
                };
                
                // Simulate significant elapsed time
                const simulatedMinutes = 90; // 1.5 hours
                const acceleratedTime = (simulatedMinutes * 60) / 500;
                appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
                
                console.log(`‚úÖ Auto mode fast mode activated (500x speed)`);
                console.log(`   Simulating ${simulatedMinutes} minutes elapsed`);
                
            } else if (mode === 'detection') {
                appState.fastMode = {
                    active: true,
                    mode: 'detection',
                    currentContentIndex: 4,
                    isInFinalSeconds: false
                };
                
                // Set base time for detection mode
                appState.indexingStartTime = Date.now() - (3 * 60 * 1000); // 3 minutes ago
                
                console.log(`‚úÖ Detection mode fast mode activated`);
                console.log(`   Content index: 4 (showing accelerated progress)`);
                
            } else if (mode === 'final') {
                if (!appState.fastMode || appState.fastMode.mode !== 'detection') {
                    console.log('‚ùå Final seconds mode requires detection mode to be active first');
                    return;
                }
                
                appState.fastMode.isInFinalSeconds = true;
                
                console.log(`‚úÖ Final seconds mode activated`);
                console.log(`   Showing normal time progression for final seconds`);
            }
            
            console.log('üìä Fast mode is now active - progress indicator and timer will update accordingly');
            console.log('   Use deactivateFastModeTest() to return to normal mode');
        }

        // NEW: Test function to deactivate fast mode
        function deactivateFastModeTest() {
            console.log('üîÑ Deactivating fast mode...');
            
            if (!appState.fastMode || !appState.fastMode.active) {
                console.log('‚ùå Fast mode is not currently active');
                return;
            }
            
            // Calculate current elapsed time in fast mode
            const currentElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            
            // Reset to normal timing - adjust indexing start time to maintain continuity
            const normalElapsedTime = currentElapsedTime;
            appState.indexingStartTime = Date.now() - (normalElapsedTime * 1000);
            
            // Deactivate fast mode
            appState.fastMode = {
                active: false,
                mode: null
            };
            
            console.log(`‚úÖ Fast mode deactivated`);
            console.log(`   Restored to normal timing, elapsed: ${(normalElapsedTime / 60).toFixed(1)} min`);
            console.log('üìä Progress indicator and timer now showing normal progression');
        }

        // NEW: Test function for fast mode content indexing
        function testFastModeContentIndexing() {
            console.log('üß™ Testing Fast Mode Content Indexing...');
            
            if (!appState.isIndexing) {
                console.log('‚ùå Test requires active indexing session. Start indexing first.');
                return;
            }
            
            if (appState.entryPoint !== 'automode') {
                console.log('‚ùå Test requires auto mode entry point');
                return;
            }
            
            if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                console.log('‚ùå No auto mode content items available');
                return;
            }
            
            console.log('üìä Initial State:');
            console.log(`   Total content items: ${appState.automodeContentItems.length}`);
            console.log(`   Current content index: ${appState.currentContentIndex}`);
            console.log(`   Indexed content count: ${appState.indexedContent.length}`);
            console.log(`   Fast mode active: ${appState.fastMode?.active || false}`);
            
            // Activate fast mode if not already active
            if (!appState.fastMode || !appState.fastMode.active) {
                console.log('üöÄ Activating auto mode fast mode...');
                appState.fastMode = {
                    active: true,
                    mode: 'automode',
                    speedMultiplier: 500
                };
                
                // Simulate significant elapsed time (2 hours)
                const simulatedMinutes = 120;
                const acceleratedTime = (simulatedMinutes * 60) / 500;
                appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            }
            
            // Force content indexing update
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            console.log(`\n‚è±Ô∏è  Current elapsed time: ${(elapsedTime / 60).toFixed(1)} minutes`);
            
            // Run the fast mode content indexing
            handleFastModeContentIndexing(elapsedTime);
            
            console.log('\nüìä After Fast Mode Content Indexing:');
            console.log(`   Current content index: ${appState.currentContentIndex}`);
            console.log(`   Indexed content count: ${appState.indexedContent.length}`);
            console.log(`   Last 5 indexed items:`);
            
            const lastItems = appState.indexedContent.slice(-5);
            lastItems.forEach((item, index) => {
                console.log(`     ${index + 1}. ${item.title} (${item.duration}m, ${item.points} pts)`);
            });
            
            // Calculate expected vs actual
            let totalExpectedDuration = 0;
            for (let i = 0; i <= appState.currentContentIndex && i < appState.automodeContentItems.length; i++) {
                const item = appState.automodeContentItems[i];
                if (item) {
                    let itemDuration;
                    if (typeof item.duration === 'string' && item.duration.includes(':')) {
                        const durationParts = item.duration.split(':');
                        itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        itemDuration = item.duration || (45 * 60);
                    }
                    totalExpectedDuration += itemDuration;
                }
            }
            
            console.log(`\nüìà Content Analysis:`);
            console.log(`   Expected duration for ${appState.currentContentIndex + 1} items: ${(totalExpectedDuration / 60).toFixed(1)} min`);
            console.log(`   Current elapsed time: ${(elapsedTime / 60).toFixed(1)} min`);
            console.log(`   Content catch-up status: ${totalExpectedDuration <= elapsedTime ? '‚úÖ Caught up' : '‚è≥ Still catching up'}`);
            
            console.log('\n‚úÖ Fast Mode Content Indexing Test Complete!');
        }

        // NEW: Function to manually trigger content indexing update
        function updateContentIndexing() {
            if (!appState.isIndexing) {
                console.log('‚ùå Not in indexing mode');
                return;
            }
            
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            
            if (appState.fastMode && appState.fastMode.active && appState.fastMode.mode === 'automode') {
                console.log('üîÑ Manually updating fast mode content indexing...');
                handleFastModeContentIndexing(elapsedTime);
                console.log(`‚úÖ Content indexing updated. Current index: ${appState.currentContentIndex}, Indexed items: ${appState.indexedContent.length}`);
            } else {
                console.log('‚ÑπÔ∏è Not in auto mode fast mode, using normal content progression');
            }
        }

        // NEW: Test function for receipt view with fast mode content
        function testReceiptViewWithFastMode() {
            console.log('üß™ Testing Receipt View with Fast Mode Content...');
            
            if (!appState.isIndexing) {
                console.log('‚ùå Test requires active indexing session. Starting auto mode...');
                
                // Auto-start an automode session for testing
                appState.entryPoint = 'automode';
                appState.currentBucket = 'Comedy Classics';
                appState.automodeContentItems = [
                    { title: 'The Office S1 E1', duration: '0:22' },
                    { title: 'The Office S1 E2', duration: '0:22' },
                    { title: 'The Office S1 E3', duration: '0:22' },
                    { title: 'Friends S1 E1', duration: '0:24' },
                    { title: 'Friends S1 E2', duration: '0:24' },
                    { title: 'Seinfeld S1 E1', duration: '0:23' },
                    { title: 'Seinfeld S1 E2', duration: '0:23' },
                    { title: 'Parks and Rec S1 E1', duration: '0:22' },
                    { title: 'Parks and Rec S1 E2', duration: '0:22' },
                    { title: 'Brooklyn Nine-Nine S1 E1', duration: '0:22' }
                ];
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0;
                appState.contentItemDuration = 22 * 60; // 22 minutes
                
                toggleIndexing();
                
                setTimeout(() => {
                    testReceiptViewWithFastMode();
                }, 1000);
                return;
            }
            
            // Activate fast mode and let it index content
            console.log('üöÄ Activating fast mode to populate indexed content...');
            appState.fastMode = {
                active: true,
                mode: 'automode',
                speedMultiplier: 500
            };
            
            // Simulate 2 hours of content consumption
            const simulatedMinutes = 120;
            const acceleratedTime = (simulatedMinutes * 60) / 500;
            appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            
            // Force content indexing
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            handleFastModeContentIndexing(elapsedTime);
            
            console.log(`üìä Indexed ${appState.indexedContent.length} content items from fast mode`);
            
            // End the session and show receipt
            setTimeout(() => {
                console.log('üé¨ Ending session and showing receipt view...');
                stopIndexing();
                
                setTimeout(() => {
                    console.log('‚úÖ Receipt view should now be displayed with movie credits scrolling!');
                    console.log(`   Total indexed items: ${appState.indexedContent.length}`);
                    console.log('   Check the "Content Indexed" section - it should:');
                    console.log('   ‚Ä¢ Show exactly 3 items visible at once');
                    console.log('   ‚Ä¢ Auto-scroll like movie credits (smooth vertical movement)');
                    console.log('   ‚Ä¢ Pause at top and bottom');
                    console.log('   ‚Ä¢ Continuously loop through all content');
                }, 500);
            }, 2000);
        }

        // NEW: Message-based system to call channel functions (works around cross-origin restrictions)
        function callChannelFunction(functionName, ...args) {
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.error('‚ùå Channel iframe not found or not loaded');
                return;
            }
            
            // Send message to iframe to execute the function
            channelFrame.contentWindow.postMessage({
                type: 'executeFunction',
                functionName: functionName,
                args: args
            }, '*');
            
            console.log(`üì§ Sent request to execute '${functionName}' in channel iframe`);
        }

        // NEW: Check if channel iframe is ready
        function checkChannelReady() {
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('‚ùå Channel iframe element not found');
                return false;
            }
            
            if (!channelFrame.contentWindow) {
                console.log('‚ùå Channel iframe not loaded yet');
                return false;
            }
            
            console.log('‚úÖ Channel iframe is ready');
            console.log('Channel iframe src:', channelFrame.src);
            console.log('Channel iframe display:', channelFrame.style.display);
            return true;
        }

        // NEW: Wrapper functions for easy access to channel test functions
        function testDuplicatePrevention() {
            console.log('üß™ Starting duplicate prevention test...');
            
            if (!checkChannelReady()) {
                console.log('‚ùå Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('testDuplicatePrevention');
        }

        function debugChannelContentState() {
            console.log('üîç Checking channel content state...');
            
            if (!checkChannelReady()) {
                console.log('‚ùå Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('debugContentState');
        }

        function forceShowChannelProgramTrack() {
            console.log('üéØ Forcing channel program track to show...');
            
            if (!checkChannelReady()) {
                console.log('‚ùå Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('forceShowProgramTrack');
        }

        function debugChannelPositioning() {
            console.log('üìê Debugging channel positioning...');
            
            if (!checkChannelReady()) {
                console.log('‚ùå Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('debugPositioning');
        }

        // NEW: Validation function to check content block sizing accuracy
        function validateContentBlockSizing() {
            console.log('üîç Validating content block sizing accuracy...');
            
            // Get the channel frame
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel frame not available for validation');
                return;
            }
            
            // Request layout validation from the channel
            const messageHandler = (event) => {
                if (event.data.type === 'layoutValidationResponse') {
                    window.removeEventListener('message', messageHandler);
                    
                    const validationData = event.data.data;
                    console.log('üìä Received layout validation data:', validationData);
                    
                    // Analyze the validation results
                    analyzeBlockSizing(validationData);
                }
            };
            
            window.addEventListener('message', messageHandler);
            
            // Request layout validation
            channelFrame.contentWindow.postMessage({
                type: 'validateLayoutSizing'
            }, '*');
            
            // Timeout after 3 seconds
            setTimeout(() => {
                window.removeEventListener('message', messageHandler);
                console.log('‚ö†Ô∏è Layout validation request timed out');
            }, 3000);
        }
        
        // Analyze block sizing accuracy
        function analyzeBlockSizing(validationData) {
            console.log('\nüéØ CONTENT BLOCK SIZING ANALYSIS');
            console.log('='.repeat(50));
            
            const { timelineDuration, blocks, timelineWidth } = validationData;
            
            console.log(`Timeline Duration: ${timelineDuration} minutes`);
            console.log(`Timeline Visual Width: ${timelineWidth}px`);
            console.log(`Minutes per Pixel: ${(timelineDuration / timelineWidth).toFixed(4)}`);
            
            let totalErrors = 0;
            let maxError = 0;
            let maxErrorBlock = null;
            
            console.log('\nBlock Analysis:');
            console.log('-'.repeat(50));
            
            blocks.forEach((block, index) => {
                // Calculate expected width based on duration
                const expectedWidthPercent = (block.duration / timelineDuration) * 100;
                const expectedWidthPixels = (block.duration / timelineDuration) * timelineWidth;
                
                // Calculate actual width
                const actualWidthPercent = parseFloat(block.computedWidth);
                const actualWidthPixels = (actualWidthPercent / 100) * timelineWidth;
                
                // Calculate errors
                const percentError = Math.abs(actualWidthPercent - expectedWidthPercent);
                const pixelError = Math.abs(actualWidthPixels - expectedWidthPixels);
                const percentageOfExpected = (actualWidthPercent / expectedWidthPercent) * 100;
                
                // Track maximum error
                if (percentError > maxError) {
                    maxError = percentError;
                    maxErrorBlock = block;
                }
                
                totalErrors += percentError;
                
                // Status indicator
                const isAccurate = percentError < 0.5; // Within 0.5% is considered accurate
                const status = isAccurate ? '‚úÖ' : (percentError < 2 ? '‚ö†Ô∏è' : '‚ùå');
                
                console.log(`${status} Block ${index + 1}: "${block.title}"`);
                console.log(`   Duration: ${block.duration} min`);
                console.log(`   Expected: ${expectedWidthPercent.toFixed(2)}% (${expectedWidthPixels.toFixed(1)}px)`);
                console.log(`   Actual: ${actualWidthPercent.toFixed(2)}% (${actualWidthPixels.toFixed(1)}px)`);
                console.log(`   Error: ${percentError.toFixed(2)}% (${pixelError.toFixed(1)}px)`);
                console.log(`   Accuracy: ${percentageOfExpected.toFixed(1)}% of expected`);
                
                if (block.startTime !== undefined) {
                    const expectedLeftPercent = (block.startTime / timelineDuration) * 100;
                    const actualLeftPercent = parseFloat(block.computedLeft);
                    const positionError = Math.abs(actualLeftPercent - expectedLeftPercent);
                    console.log(`   Position - Expected: ${expectedLeftPercent.toFixed(2)}%, Actual: ${actualLeftPercent.toFixed(2)}%, Error: ${positionError.toFixed(2)}%`);
                }
                
                console.log('');
            });
            
            // Summary
            console.log('üìã VALIDATION SUMMARY');
            console.log('='.repeat(50));
            
            const averageError = totalErrors / blocks.length;
            const accurateBlocks = blocks.filter((block, index) => {
                const expectedWidthPercent = (block.duration / timelineDuration) * 100;
                const actualWidthPercent = parseFloat(block.computedWidth);
                return Math.abs(actualWidthPercent - expectedWidthPercent) < 0.5;
            }).length;
            
            console.log(`Total Blocks: ${blocks.length}`);
            console.log(`Accurate Blocks (¬±0.5%): ${accurateBlocks}/${blocks.length} (${((accurateBlocks/blocks.length)*100).toFixed(1)}%)`);
            console.log(`Average Error: ${averageError.toFixed(2)}%`);
            console.log(`Maximum Error: ${maxError.toFixed(2)}% (${maxErrorBlock ? maxErrorBlock.title : 'N/A'})`);
            
            // Overall assessment
            if (averageError < 0.5) {
                console.log('üéâ EXCELLENT: Block sizing is highly accurate');
            } else if (averageError < 1.0) {
                console.log('‚úÖ GOOD: Block sizing is reasonably accurate');
            } else if (averageError < 2.0) {
                console.log('‚ö†Ô∏è FAIR: Block sizing has some inaccuracies');
            } else {
                console.log('‚ùå POOR: Block sizing needs improvement');
            }
            
            // Recommendations
            if (maxError > 2.0) {
                console.log('\nüí° RECOMMENDATIONS:');
                console.log('- Check timeline expansion logic for very long content');
                console.log('- Verify percentage calculations in calculateWidth()');
                console.log('- Ensure currentTimelineDuration is accurate');
            }
            
            console.log('\n‚úÖ Block sizing validation complete');
        }

        function showState() {
            console.log('showState called');
            console.log('Current App State:', appState);
            if (typeof Tracker !== 'undefined') {
                Tracker.logRumiState(appState);
            } else {
                console.error('Tracker not available');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded');
            setTimeout(initApp, 100);
            initializeEntryPoint(); // Setup the launcher panel
        });

        // ... (rest of the code remains unchanged)

        // --- Error State Management via Message Area ---
        let wasIndexingBeforeError = false;

        function setErrorState(errorType) {
            // Save if we were indexing before error, but DON'T stop indexing
            if (errorType && appState.isIndexing) {
                wasIndexingBeforeError = true;
                // Pause indexing when error occurs
                pauseIndexing();
            }

            // Hide all error-state panels (legacy, just in case)
            document.querySelectorAll('.error-state').forEach(el => {
                if (el && el.style) el.style.display = 'none';
            });
            
            // Show error in message area using new expandable functionality
            if (errorType) {
                // Map old error types to new ones for compatibility
                let newErrorType = errorType;
                switch (errorType) {
                    case 'volume':
                        newErrorType = 'user-error';
                        break;
                    case 'connection':
                        newErrorType = 'system-error';
                        break;
                    case 'loading':
                        newErrorType = 'loading';
                        break;
                    case 'offline':
                        newErrorType = 'offline';
                        break;
                    case 'show-interrupt':
                        newErrorType = 'show-interrupt';
                        break;
                }
                
                updateMessageArea(newErrorType);
                autoExpandSections(newErrorType);
                appState.errorState = errorType;
                Tracker.logRumiAction('ERROR_STATE_SET', { errorType, timestamp: Date.now() });
            } else {
                // Clear error state
                updateMessageArea('normal');
                appState.errorState = null;
                Tracker.logRumiAction('ERROR_STATE_CLEARED', { timestamp: Date.now() });
                // Resume indexing if it was active before error
                if (wasIndexingBeforeError) {
                    wasIndexingBeforeError = false;
                    // Resume indexing using the new pause/resume system
                    resumeIndexing();
                }
            }
            updateUI();
            updateDebugButtonStates(); // Update debug button states when error state changes
        }

        function handleVolumeError() {
            setErrorState('volume');
            // Update the volume display
            const volumeDisplay = document.getElementById('current-volume-display');
            if (volumeDisplay) {
                volumeDisplay.textContent = `${appState.volumeLevel}%`;
            }
            Tracker.logRumiAction('VOLUME_ERROR_DETECTED', { 
                currentVolume: appState.volumeLevel,
                requiredVolume: 100 
            });
        }

        function handleConnectionLost() {
            setErrorState('connection');
            Tracker.logRumiAction('CONNECTION_LOST', { 
                sessionDuration: appState.isIndexing ? Date.now() - appState.indexingStartTime : 0 
            });
        }

        function handleLoadingState() {
            setErrorState('loading');
            Tracker.logRumiAction('LOADING_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function handleOfflineState() {
            setErrorState('offline');
            Tracker.logRumiAction('OFFLINE_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function clearErrorState() {
            setErrorState(null);
        }

        // Error Recovery Functions
        function retryConnection() {
            Tracker.logRumiAction('CONNECTION_RETRY_ATTEMPTED', { timestamp: Date.now() });
            
            // Simulate connection retry
            setTimeout(() => {
                clearErrorState();
                Tracker.logRumiAction('CONNECTION_RESTORED', { timestamp: Date.now() });
            }, 2000);
        }

        function resumeSession() {
            if (appState.volumeLevel >= 100) {
                clearErrorState();
                Tracker.logRumiAction('SESSION_RESUMED', { timestamp: Date.now() });
            } else {
                // Update the volume display to show current level
                const volumeDisplay = document.getElementById('current-volume-display');
                if (volumeDisplay) {
                    volumeDisplay.textContent = `${appState.volumeLevel}%`;
                }
                Tracker.logRumiAction('SESSION_RESUME_FAILED', { 
                    reason: 'Volume still below 100%',
                    currentVolume: appState.volumeLevel 
                });
            }
        }

        // Test Functions for Error States
        function testVolumeError() {
            appState.volumeLevel = 20;
            handleVolumeError();
        }

        function testVolumeRestored() {
            appState.volumeLevel = 100;
            // This will trigger auto-resume in monitorVolume
            Tracker.logRumiAction('Volume restored for testing', { volumeLevel: appState.volumeLevel });
        }

        function testConnectionLost() {
            handleConnectionLost();
        }

        function testLoadingState() {
            handleLoadingState();
            // Auto-clear after 3 seconds
            setTimeout(() => {
                clearErrorState();
            }, 3000);
        }

        function testOfflineState() {
            handleOfflineState();
        }

        // Error State Compression (for mobile)
        function compressErrorState() {
            const errorStates = document.querySelectorAll('.error-state');
            errorStates.forEach(state => {
                state.style.fontSize = '0.8em';
                state.style.padding = '8px';
            });
        }

        // Monitor volume changes (simulated)
        function monitorVolume() {
            // Simulate volume monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger volume errors if we're already in a volume error state
                if (appState.errorState === 'volume') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && appState.volumeLevel < 100) {
                    handleVolumeError();
                }
                // Note: Removed auto-resume to prevent cycling - user must manually resolve
            }, 5000);
        }

        // Monitor connection status (simulated)
        function monitorConnection() {
            // Simulate connection monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger connection errors if we're already in a connection error state
                if (appState.errorState === 'connection') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && Math.random() < 0.1) {
                    handleConnectionLost();
                }
            }, 10000);
        }

        function showSettingsView() {
            Tracker.logRumiAction('Settings view shown');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="showMainView()">‚Üê BACK</button>';
            // }
            
            // Hide main view and show settings view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'block';
            
            appState.view = 'settings';
        }

        // Test function for receipt flow
        function testReceipt() {
            Tracker.testReceiptFlow();
            
            // Simulate a completed session for testing
            const testSessionEarnings = 45.6;
            const testSessionDuration = 930; // 15:30
            const testMultiplier = 1.2;
            
            showReceiptView(testSessionEarnings, testSessionDuration, testMultiplier);
        }

        // Toggle Leaderboard visibility
        function toggleLeaderboard() {
            const leaderboardSection = document.getElementById('leaderboard-section');
            const isExpanded = leaderboardSection.classList.toggle('is-expanded');
            Tracker.logRumiAction('Leaderboard toggled', { expanded: isExpanded });
        }

        // Toggle queue visibility
        function toggleQueue() {
            const queueDetails = document.getElementById('queue-details');
            const queueButton = document.querySelector('.show-queue-button');
            const isExpanded = queueDetails.classList.toggle('is-expanded');

            if (isExpanded) {
                queueButton.textContent = 'Hide Queue ‚ñ≤';
                updateQueueView(); // Populate the queue when showing
                Tracker.logRumiAction('Queue shown');
            } else {
                queueButton.textContent = 'Show Queue ‚ñº';
                Tracker.logRumiAction('Queue hidden');
            }
        }
        
        // Update Queue View
        function updateQueueView() {
            const queueDetails = document.getElementById('queue-details');
            if (!queueDetails) return;

            // Clear previous items
            queueDetails.innerHTML = '';

            if (appState.queue.length > 0) {
                appState.queue.forEach(item => {
                    const queueItem = document.createElement('div');
                    queueItem.className = 'queue-item';
                    queueItem.textContent = `${item.title} - ${item.details}`;
                    queueDetails.appendChild(queueItem);
                });
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'queue-item';
                noItems.textContent = 'Queue is empty';
                queueDetails.appendChild(noItems);
            }
        }
        
        // Iframe resizing and error handling logic
        function resizeIframe(iframe) {
            console.log('resizeIframe called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Iframe visibility set to visible');
                
                // Integrate content tracking with the loaded channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoading() {
            const loadingDiv = document.getElementById('channel-loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelError() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available');
        }

        // Listen for messages from iframes
        window.addEventListener('message', (event) => {
            // Basic security check
            if (!event.data || !event.data.type) {
                return;
            }

            if (event.data.type === 'rumi:setBucket') {
                const bucket = event.data.payload.bucket;
                if (bucket) {
                    appState.currentBucket = bucket;
                    Tracker.logRumiAction('Bucket changed', { bucket });
                    console.log('Rumi bucket set to:', bucket);
                    updateChannelTitle(); // Update the UI
                    updateUI(); // Update button labels for automode
                }
            }
            
            if (event.data.type === 'rumi:showAdded') {
                const { showTitle, position } = event.data.payload;
                if (showTitle) {
                    console.log(`Show "${showTitle}" added to ${position} of channel`);
                    Tracker.logRumiAction('Show added to channel', { showTitle, position });
                    
                    // Show the detected show UI
                    showDetectedShowUI(showTitle);
                } else {
                    console.warn('Received showAdded message with undefined showTitle');
                }
            }
        });

        // Initialize and update channel title
        function initializeChannelTitle() {
            updateChannelTitle();
        }

        function updateChannelTitle() {
            const channelTitleEl = document.getElementById('channel-title');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Indexing channel functions
        function resizeIframeIndexing(iframe) {
            console.log('resizeIframeIndexing called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Indexing iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting indexing iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Indexing iframe visibility set to visible');
                
                // Integrate content tracking with the loaded indexing channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoadingIndexing() {
            const loadingDiv = document.getElementById('channel-loading-indexing');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelErrorIndexing() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available (indexing)');
        }

        function initializeChannelTitleIndexing() {
            updateChannelTitleIndexing();
        }

        function updateChannelTitleIndexing() {
            const channelTitleEl = document.getElementById('channel-title-indexing');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Channel switching functionality
        let currentChannel = 'rumi'; // 'rumi' or 'genre'
        
        function toggleChannel() {
            // This function is no longer needed - channels are handled automatically
            // based on entry point. Remove the problematic element access.
            console.log('Channel switching is now automatic based on entry point');
        }

        // Function to send show detection to genre channel
        function sendShowDetection(showData) {
            console.log('Sending show detection:', showData);
            
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            const message = {
                type: 'rumi:showDetected',
                payload: showData
            };
            
            console.log('Sending message to channel frames:', message);
            
            // Function to send message when iframe is ready
            function sendMessageWhenReady(iframe, frameName) {
                if (iframe && iframe.contentWindow) {
                    try {
                        console.log(`Sending to ${frameName} channel frame`);
                        console.log(`${frameName} frame src:`, iframe.src);
                        // Don't try to access iframe document properties - causes CORS errors
                        
                        iframe.contentWindow.postMessage(message, '*');
                        console.log(`Message sent to ${frameName} frame successfully`);
                        return true;
                    } catch (e) {
                        console.error(`Error sending to ${frameName} frame:`, e);
                        return false;
                    }
                } else {
                    console.error(`${frameName} channel frame not found or not ready`);
                    console.log(`${frameName} frame exists:`, !!iframe);
                    console.log(`${frameName} frame contentWindow exists:`, !!(iframe && iframe.contentWindow));
                    return false;
                }
            }
            
            // Send to both iframes (home and indexing views)
            const homeSent = sendMessageWhenReady(channelFrame, 'home');
            const indexingSent = sendMessageWhenReady(channelFrameIndexing, 'indexing');
            
            if (!homeSent || !indexingSent) {
                // If either frame wasn't ready, try again after a short delay
                console.log('Some frames not ready, retrying in 1 second...');
                setTimeout(() => {
                    sendMessageWhenReady(channelFrame, 'home (retry)');
                    sendMessageWhenReady(channelFrameIndexing, 'indexing (retry)');
                }, 1000);
            }
            
            Tracker.logRumiAction('Show detection sent', showData);
        }

        // Test function to simulate show detection
        function testShowDetection() {
            const testShows = [
                {
                    title: 'BREAKING BAD',
                    genre: 'Thriller',
                    service: 'NETFLIX',
                    season: 'S5',
                    episode: 'E16'
                },
                {
                    title: 'STRANGER THINGS',
                    genre: 'Thriller',
                    service: 'NETFLIX',
                    season: 'S4',
                    episode: 'E9'
                },
                {
                    title: 'THE CROWN',
                    genre: 'Drama',
                    service: 'NETFLIX',
                    season: 'S6',
                    episode: 'E10'
                },
                {
                    title: 'BLACK MIRROR',
                    genre: 'Sci-Fi',
                    service: 'NETFLIX',
                    season: 'S6',
                    episode: 'E3'
                }
            ];
            
            const randomShow = testShows[Math.floor(Math.random() * testShows.length)];
            sendShowDetection(randomShow);
        }
        
        // Test function to manually trigger show detection for channel
        function testChannelShowDetection() {
            const testShow = {
                title: 'Blade Runner 2049',
                genre: 'Sci-Fi',
                service: 'HBO MAX',
                season: 'N/A',
                episode: 'N/A',
                duration: 164
            };
            
            console.log('Setting up manual show detection test...');
            appState.pendingShowForGenreChannel = testShow;
            appState.detectedShow = testShow;
            
            console.log('Sending show detection manually...');
            sendShowDetection(testShow);
        }

        // Test function to manually test the animation
        function testAnimation() {
            console.log('Testing animation manually...');
            
            // Force show the nokia content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.style.display = 'block';
                console.log('Nokia content shown');
            }
            
            // Test the animation panel directly
            const panel = document.getElementById('animation-panel-content');
            if (panel) {
                console.log('Animation panel found, testing with simple content...');
                panel.innerHTML = 'TESTING ANIMATION\n################\n##WORKING####\n################\nTESTING ANIMATION';
                console.log('Set test content to panel');
            } else {
                console.error('Animation panel not found!');
            }
            
            // Also test the session stats panel
            const statsPanel = document.getElementById('session-stats-content');
            if (statsPanel) {
                statsPanel.innerHTML = 'TESTING STATS\nMULTIPLIER: 1.0x\nSESSION: +0.00 | [0:00/30:00]\n############################';
                console.log('Set test content to stats panel');
            }
        }

        // Function to show detected show UI
        function showDetectedShowUI(showTitle) {
            // The animation will be updated by the main animation loop once it starts.
            // There is no need to force an update here.
            Tracker.logRumiAction('Detected show UI shown', { showTitle });
        }

        // Function to dismiss detected show UI (home view)
        function dismissDetectedShow() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI dismissed');
        }

        // Function to dismiss detected show UI (indexing view)
        function dismissDetectedShowIndexing() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI (indexing) dismissed');
        }

        // Function to update animation when show is detected
        function updateAnimationForShow(showTitle) {
            // Force an immediate animation update with new show data
            if (appState.isIndexing) {
                const now = Date.now();
                const elapsedMilliseconds = (now - appState.indexingStartTime) / 1000;
                updateAnimationPanel(elapsedMilliseconds);
                
                // Log the show detection for animation
                Tracker.logRumiAction('Animation updated for show', { showTitle });
            }
        }

        // Enhanced animation loop with show detection integration and automatic transitions
        function animateSessionStats() {
            let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            
            // Handle fast mode time calculation
            if (appState.fastMode && appState.fastMode.active) {
                if (appState.fastMode.mode === 'automode') {
                    // Auto mode fast mode: time is already accelerated via indexingStartTime adjustment
                    // But we need to ensure smooth progress updates during the acceleration
                    elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    
                    // Handle fast mode content indexing for auto mode
                    handleFastModeContentIndexing(elapsedTime);
                } else if (appState.fastMode.mode === 'detection') {
                    // Detection mode fast mode: calculate accelerated time based on content navigation
                    const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    
                    // If we're in fast mode navigation, accelerate the time display
                    if (appState.fastMode.isInFinalSeconds) {
                        // During final seconds, show normal time progression
                        elapsedTime = baseElapsedTime;
                    } else {
                        // When skipping through content, show accelerated time
                        const contentIndex = appState.fastMode.currentContentIndex || 0;
                        const averageContentDuration = 45 * 60; // 45 minutes in seconds
                        const timeFromFastSkipping = contentIndex * averageContentDuration;
                        elapsedTime = baseElapsedTime + timeFromFastSkipping;
                    }
                }
            }
            
            updateAnimationPanel(elapsedTime);
            updatePointsDisplay(); // Update points display in real-time at 60fps
            
            // Update multiplier based on dynamic milestones
            updateCurrentMultiplier(elapsedTime);
            
            // Apply enhanced multiplier every 30 seconds (if transition system is available)
            if (Math.floor(elapsedTime) % 30 === 0 && Math.floor(elapsedTime) > 0) {
                applyEnhancedMultiplier();
            }
            
            // Check for automatic show transitions based on duration
            checkForAutomaticTransition(elapsedTime);
            
            // Continue animation loop at 60fps
            animationFrameId = requestAnimationFrame(animateSessionStats);
        }
        
        // NEW: Check if current show should transition to next show automatically
        function checkForAutomaticTransition(elapsedTime) {
            // Only do automatic transitions in detection mode with transition system
            if (appState.entryPoint !== 'detection' || !window.transitionSystem) return;
            
            // Don't transition if we're already transitioning
            if (appState.isTransitioning) return;
            
            // Calculate time spent on current show
            const timeInCurrentShow = elapsedTime - (appState.contentItemStartTime || 0);
            const currentShowDuration = (appState.contentItemDuration || 45 * 60); // Duration in seconds
            
            // Check if current show has completed its duration
            if (timeInCurrentShow >= currentShowDuration) {
                console.log(`Show completed after ${timeInCurrentShow}s (duration: ${currentShowDuration}s)`);
                
                // Get next show from channel
                getNextShowFromChannel().then(nextShow => {
                    if (nextShow) {
                        console.log('Auto-transitioning to next show:', nextShow.title);
                        transitionToNextShow(nextShow);
                    } else {
                        console.log('No more shows in channel, continuing with current show');
                    }
                }).catch(error => {
                    console.error('Error getting next show:', error);
                });
            }
        }
        
        // NEW: Get the next show from the channel queue
        async function getNextShowFromChannel() {
            return new Promise((resolve) => {
                // Request current content from channel
                const channelFrame = document.getElementById('channel-frame');
                if (!channelFrame || !channelFrame.contentWindow) {
                    resolve(null);
                    return;
                }
                
                // Set up message listener for channel response
                const messageHandler = (event) => {
                    if (event.data.type === 'currentContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const channelContent = event.data.content || [];
                        console.log('Received channel content:', channelContent);
                        
                        // Find current show index
                        let currentIndex = -1;
                        if (appState.detectedShow) {
                            currentIndex = channelContent.findIndex(item => 
                                item.title === appState.detectedShow.title
                            );
                        }
                        
                        // Get next show
                        const nextIndex = currentIndex + 1;
                        if (nextIndex < channelContent.length) {
                            const nextShow = channelContent[nextIndex];
                            console.log(`Found next show at index ${nextIndex}:`, nextShow);
                            resolve(nextShow);
                        } else {
                            console.log('No next show available in channel');
                            resolve(null);
                        }
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Request current content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                
                // Timeout after 2 seconds
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    resolve(null);
                }, 2000);
            });
        }
        
        // NEW: Get the next show from channel for fast mode (uses independent index tracking)
        async function getNextShowFromChannelForFastMode() {
            return new Promise((resolve) => {
                // Request current content from channel
                const channelFrame = document.getElementById('channel-frame');
                if (!channelFrame || !channelFrame.contentWindow) {
                    resolve(null);
                    return;
                }
                
                // Set up message listener for channel response
                const messageHandler = (event) => {
                    if (event.data.type === 'currentContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const channelContent = event.data.content || [];
                        console.log('Fast Mode: Received channel content:', channelContent.length, 'items');
                        
                        // Use fast mode's independent index tracking
                        const currentFastModeIndex = appState.fastMode.currentContentIndex || 0;
                        const nextIndex = currentFastModeIndex + 1;
                        
                        console.log(`Fast Mode: Current index ${currentFastModeIndex}, next index ${nextIndex}`);
                        
                        if (nextIndex < channelContent.length) {
                            const nextShow = channelContent[nextIndex];
                            console.log(`Fast Mode: Found next show at index ${nextIndex}:`, nextShow.title);
                            resolve(nextShow);
                        } else {
                            console.log('Fast Mode: No more shows available in channel - session complete');
                            resolve(null);
                        }
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Request current content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                
                // Timeout after 2 seconds
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    resolve(null);
                }, 2000);
            });
        }
        
        // NEW: Transition to the next show in sequence
        function transitionToNextShow(nextShow) {
            console.log('=== AUTOMATIC SHOW TRANSITION ===');
            console.log('From:', appState.detectedShow?.title);
            console.log('To:', nextShow.title);
            
            // Set transition flag
            appState.isTransitioning = true;
            
            // Convert channel show format to app show format
            const formattedShow = {
                title: nextShow.title,
                season: nextShow.season || 'N/A',
                episode: nextShow.episode || 'N/A', 
                service: nextShow.service || 'Unknown',
                genre: nextShow.genre || 'Unknown',
                duration: nextShow.duration || 45,
                type: nextShow.type || 'show'
            };
            
            // Use the transition system for smooth transition
            if (window.transitionSystem) {
                transitionToShowWithSystem(formattedShow);
            } else {
                // Fallback: direct transition
                directTransitionToShow(formattedShow);
            }
            
            // Clear transition flag
            setTimeout(() => {
                appState.isTransitioning = false;
            }, 1000);
            
            console.log('=== TRANSITION COMPLETE ===');
        }
        
        // NEW: Direct transition fallback (without transition system)
        function directTransitionToShow(newShow) {
            // Store previous show
            if (appState.detectedShow) {
                markContentAsPlayedWithTransition(appState.detectedShow);
            }
            
            // Update to new show
            const previousShow = appState.detectedShow;
            appState.detectedShow = newShow;
            
            // Set originalShow only on first transition
            if (!appState.originalShow) {
                appState.originalShow = previousShow;
            }
            
            // Track transition
            appState.interruptNewShow = newShow;
            appState.showInterruptTimestamp = Date.now();
            appState.transitionCount = (appState.transitionCount || 0) + 1;
            
            // Update global variable for compatibility
            detectedShow = newShow;
            
            // Reset content timing for new show
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.contentItemStartTime = elapsedTime;
            appState.contentItemDuration = (newShow.duration || 45) * 60; // Convert to seconds
            
            // Update UI
            updateUI();
            updatePointsDisplay();
            updateContentDisplay();
            updateButtonWithCurrentShow(newShow);
            
            console.log(`Direct transition: ${previousShow?.title} ‚Üí ${newShow.title}`);
        }

        function simulateStreamDetection() {
            const statusEl = document.getElementById('stream-detector-status');
            if (!statusEl) return;

            statusEl.textContent = 'DETECTING...';
            setTimeout(() => {
                statusEl.textContent = 'STREAM DETECTED!';
                // Open extension or perform other action here
            }, 2000);
        }

        function simulateAutomode() {
            // Placeholder for automode campaign logic
            alert('Automode Campaign button clicked!');
        }

        let detectedShow = null;
        const availableShows = [
            { title: 'Stranger Things', genre: 'Thriller', service: 'NETFLIX', season: 'S4', episode: 'E9', duration: 60 },
            { title: 'The Office', genre: 'Comedy', service: 'PEACOCK', season: 'S3', episode: 'E20', duration: 22 },
            { title: 'Blade Runner 2049', genre: 'Sci-Fi', service: 'HBO MAX', season: 'N/A', episode: 'N/A', year: '2017', duration: 164 },
            { title: 'The Crown', genre: 'Drama', service: 'NETFLIX', season: 'S6', episode: 'E10', duration: 58 },
            { title: 'Planet Earth II', genre: 'Documentary', service: 'DISCOVERY+', season: 'S1', episode: 'E1', duration: 60 }
        ];

        // NEW: State for coordinating the genre channel update
        appState.pendingShowForGenreChannel = null;

        function initializeEntryPoint() {
            // Pick a random show on load
            detectedShow = availableShows[Math.floor(Math.random() * availableShows.length)];
            
            const detectorUI = document.getElementById('stream-detector-entry');
            detectorUI.innerHTML = `
                <div class="status">Stream Detected!</div>
                <div class="subtext" style="margin-top: 10px; margin-bottom: 10px;">
                    Watching: <strong>${detectedShow.title}</strong>
                </div>
                <button class="primary-cta" style="width:100%; padding: 10px 12px; font-size: 12px;" onclick="launchWithDetection()">
                    Launch Rumi & Get Points
                </button>
            `;
            detectorUI.style.cursor = 'default';
        }

        function launchWithDetection() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'block';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const streamDetector = document.getElementById('stream-detector-entry');
            const automodeButton = document.querySelector('.automode-button');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Store the entry point info for when activation happens
            appState.pendingEntryPoint = 'detection';
            appState.pendingDetectedShow = detectedShow;
            
            // Don't set the main entry point yet - wait for activation
            // appState.entryPoint = 'detection';
            // appState.detectedShow = detectedShow;
            
            // Don't update UI yet - wait for activation
            // updateUI();
        }

        function launchWithAutomode() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'block';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const streamDetector = document.getElementById('stream-detector-entry');
            const automodeButton = document.querySelector('.automode-button');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Store the entry point info for when activation happens
            appState.pendingEntryPoint = 'automode';
            
            // Don't set the main entry point yet - wait for activation
            // appState.isIndexing = false;
            // appState.entryPoint = 'automode';
            // detectedShow = null;
            
            // Don't update UI yet - wait for activation
            // updateUI();
        }

        function activateExtension() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Activate the circle with visual feedback
            activationCircle.classList.add('activated');
            
            // After a brief delay, remove the deactivated state and proceed
            setTimeout(() => {
                // Remove deactivated state
                popup.classList.remove('deactivated');
                activationCircle.style.display = 'none';
                activationCircle.classList.remove('activated');
                
                // Now proceed with the normal flow based on pending entry point
                if (appState.pendingEntryPoint === 'detection') {
                    // Set the state to show indexing screen but NOT start indexing yet
                    appState.isIndexing = false;
                    appState.entryPoint = 'detection';
                    appState.detectedShow = appState.pendingDetectedShow;
                    appState.pendingShowForGenreChannel = appState.pendingDetectedShow;
                    
                    // Initialize transition system immediately for detection mode
                    if (!window.transitionSystem) {
                        console.log('Auto-initializing transition system for detection mode...');
                        initializeTransitionSystem();
                    }
                    
                    // Reset channel expansion state for new entry point
                    appState.channelExpanded = false;

                    // Update UI after state is set
                    updateUI();

                    // Update the UI elements within the indexing view
                    showDetectedShowUI(appState.pendingDetectedShow.title);

                    // Send show detection to genre channel
                    setTimeout(() => {
                        sendShowDetection(appState.pendingShowForGenreChannel);
                    }, 500);
                    
                } else if (appState.pendingEntryPoint === 'automode') {
                    // Set the state to show indexing screen but NOT start indexing yet
                    appState.isIndexing = false;
                    appState.entryPoint = 'automode';
                    detectedShow = null; // Clear detectedShow for automode

                    // Ensure we're on the Rumi channel for automode
                    currentChannel = 'rumi';
                    
                    // Reset channel expansion state for new entry point
                    appState.channelExpanded = false;
                    
                    // Update UI after state is set
                    updateUI();

                    // Force update the expandable channel UI to show the correct channel
                    updateExpandableChannelUI();
                }
                
                // Clear pending entry point (but keep pendingShowForGenreChannel for the setTimeout)
                appState.pendingEntryPoint = null;
                appState.pendingDetectedShow = null;
                
            }, 500); // 500ms delay for visual feedback
        }

        function updateEntryPointForNextStep() {
            const detectorUI = document.getElementById('stream-detector-entry');
            detectorUI.innerHTML = `
                <div class="status">Indexing in Progress...</div>
                <div class="subtext" style="margin-top: 10px; margin-bottom: 10px;">
                    Current Show: <strong>${detectedShow.title}</strong>
                </div>
                <button class="secondary-button" style="width:100%; padding: 10px 12px; font-size: 12px; border-color: #ffaa00; color: #ffaa00;" onclick="simulateShowChange()">
                    Simulate User Changing Show
                </button>
            `;
        }

        function simulateShowChange() {
            // Pick a new random show
            const newShow = availableShows.find(s => s.title !== detectedShow.title) || availableShows[1];
            
            // Stop current indexing if active
            if (appState.isIndexing) {
            stopIndexing();
            }
            
            // Update the detected show
            detectedShow = newShow;
            appState.detectedShow = newShow;
            appState.pendingShowForGenreChannel = newShow;
            
            // Update the entry point UI
            updateEntryPointForNextStep();
            
            // Send the new show detection
            setTimeout(() => {
                sendShowDetection(newShow);
            }, 500);
        }

        // Cache control toggle function
        function toggleCacheControl() {
            const cacheBtn = document.getElementById('cache-control-btn');
            const isCacheDisabled = cacheBtn.textContent.includes('Disable');
            
            if (isCacheDisabled) {
                // Enable cache
                cacheBtn.textContent = 'üóÇÔ∏è Enable Cache';
                        cacheBtn.style.background = '#1a2a1a';
        cacheBtn.style.borderColor = '#ffff00';
        cacheBtn.style.color = '#ffff00';
                
                // Remove cache-busting headers from genre channel iframe
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                if (channelFrame && channelFrame.src.includes('Genre-channel_v2.html')) {
                    channelFrame.src = channelFrame.src.split('?')[0];
                }
                if (channelFrameIndexing && channelFrameIndexing.src.includes('Genre-channel_v2.html')) {
                    channelFrameIndexing.src = channelFrameIndexing.src.split('?')[0];
                }
                
                console.log('Cache enabled - iframes will use cached versions');
            } else {
                // Disable cache
                cacheBtn.textContent = 'üóÇÔ∏è Disable Cache';
                cacheBtn.style.background = '#1a1a1a';
                cacheBtn.style.borderColor = '#666';
                cacheBtn.style.color = '#ccc';
                
                // Add cache-busting parameter to genre channel iframes
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                const timestamp = Date.now();
                
                if (channelFrame && channelFrame.src.includes('Genre-channel_v2.html')) {
                    channelFrame.src = channelFrame.src.split('?')[0] + '?cache=' + timestamp;
                }
                if (channelFrameIndexing && channelFrameIndexing.src.includes('Genre-channel_v2.html')) {
                    channelFrameIndexing.src = channelFrameIndexing.src.split('?')[0] + '?cache=' + timestamp;
                }
                
                console.log('Cache disabled - iframes will reload fresh versions');
            }
        }

        // Add new message listeners for genre channel coordination
        window.addEventListener('message', (event) => {
    const message = event.data;

    if (!message) return; // Ignore empty messages

    console.log('Main window received message:', message);

    switch(message.type) {
        case 'rumi:setBucket': {
            const { bucket } = message.payload;
            if (bucket) {
                appState.currentBucket = bucket;
                console.log('Rumi channel bucket updated:', appState.currentBucket);
            }
            break;
        }
        case 'genreChannelReady': {
            console.log('Genre channel ready, sending pending show detection');
            console.log('pendingShowForGenreChannel:', appState.pendingShowForGenreChannel);
            if (appState.pendingShowForGenreChannel) {
                sendShowDetection(appState.pendingShowForGenreChannel);
            } else {
                console.log('No pending show for genre channel');
            }
            break;
        }
        case 'rumiChannelReady': {
            // Rumi channel is ready, no special action needed for automode
            console.log('Rumi channel ready');
            break;
        }
        case 'genreChangeComplete': {
            if (appState.pendingShowForGenreChannel) {
                // Now that the genre channel is confirmed to be updated, start indexing.
                startIndexing();
                updateEntryPointForNextStep();
                
                // Clear the pending state
                appState.pendingShowForGenreChannel = null;
            }
            break;
        }
        case 'rumi:showSelected': {
            // Handle show selection from channel for transition
            const { showData } = message.payload;
            if (showData && appState.isIndexing) {
                console.log('Show selected for transition from channel:', showData);
                
                // Convert channel data to show format
                const newShow = {
                    title: showData.title,
                    season: showData.season || 'N/A',
                    episode: showData.episode || 'N/A',
                    service: showData.service,
                    genre: showData.genre || 'Unknown',
                    duration: showData.duration || 45,
                    type: showData.type || 'show'
                };
                
                // Trigger transition using the transition system
                transitionToShowWithSystem(newShow);
                
                Tracker.logRumiAction('Show transition via channel selection', { 
                    fromShow: appState.detectedShow?.title,
                    toShow: newShow.title 
                });
            }
            break;
        }
    }
});

        // Entry Point 1: Launch with a detected show
        function launchWithShowDetection(show) {
            if (!show) return;

            appState.entryPoint = 'showDetection';
            Tracker.logRumiAction('Launch via show detection', { showTitle: show.title });

            // Set the detected show state immediately
            updateDetectedShowState(show); // Pass the whole show object

            // Switch to the Genre Channel view programmatically
            switchToGenreChannel();

            // Store the show data to be sent after the channel is ready
            appState.pendingShowForGenreChannel = show;
        }

        // This function sets the application state when a show is detected.
        // It's a key part of the entry point 1 flow.
        function updateDetectedShowState(show) {
            appState.detectedShow = show;
            showDetectedShowUI(show.title);
        }

        // Show receipt with mode-specific data
        function showReceipt(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint
            });
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-overlay').style.display = 'block';
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${sessionEarnings.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${(appState.totalPendingPoints + sessionEarnings).toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(sessionDuration);
            document.getElementById('receipt-multiplier').textContent = `${finalMultiplier.toFixed(1)}x`;
            
            // Set bonus text based on multiplier
            const bonusElement = document.getElementById('receipt-bonus');
            if (finalMultiplier >= 1.2) {
                bonusElement.textContent = '10min Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Generate mode-specific content list
            generateReceiptContentList(sessionDuration, appState.entryPoint);
            
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // Helper function to get related content based on genre with points calculation
        function getRelatedContentWithPoints(genre, remainingTime, baseRate, multiplier) {
            const relatedShows = {
                'Drama': [
                    { title: 'Succession S4:E3', duration: 58 },
                    { title: 'The Crown S6:E8', duration: 52 },
                    { title: 'Mad Men S7:E14', duration: 47 },
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'The Wire S2:E12', duration: 60 },
                    { title: 'Better Call Saul S6:E13', duration: 45 }
                ],
                'Comedy': [
                    { title: 'The Office S3:E20', duration: 22 },
                    { title: 'Ted Lasso S3:E12', duration: 45 },
                    { title: 'Fleabag S2:E6', duration: 28 },
                    { title: 'Parks and Recreation S4:E22', duration: 22 },
                    { title: 'Brooklyn Nine-Nine S5:E23', duration: 22 },
                    { title: 'The Good Place S4:E13', duration: 22 }
                ],
                'Sci-Fi': [
                    { title: 'Stranger Things S4:E9', duration: 51 },
                    { title: 'Black Mirror S6:E3', duration: 45 },
                    { title: 'The Expanse S6:E6', duration: 42 },
                    { title: 'Westworld S3:E8', duration: 58 },
                    { title: 'Altered Carbon S2:E8', duration: 45 },
                    { title: 'The Mandalorian S3:E8', duration: 35 }
                ],
                'Thriller': [
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'Killing Eve S4:E8', duration: 44 },
                    { title: 'Ozark S4:E14', duration: 60 },
                    { title: 'Mindhunter S2:E9', duration: 45 },
                    { title: 'True Detective S3:E8', duration: 58 },
                    { title: 'The Sinner S4:E8', duration: 45 }
                ]
            };
            
            const shows = relatedShows[genre] || relatedShows['Drama'];
            const content = [];
            let timeLeft = remainingTime;
            
            for (const show of shows) {
                if (timeLeft <= 0) break;
                const showTime = Math.min(show.duration, timeLeft);
                const showTimeSeconds = showTime * 60;
                const showPoints = Math.round((showTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                content.push({
                    title: show.title,
                    duration: formatTime(showTime),
                    points: showPoints.toFixed(1)
                });
                timeLeft -= showTime;
            }
            
            return content;
        }

        // Helper function to get automode content based on bucket with points calculation
        function getAutomodeContent(bucket, sessionDuration, baseRate, multiplier) {
            const bucketContent = {
                'Content Intelligence': [
                    { title: 'Breaking Bad Pilot Scene Analysis' },
                    { title: 'The Crown Opening Sequence Review' },
                    { title: 'Stranger Things Monster Reveal Assessment' },
                    { title: 'Mad Men Office Scene Analysis' },
                    { title: 'The Wire Street Scene Review' },
                    { title: 'Succession Board Meeting Assessment' },
                    { title: 'Black Mirror Tech Scene Analysis' },
                    { title: 'Game of Thrones Battle Scene Review' }
                ],
                'Scene Description pipeline': [
                    { title: 'Chernobyl Reactor Scene Review' },
                    { title: 'The Marvelous Mrs. Maisel Standup Analysis' },
                    { title: 'Killing Eve Chase Scene Assessment' },
                    { title: 'The Crown Diana Interview Analysis' },
                    { title: 'Stranger Things Eleven Powers Review' },
                    { title: 'Succession Logan Speech Assessment' },
                    { title: 'The Witcher Monster Hunt Analysis' },
                    { title: 'Better Call Saul Legal Maneuver Review' }
                ],
                'Story Tree': [
                    { title: 'Breaking Bad Season 1 Arc Summary' },
                    { title: 'The Crown Episode 3 Political Subplot' },
                    { title: 'Stranger Things Season 2 Development' },
                    { title: 'Mad Men Season 4 Opening Analysis' },
                    { title: 'The Wire Season 2 Setup Review' },
                    { title: 'Succession Power Struggle Assessment' },
                    { title: 'Black Mirror Episode Arc Analysis' },
                    { title: 'Game of Thrones Red Wedding Impact' }
                ],
                'Character Summaries': [
                    { title: 'Walter White Transformation Arc' },
                    { title: 'Tony Soprano Therapy Session Analysis' },
                    { title: 'Don Draper Identity Crisis Review' },
                    { title: 'Jimmy McGill Evolution Assessment' },
                    { title: 'Eleven Power Discovery Analysis' },
                    { title: 'Kendall Roy Ambition Review' },
                    { title: 'Fleabag Self-Destruction Assessment' },
                    { title: 'Ted Lasso Optimism Analysis' }
                ]
            };
            
            const content = bucketContent[bucket] || bucketContent['Content Intelligence'];
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of content) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1)
                });
                timeLeft -= itemTime;
            }
            
            return items;
        }

        // Helper function to get generic content with points calculation
        function getGenericContentWithPoints(sessionDuration, baseRate, multiplier) {
            const genericContent = [
                { title: 'Blade Runner 2029' },
                { title: 'Stranger Things S3:E1' },
                { title: 'The Witcher S2:E3' },
                { title: 'Breaking Bad Pilot' },
                { title: 'The Crown Opening' },
                { title: 'Black Mirror Episode' }
            ];
            
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of genericContent) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1)
                });
                timeLeft -= itemTime;
            }
            
            return items;
        }

        // Helper function to get show detection content based on detected show
        function getShowDetectionContent(detectedShow, sessionDuration) {
            // Get actual content from the channel iframe
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    // Request current content from the channel
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                    
                    // For now, return a placeholder - the actual content will be set via message handler
                    return [];
                } catch (e) {
                    console.log('Could not request content from channel:', e.message);
                }
            }
            
            // Fallback: return empty array - content will be populated via message handler
            return [];
        }

        // NEW: Message handler for channel content
        window.addEventListener('message', function(event) {
            if (event.data.type === 'currentContentResponse') {
                console.log('Received current content from channel:', event.data.content);
                
                // Convert channel content to show detection content format
                const channelContent = event.data.content || [];
                const showDetectionContent = channelContent.map(item => ({
                    title: item.title,
                    duration: item.duration * 60, // Convert minutes to seconds
                    type: item.type || 'show',
                    service: item.service || 'UNKNOWN',
                    season: item.season || 'N/A',
                    episode: item.episode || 'N/A'
                }));
                
                // Update the automode content items with actual channel content
                appState.automodeContentItems = showDetectionContent;
                
                // Recalculate content item duration if we have items
                if (showDetectionContent.length > 0) {
                    const firstItem = showDetectionContent[0];
                    appState.contentItemDuration = firstItem.duration;
                    console.log(`Updated show detection content with ${showDetectionContent.length} items from channel`);
                    console.log(`First item: ${firstItem.title}, duration: ${firstItem.duration} seconds`);
                    
                    // If we're currently indexing, update the UI to reflect the new content
                    if (appState.isIndexing) {
                        // Force an immediate animation update with the new content
                        const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        updateAnimationPanel(elapsedTime);
                        updatePointsDisplay();
                        
                        // Update the button text to show the current show
                        const ctaButton = document.getElementById('cta-button');
                        if (ctaButton && appState.entryPoint === 'detection') {
                            const show = firstItem;
                            if (show.season !== 'N/A' && show.episode !== 'N/A') {
                                ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                            } else {
                                ctaButton.textContent = `START WATCHING ${show.title}`;
                            }
                        }
                    }
                }
            }
        });

        // Debug Panel Collapsible Functions
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            const content = document.getElementById('debug-panel-content');
            const toggle = document.getElementById('debug-panel-toggle');
            
            if (panel.classList.contains('visible')) {
                // Hide the panel
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            } else {
                // Show the panel
                panel.classList.add('visible');
                trigger.style.display = 'none';
                
                // Expand the content when showing
                content.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
                toggle.classList.remove('collapsed');
                
                // Expand error testing section by default (most commonly used)
                const errorTestingContent = document.getElementById('error-testing-content');
                const errorTestingToggle = document.getElementById('error-testing-toggle');
                if (errorTestingContent && errorTestingToggle) {
                    errorTestingContent.classList.remove('collapsed');
                    errorTestingToggle.textContent = '‚ñº';
                    errorTestingToggle.classList.remove('collapsed');
                }
            }
        }

        function toggleDebugSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const toggle = document.getElementById(sectionId + '-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
                toggle.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
                toggle.classList.add('collapsed');
            }
        }

        // Initialize debug panel state
        document.addEventListener('DOMContentLoaded', function() {
            // Start with debug panel hidden and trigger visible
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            
            if (panel && trigger) {
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            }
            
            // Start with sections collapsed
            const basicTestingContent = document.getElementById('basic-testing-content');
            const errorTestingContent = document.getElementById('error-testing-content');
            const sessionManagementContent = document.getElementById('session-management-content');
            const basicTestingToggle = document.getElementById('basic-testing-toggle');
            const errorTestingToggle = document.getElementById('error-testing-toggle');
            const sessionManagementToggle = document.getElementById('session-management-toggle');
            
            if (basicTestingContent && errorTestingContent && sessionManagementContent) {
                basicTestingContent.classList.add('collapsed');
                errorTestingContent.classList.add('collapsed');
                sessionManagementContent.classList.add('collapsed');
                basicTestingToggle.textContent = '‚ñ∂';
                errorTestingToggle.textContent = '‚ñ∂';
                sessionManagementToggle.textContent = '‚ñ∂';
                basicTestingToggle.classList.add('collapsed');
                errorTestingToggle.classList.add('collapsed');
                sessionManagementToggle.classList.add('collapsed');
            }

            // Initialize debug button states
            updateDebugButtonStates();
        });

        // Keyboard shortcut for debug panel (Ctrl+Shift+D)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.shiftKey && event.key === 'D') {
                event.preventDefault();
                toggleDebugPanel();
            }
        });

        // Hide receipt overlay
        function hideReceiptView() {
            Tracker.logRumiAction('Receipt view hidden');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<div class="popup-balance">BALANCE: 4,349 PTS</div><button class="settings-button" onclick="showSettingsView()">‚öô SETTINGS</button>';
            // }
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
        }

        function returnToEntryPoint() {
            const originalEntryPoint = appState.entryPoint; // Store before resetting
            Tracker.logRumiAction('Returning to indexing screen', { entryPoint: originalEntryPoint });
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Show the extension popup
            const popup = document.querySelector('.extension-popup');
            if (popup) {
                popup.style.display = 'flex';
            }
            
            // Hide the entry point panel
            const entryPointPanel = document.querySelector('.entry-point-panel');
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            
            // Show the user changes content button
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }
            
            // Reset to the indexing screen state (not started yet)
            appState.isIndexing = false;
            appState.entryPoint = originalEntryPoint; // Keep the same entry point
            
            // Update UI to show the indexing screen
            updateUI();
            
            // If we came from detection, restore the detected show
            if (originalEntryPoint === 'detection' && detectedShow) {
                appState.detectedShow = detectedShow;
                showDetectedShowUI(detectedShow.title);
            }
        }

        // --- Expandable Channel Section Logic ---
        function toggleChannelExpansion() {
            const expandedContainer = document.getElementById('channel-expanded-container');
            const expandHeader = document.getElementById('expand-channel-header');
            const expandText = document.getElementById('expand-channel-text');
            const expandIcon = document.getElementById('expand-channel-icon');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Channel expansion elements not found');
                return;
            }
            
            // Mark this as a user-initiated change
            appState.userInitiatedChannelChange = true;
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '‚ñ≤';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '‚ñº';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // --- Expandable Channel Section Logic for Indexing View ---
        function toggleChannelExpansionIndexing() {
            const expandedContainer = document.getElementById('channel-expanded-container-indexing');
            const expandHeader = document.getElementById('expand-channel-header-indexing');
            const expandText = document.getElementById('expand-channel-text-indexing');
            const expandIcon = document.getElementById('expand-channel-icon-indexing');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Indexing channel expansion elements not found');
                return;
            }
            
            // Use the same state as the main channel expansion
            // Mark this as a user-initiated change
            appState.userInitiatedChannelChange = true;
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '‚ñ≤';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame-indexing');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '‚ñº';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Indexing channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // Debug function to check channel state
        function debugChannelState() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            
            console.log('=== Channel Debug Info ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Channel Expanded:', appState.channelExpanded);
            console.log('Expandable Section Display:', expandableSection ? expandableSection.style.display : 'NOT FOUND');
            console.log('Expanded Container Display:', expandedContainer ? expandedContainer.style.display : 'NOT FOUND');
            console.log('Channel Frame Src:', channelFrame ? channelFrame.src : 'NOT FOUND');
            
            // Try to access iframe content to see if genre channel is working
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    if (channelTitle) {
                        console.log('Genre Channel Title:', channelTitle.textContent);
                    } else {
                        console.log('Genre Channel Title: NOT FOUND');
                    }
                    
                    // Check if there's content in the program track
                    const programTrack = iframeDocument.getElementById('program-track');
                    if (programTrack) {
                        console.log('Program Track Children:', programTrack.children.length);
                        if (programTrack.children.length > 0) {
                            console.log('First Program Item:', programTrack.children[0].textContent);
                        }
                    } else {
                        console.log('Program Track: NOT FOUND');
                    }
                } catch (e) {
                    console.log('Cannot access iframe content (CORS or not loaded):', e.message);
                }
            }
            
            console.log('========================');
        }

        // Update UI based on current state (additions for expandable channel)
        function updateExpandableChannelUI() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            const expandText = document.getElementById('expand-channel-text');
            
            // Indexing view elements
            const expandableSectionIndexing = document.getElementById('expandable-channel-section-indexing');
            const expandedContainerIndexing = document.getElementById('channel-expanded-container-indexing');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            const expandTextIndexing = document.getElementById('expand-channel-text-indexing');
            
            if (!expandableSection || !expandedContainer || !channelFrame || !expandText) return;

            console.log('updateExpandableChannelUI called, entry point:', appState.entryPoint);

            // Only show expandable section if in entry point mode
            if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // MODAL FIX: Prevent iframe reset during active sessions unless explicitly needed
                // Only set the src if it's not already correct AND we're not in an active session
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                console.log('Current channel frame src:', currentSrc);
                
                // Check if we should avoid resetting the iframe
                const shouldAvoidReset = appState.isIndexing && !appState.userInitiatedChannelChange;
                
                if (currentSrc !== 'Genre-channel_v2.html' && !shouldAvoidReset) {
                    console.log('Changing channel frame src to Genre-channel_v2.html');
                    channelFrame.src = 'Genre-channel_v2.html';
                    console.log('Channel frame src after change:', channelFrame.src);
                    if (channelFrameIndexing) {
                        console.log('Changing indexing channel frame src to Genre-channel_v2.html');
                        channelFrameIndexing.src = 'Genre-channel_v2.html';
                        console.log('Indexing channel frame src after change:', channelFrameIndexing.src);
                    }
                    console.log('Detection mode: Set channel to Genre-channel_v2.html');
                    
                    // Check if iframe loads after a delay
                    setTimeout(() => {
                        console.log('Checking iframe src after 2 seconds:', channelFrame.src);
                        if (channelFrameIndexing) {
                            console.log('Checking indexing iframe src after 2 seconds:', channelFrameIndexing.src);
                        }
                    }, 2000);
                } else if (shouldAvoidReset) {
                    console.log('üö´ Preventing iframe reset during active session (modal protection)');
                } else {
                    console.log('Channel frame already pointing to Genre-channel_v2.html');
                }
            } else if (appState.entryPoint === 'automode') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // MODAL FIX: Apply same protection for automode
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                const shouldAvoidReset = appState.isIndexing && !appState.userInitiatedChannelChange;
                
                if (currentSrc !== 'rumi-channel.html' && !shouldAvoidReset) {
                    channelFrame.src = 'rumi-channel.html';
                    if (channelFrameIndexing) channelFrameIndexing.src = 'rumi-channel.html';
                    console.log('Automode: Set channel to rumi-channel.html');
                } else if (shouldAvoidReset) {
                    console.log('üö´ Preventing iframe reset during active session (modal protection - automode)');
                }
            } else {
                expandableSection.style.display = 'none';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'none';
            }
            
            // Synchronize expansion state between both views
            if (expandedContainerIndexing) {
                expandedContainerIndexing.style.display = expandedContainer.style.display;
            }
            
            // Reset the user-initiated flag after processing
            if (appState.userInitiatedChannelChange) {
                appState.userInitiatedChannelChange = false;
            }
            
            // Debug the channel state
            debugChannelState();
        }

        // Patch updateUI to call updateExpandableChannelUI
        const _originalUpdateUI = updateUI;
        updateUI = function() {
            _originalUpdateUI.apply(this, arguments);
            updateExpandableChannelUI();
        };
        // Call on load
        document.addEventListener('DOMContentLoaded', function() {
            updateExpandableChannelUI();
        });

        function checkGenreChannelContent() {
            console.log('=== Checking Genre Channel Content ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    
                    // Check for genre channel specific elements
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    console.log('Channel title element:', channelTitle ? channelTitle.textContent : 'NOT FOUND');
                    
                    const programTrack = iframeDocument.getElementById('program-track');
                    console.log('Program track element:', programTrack ? 'FOUND' : 'NOT FOUND');
                    
                    if (programTrack) {
                        console.log('Program track children count:', programTrack.children.length);
                        for (let i = 0; i < Math.min(3, programTrack.children.length); i++) {
                            const child = programTrack.children[i];
                            console.log(`Program item ${i + 1}:`, child.textContent.trim());
                        }
                    }
                    
                    // Check for genre dropdown
                    const genreDropdown = iframeDocument.getElementById('genre-select');
                    console.log('Genre dropdown:', genreDropdown ? genreDropdown.value : 'NOT FOUND');
                    
                    // Check for any error messages or loading states
                    const errorElements = iframeDocument.querySelectorAll('.error, .loading, .status');
                    if (errorElements.length > 0) {
                        console.log('Error/status elements found:');
                        errorElements.forEach(el => console.log('-', el.textContent));
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            }
            
            console.log('=== End Genre Channel Check ===');
        }

        // Debug function to test Planet Earth II detection specifically
        function testPlanetEarthDetection() {
            console.log('=== Testing Planet Earth II Detection ===');
            
            // Set the entry point to detection mode so the genre channel gets loaded
            appState.entryPoint = 'detection';
            console.log('Set entry point to detection mode');
            
            const planetEarthShow = {
                title: 'Planet Earth II',
                genre: 'Documentary',
                service: 'DISCOVERY+',
                season: 'S1',
                episode: 'E1'
            };
            
            console.log('Sending Planet Earth II detection:', planetEarthShow);
            
            // Update the UI to load the genre channel first
            updateExpandableChannelUI();
            
            // Wait for the channel to load, then send the detection
            setTimeout(() => {
                // Check if the channel loaded correctly before sending the message
                checkGenreChannelLoaded();
                
                // Send the show detection
                sendShowDetection(planetEarthShow);
                
                // Check the channel content after a delay
                setTimeout(() => {
                    console.log('Checking channel content after Planet Earth II detection...');
                    checkGenreChannelContent();
                }, 2000);
            }, 2000); // Increased delay to ensure channel loads
        }

        // Simple test to verify message passing to genre channel
        function testMessagePassing() {
            console.log('=== Testing Message Passing ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            
            // Send a simple test message
            const testMessage = {
                type: 'test-message',
                payload: { test: 'Hello from main window' }
            };
            
            console.log('Sending test message:', testMessage);
            
            if (channelFrame.contentWindow) {
                try {
                    channelFrame.contentWindow.postMessage(testMessage, '*');
                    console.log('Test message sent successfully');
                } catch (e) {
                    console.error('Error sending test message:', e);
                }
            } else {
                console.log('Channel frame not ready');
            }
        }

        // Function to check if genre channel is actually loaded
        function checkGenreChannelLoaded() {
            console.log('=== Checking Genre Channel Loaded ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    console.log('Iframe document readyState:', iframeDocument.readyState);
                    
                    // Check if it's actually the genre channel
                    if (iframeDocument.title === 'Rumi Genre Channel') {
                        console.log('‚úÖ Genre channel is loaded correctly');
                    } else {
                        console.log('‚ùå Wrong channel loaded:', iframeDocument.title);
                    }
                    
                    // Try to access a genre channel specific element
                    const genreSelect = iframeDocument.getElementById('genre-select');
                    if (genreSelect) {
                        console.log('‚úÖ Genre select element found');
                    } else {
                        console.log('‚ùå Genre select element not found');
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            } else {
                console.log('‚ùå Channel frame not ready');
            }
        }

        // Expandable sections functionality
        function expandSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('expanded');
            }
        }

        function collapseSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.remove('expanded');
            }
        }

        function collapseAllSections() {
            const sections = document.querySelectorAll('.expandable-section');
            sections.forEach(section => {
                section.classList.remove('expanded');
            });
        }

        // Auto-expand sections based on state
        function autoExpandSections(state) {
            // Collapse all sections first
            collapseAllSections();
            
            // Auto-expand based on state
            switch(state) {
                case 'system-error':
                case 'network-error':
                case 'browser-error':
                    expandSection('error-details-section');
                    break;
                case 'user-error':
                case 'speed-error':
                case 'language-error':
                case 'warning':
                case 'show-interrupt':
                    expandSection('warning-details-section');
                    break;
                case 'settings':
                    expandSection('settings-panel-section');
                    break;
                case 'indexing-paused':
                    // Don't expand any sections in paused state
                    break;
                default:
                    // Don't expand any sections for other states
                    break;
            }
        }

        // New Error Testing Functions
        function testSpeedError() {
            setErrorState('speed-error');
            updateMessageArea('speed-error');
            autoExpandSections('speed-error');
            Tracker.logRumiAction('SPEED_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSystemError() {
            setErrorState('system-error');
            updateMessageArea('system-error');
            autoExpandSections('system-error');
            Tracker.logRumiAction('SYSTEM_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testNetworkError() {
            setErrorState('network-error');
            updateMessageArea('network-error');
            autoExpandSections('network-error');
            Tracker.logRumiAction('NETWORK_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testBrowserError() {
            setErrorState('browser-error');
            updateMessageArea('browser-error');
            autoExpandSections('browser-error');
            Tracker.logRumiAction('BROWSER_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSettings() {
            setErrorState('settings');
            updateMessageArea('settings');
            autoExpandSections('settings');
            Tracker.logRumiAction('SETTINGS_PANEL_ACTIVATED', { timestamp: Date.now() });
        }

        function testIndexingPaused() {
            setErrorState('indexing-paused');
            updateMessageArea('indexing-paused');
            autoExpandSections('indexing-paused');
            Tracker.logRumiAction('INDEXING_PAUSED_ACTIVATED', { timestamp: Date.now() });
        }

        function testLanguageError() {
            setErrorState('language-error');
            updateMessageArea('language-error');
            autoExpandSections('language-error');
            Tracker.logRumiAction('LANGUAGE_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testShowInterrupt() {
            console.log('testShowInterrupt called');
            setErrorState('show-interrupt');
            updateMessageArea('show-interrupt');
            autoExpandSections('show-interrupt');
            
            // Ensure content info is populated after a longer delay to allow DOM to fully update
            setTimeout(() => {
                console.log('Attempting to populate content after delay');
                populateInterruptContentInfo();
                
                // Additional debugging to check visibility
                setTimeout(() => {
                    const contentElement = document.getElementById('interrupt-content-info');
                    const warningSection = document.getElementById('warning-details-section');
                    console.log('Content element after population:', contentElement);
                    console.log('Warning section:', warningSection);
                    console.log('Warning section display:', warningSection?.style.display);
                    console.log('Content element innerHTML:', contentElement?.innerHTML);
                    console.log('Content element computed style:', window.getComputedStyle(contentElement));
                }, 100);
            }, 200);
            
            Tracker.logRumiAction('SHOW_INTERRUPT_ACTIVATED', { timestamp: Date.now() });
        }

        function endSession() {
            // Clear any error states
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'fatal_error';
            
            // Log the session end action
            Tracker.logRumiAction('SESSION_ENDED_FATAL_ERROR', { 
                timestamp: Date.now(),
                reason: 'fatal_error'
            });
            
            // Navigate to receipt view
            showReceiptView();
            
            console.log('Session ended due to fatal error - navigating to receipt view');
        }

        // Pause indexing (called when errors occur)
        function pauseIndexing() {
            if (appState.isPaused) return; // Already paused
            
            appState.isPaused = true;
            appState.pauseStartTime = Date.now();
            
            // Add paused class to nokia-content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.classList.add('paused');
            }
            
            // Pause all intervals and animations
            if (pointAccrualInterval) {
                clearInterval(pointAccrualInterval);
                pointAccrualInterval = null;
            }
            if (indexingTimerInterval) {
                clearInterval(indexingTimerInterval);
                indexingTimerInterval = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            Tracker.logRumiAction('INDEXING_PAUSED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings
            });
            
            console.log('Indexing paused');
        }

        // Resume indexing (called when errors are resolved)
        function resumeIndexing() {
            if (!appState.isPaused) return; // Not paused
            
            // Calculate pause duration
            if (appState.pauseStartTime) {
                const pauseTime = Date.now() - appState.pauseStartTime;
                appState.pauseDuration += pauseTime;
                appState.pauseStartTime = null;
            }
            
            appState.isPaused = false;
            
            // Remove paused class from nokia-content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.classList.remove('paused');
            }
            
            // Resume intervals and animations
            startPointsEarning();
            
            Tracker.logRumiAction('INDEXING_RESUMED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings,
                totalPauseDuration: appState.pauseDuration
            });
            
            console.log('Indexing resumed');
        }

        // Enhanced message area update function
        function updateMessageArea(state) {
            const messageArea = document.querySelector('.message-area');
            const messageText = document.getElementById('message-summary-text');
            const errorDetails = document.getElementById('error-details');
            const errorDetailsContent = document.getElementById('error-details-content');
            const warningDetailsContent = document.getElementById('warning-details-content');
            const settingsPanelContent = document.getElementById('settings-panel-content');

            // Remove all error classes
            messageArea.classList.remove('error', 'warning', 'info');
            messageArea.classList.remove('collapsed', 'expanded');

            switch(state) {
                case 'user-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '‚ö†Ô∏è VOLUME CHANGED - PLEASE RETURN VOLUME TO 100% TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - VOLUME DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Volume level has been detected below 100%. Rumi requires maximum volume for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Use your system volume controls<br>
                                2. Or use the volume slider below<br>
                                3. Ensure volume is at 100%<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Volume monitoring ensures optimal audio capture for content analysis.
                        </div>
                    `;
                    break;

                case 'speed-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '‚ö†Ô∏è SPEED CHANGED - SET VIDEO SPEED TO 1X TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - SPEED DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Video playback speed has been detected above 1x. Rumi requires normal speed for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Set video speed to 1x (normal)<br>
                                2. Use player speed controls<br>
                                3. Ensure speed is not accelerated<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Speed monitoring ensures accurate content timing and analysis.
                        </div>
                    `;
                    break;

                case 'system-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '‚ùå INDEXING FAILED - CONNECTION TO RUMI SERVERS LOST <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: SYS-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Connection to Rumi indexing servers has been lost. This may be due to network issues or server maintenance.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your internet connection<br>
                                2. Try refreshing the page<br>
                                3. Contact support if issue persists
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your progress has been saved. You can resume indexing once connection is restored.
                        </div>
                    `;
                    break;

                case 'network-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = 'üåê NETWORK ERROR - INTERNET CONNECTION REQUIRED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: NET-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Network connectivity has been lost. Rumi requires an active internet connection to function properly.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your Wi-Fi or ethernet connection<br>
                                2. Try disconnecting and reconnecting<br>
                                3. Restart your router if necessary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your session data is saved locally and will sync when connection is restored.
                        </div>
                    `;
                    break;

                case 'browser-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = 'üîß BROWSER ERROR - COMPATIBILITY ISSUE DETECTED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: BRW-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Your browser is not compatible with Rumi's indexing technology. Please use a supported browser.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">SUPPORTED BROWSERS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                ‚Ä¢ Google Chrome (version 90+)<br>
                                ‚Ä¢ Mozilla Firefox (version 88+)<br>
                                ‚Ä¢ Microsoft Edge (version 90+)<br>
                                ‚Ä¢ Safari (version 14+)
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Please update your browser or switch to a supported browser to continue indexing.
                        </div>
                    `;
                    break;

                case 'warning':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '‚ö†Ô∏è PLAYER MODIFIED - PLEASE USE THE CONTROLS BELOW INSTEAD OF PLAYER CONTROLS <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - PLAYER INTERACTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Direct interaction with the video player has been detected. Rumi requires controlled playback for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Avoid direct player interaction<br>
                                2. Use system controls if needed<br>
                                3. Let Rumi manage playback<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            This ensures accurate content tracking and optimal indexing performance.
                        </div>
                    `;
                    break;

                case 'settings':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '‚öôÔ∏è SETTINGS CONFIGURATION - INDEXING PAUSED DURING SETTINGS <button class="message-button" onclick="simResolveError()">CANCEL</button> <button class="message-button primary" onclick="saveSettings()">SAVE</button>';
                    errorDetails.innerHTML = '';
                    settingsPanelContent.innerHTML = `
                        <!-- Account Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">ACCOUNT</div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 10px;">
                                <span style="color: #888;">Username</span>
                                <span style="color: #fff;">CRYPTO_MAVEN</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 10px;">
                                <span style="color: #888;">Member Since</span>
                                <span style="color: #fff;">Dec 2023</span>
                            </div>
                            <button class="secondary-button" style="width: 100%; margin-top: 8px; background: #ff4444; color: #fff; border-color: #ff4444;">LOGOUT</button>
                        </div>

                        <!-- Preferences Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PREFERENCES</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Desktop Notifications</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-start Indexing</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Disabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Audio Settings Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">AUDIO SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Volume Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-resume on Volume Fix</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Playback Settings Section -->
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PLAYBACK SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Speed Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                        </div>

                        <div style="font-size: 10px; color: #888; font-style: italic; text-align: center;">
                            Settings will be applied immediately. Indexing will resume when you save and close.
                        </div>
                    `;
                    break;

                case 'indexing-paused':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '‚è∏Ô∏è INDEXING PAUSED - READY TO RESUME WHEN ERROR IS RESOLVED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    break;

                case 'language-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = 'üåç LANGUAGE ERROR - CONTENT LANGUAGE NOT SUPPORTED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - LANGUAGE DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Content language has been detected as Japanese. Rumi currently supports English content only for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">SUPPORTED LANGUAGES</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                ‚Ä¢ English (Primary)<br>
                                ‚Ä¢ Spanish (Beta)<br>
                                ‚Ä¢ French (Beta)<br>
                                ‚Ä¢ German (Beta)
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Switch to English content<br>
                                2. Or select a supported language<br>
                                3. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Note: Language detection is automatic. Indexing will resume once supported content is detected.
                        </div>
                    `;
                    break;

                case 'show-interrupt':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '<span style="color: #0088ff;">üîÑ SHOW INTERRUPT - DIFFERENT CONTENT DETECTED</span> <button class="inline-resume-button" onclick="confirmShowInterrupt()">CONTINUE INDEXING</button> <button class="inline-end-session-button" onclick="endSessionFromInterrupt()">GO TO RECEIPT</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">CONTENT CHANGE DETECTED</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                A different show or movie has been detected. You can continue indexing this new content for additional points.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">NEW CONTENT DETECTED</div>
                            <div id="interrupt-content-info" style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                <!-- Content info will be populated by JavaScript -->
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">YOUR OPTIONS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. <strong>Continue Indexing:</strong> Chain points for additional multiplier (+0.1)<br>
                                2. <strong>Go to Receipt:</strong> End session and view earnings summary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Continuing will add the new content to your session and increase your multiplier bonus.
                        </div>
                    `;
                    // Populate the content info with random show data
                    // populateInterruptContentInfo(); // Commented out - will be called with delay
                    break;

                default:
                    // Normal state - collapse all sections
                    messageText.textContent = 'System operational - Daily bonus in 2h 34m';
                    errorDetails.innerHTML = '';
                    collapseAllSections();
                    break;
            }
        }

        // Helper functions for error recovery
        function saveSettings() {
            clearErrorState();
            Tracker.logRumiAction('SETTINGS_SAVED', { timestamp: Date.now() });
        }

        // Universal error resolution function
        function simResolveError() {
            // Reset simulated volume level if this was a volume error
            if (appState.errorState === 'volume') {
                appState.volumeLevel = 100;
            }
            
            // Clear error state
            clearErrorState();
            
            // Resume indexing if it was paused
            if (appState.isPaused) {
                resumeIndexing();
            }
            
            Tracker.logRumiAction('ERROR_RESOLVED', { 
                timestamp: Date.now(),
                previousError: appState.errorState
            });
            
            console.log('Error resolved, indexing resumed');
        }

        // Helper function to populate interrupt content info with random show data
        function populateInterruptContentInfo() {
            console.log('populateInterruptContentInfo called');
            const contentInfoElement = document.getElementById('interrupt-content-info');
            console.log('Content info element found:', contentInfoElement);
            
            if (!contentInfoElement) {
                console.error('interrupt-content-info element not found');
                return;
            }

            // Get a random show that's different from the current one
            const currentShow = appState.detectedShow;
            console.log('Current show:', currentShow);
            const newShow = availableShows.find(s => s.title !== currentShow?.title) || availableShows[0];
            console.log('New show selected:', newShow);
            
            // Store the new show for later use
            appState.interruptNewShow = newShow;

            const contentHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #fff; font-weight: 600;">${newShow.title}</span>
                    <span style="color: #888;">${newShow.service}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Genre:</span>
                    <span style="color: #fff;">${newShow.genre}</span>
                </div>
                ${newShow.season !== 'N/A' ? `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Episode:</span>
                    <span style="color: #fff;">${newShow.season} ${newShow.episode}</span>
                </div>
                ` : `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Year:</span>
                    <span style="color: #fff;">${newShow.year || 'N/A'}</span>
                </div>
                `}
            `;
            
            console.log('Setting content HTML:', contentHTML);
            contentInfoElement.innerHTML = contentHTML;
            console.log('Content populated successfully');
        }

        // Function to handle confirming show interrupt and continuing indexing
        function confirmShowInterrupt() {
            const newShow = appState.interruptNewShow;
            if (!newShow) {
                console.error('No new show data available for interrupt');
                return;
            }

            // Store the original show for receipt display
            appState.originalShow = appState.detectedShow;
            
            // Record the timestamp when the interrupt occurred
            appState.showInterruptTimestamp = Date.now();

            // Update the detected show to the new one
            appState.detectedShow = newShow;
            detectedShow = newShow;

            // Add chain bonus to multiplier
            if (appState.currentMultiplier) {
                appState.currentMultiplier += 0.1;
            } else {
                appState.currentMultiplier = 1.1;
            }

            // Clear the interrupt state
            clearErrorState();

            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_CONFIRMED', { 
                timestamp: Date.now(),
                newShow: newShow.title,
                newMultiplier: appState.currentMultiplier,
                interruptTimestamp: appState.showInterruptTimestamp
            });

            // Resume indexing with the new show
            resumeIndexing();

            console.log(`Show interrupt confirmed. Continuing with ${newShow.title}. New multiplier: ${appState.currentMultiplier}`);
        }

        // NEW: Enhanced Multiplier Progression System
        function calculateEnhancedMultiplier(sessionData) {
            const baseMultiplier = 1.0;
            let enhancedMultiplier = baseMultiplier;
            let multiplierReasons = [];
            
            // Time-based progression (every 5 minutes)
            const sessionMinutes = sessionData.sessionTime / 60;
            const timeBonus = Math.floor(sessionMinutes / 5) * 0.1;
            if (timeBonus > 0) {
                enhancedMultiplier += timeBonus;
                multiplierReasons.push(`Time bonus: +${timeBonus.toFixed(1)}x (${Math.floor(sessionMinutes / 5)} √ó 5min)`);
            }
            
            // Show transition bonus (escalating for multiple transitions)
            if (sessionData.numberOfShows > 1) {
                const transitionCount = sessionData.numberOfShows - 1;
                // Escalating bonus: 0.15x for 1st, 0.20x for 2nd, 0.25x for 3rd+
                let transitionBonus = 0;
                for (let i = 1; i <= transitionCount; i++) {
                    if (i === 1) transitionBonus += 0.15;
                    else if (i === 2) transitionBonus += 0.20;
                    else transitionBonus += 0.25;
                }
                enhancedMultiplier += transitionBonus;
                multiplierReasons.push(`Transition bonus: +${transitionBonus.toFixed(1)}x (${transitionCount} transitions, escalating)`);
            }
            
            // Content variety bonus (different types of content)
            const contentTypes = new Set();
            if (window.transitionSystem && window.transitionSystem.state && window.transitionSystem.state.playedContent) {
                const playedContent = window.transitionSystem.state.playedContent;
                playedContent.forEach(content => {
                    if (content.type) contentTypes.add(content.type);
                    if (content.service) contentTypes.add(content.service);
                });
                
                if (contentTypes.size > 2) {
                    const varietyBonus = (contentTypes.size - 2) * 0.05;
                    enhancedMultiplier += varietyBonus;
                    multiplierReasons.push(`Variety bonus: +${varietyBonus.toFixed(1)}x (${contentTypes.size} types)`);
                }
            }
            
            // Quality session bonus (long sessions with multiple shows)
            if (sessionMinutes > 15 && sessionData.numberOfShows > 2) {
                const qualityBonus = 0.2;
                enhancedMultiplier += qualityBonus;
                multiplierReasons.push(`Quality session: +${qualityBonus.toFixed(1)}x`);
            }
            
            // Cap at 3.0x maximum
            enhancedMultiplier = Math.min(enhancedMultiplier, 3.0);
            
            return {
                multiplier: enhancedMultiplier,
                reasons: multiplierReasons,
                improvement: enhancedMultiplier - baseMultiplier
            };
        }

        // NEW: Apply enhanced multiplier during session
        function applyEnhancedMultiplier() {
            if (!window.transitionSystem) return;
            
            const sessionData = window.transitionSystem.getCurrentState();
            const enhanced = calculateEnhancedMultiplier(sessionData);
            
            // Only update if there's an improvement
            if (enhanced.improvement > 0.05) { // 0.05x threshold
                const oldMultiplier = appState.currentMultiplier;
                appState.currentMultiplier = enhanced.multiplier;
                
                console.log(`Enhanced multiplier applied: ${oldMultiplier.toFixed(1)}x ‚Üí ${enhanced.multiplier.toFixed(1)}x`);
                enhanced.reasons.forEach(reason => console.log(`  ${reason}`));
                
                // Update transition system multiplier
                if (window.transitionSystem.updateMultiplier) {
                    window.transitionSystem.updateMultiplier(enhanced.multiplier);
                }
                
                // Update UI
                updateUI();
                
                // Log the enhancement
                Tracker.logRumiAction('Enhanced multiplier applied', {
                    oldMultiplier: oldMultiplier,
                    newMultiplier: enhanced.multiplier,
                    improvement: enhanced.improvement,
                    reasons: enhanced.reasons
                });
            }
        }

        // Function to handle ending session from interrupt
        function endSessionFromInterrupt() {
            // Clear the interrupt state
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'show_interrupt_declined';
            
            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_DECLINED', { 
                timestamp: Date.now(),
                reason: 'user_declined_new_content'
            });
            
            // Calculate session duration and earnings
            const sessionDuration = appState.isIndexing ? Date.now() - appState.indexingStartTime : 0;
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Navigate to receipt view
            showReceiptView(sessionDuration, appState.currentMode || 'detection', finalMultiplier);
            
            console.log('Session ended due to show interrupt decline - navigating to receipt view');
        }

        // Helper function to get related content based on genre (original for backward compatibility)
        function getRelatedContent(genre, remainingTime) {
            const relatedShows = {
                'Drama': [
                    { title: 'Succession S4:E3', duration: 58 },
                    { title: 'The Crown S6:E8', duration: 52 },
                    { title: 'Mad Men S7:E14', duration: 47 },
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'The Wire S2:E12', duration: 60 },
                    { title: 'Better Call Saul S6:E13', duration: 45 }
                ],
                'Comedy': [
                    { title: 'The Office S3:E20', duration: 22 },
                    { title: 'Ted Lasso S3:E12', duration: 45 },
                    { title: 'Fleabag S2:E6', duration: 28 },
                    { title: 'Parks and Recreation S4:E22', duration: 22 },
                    { title: 'Brooklyn Nine-Nine S5:E23', duration: 22 },
                    { title: 'The Good Place S4:E13', duration: 22 }
                ],
                'Sci-Fi': [
                    { title: 'Stranger Things S4:E9', duration: 51 },
                    { title: 'Black Mirror S6:E3', duration: 45 },
                    { title: 'The Expanse S6:E6', duration: 42 },
                    { title: 'Westworld S3:E8', duration: 58 },
                    { title: 'Altered Carbon S2:E8', duration: 45 },
                    { title: 'The Mandalorian S3:E8', duration: 35 }
                ],
                'Thriller': [
                    { title: 'Breaking Bad S5:E16', duration: 47 },
                    { title: 'Killing Eve S4:E8', duration: 44 },
                    { title: 'Ozark S4:E14', duration: 60 },
                    { title: 'Mindhunter S2:E9', duration: 45 },
                    { title: 'True Detective S3:E8', duration: 58 },
                    { title: 'The Sinner S4:E8', duration: 45 }
                ]
            };
            
            const shows = relatedShows[genre] || relatedShows['Drama'];
            const content = [];
            let timeLeft = remainingTime;
            
            for (const show of shows) {
                if (timeLeft <= 0) break;
                const showTime = Math.min(show.duration, timeLeft);
                const showTimeSeconds = showTime * 60;
                const showPoints = Math.round((showTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                content.push({
                    title: show.title,
                    duration: formatTime(showTime),
                    points: showPoints.toFixed(1)
                });
                timeLeft -= showTime;
            }
            
            return content;
        }

        // Helper function to get automode content based on bucket (original for backward compatibility)
        function getAutomodeContent(bucket, sessionDuration, baseRate, multiplier) {
            const bucketContent = {
                'Content Intelligence': [
                    { title: 'Breaking Bad Pilot Scene Analysis' },
                    { title: 'The Crown Opening Sequence Review' },
                    { title: 'Stranger Things Monster Reveal Assessment' },
                    { title: 'Mad Men Office Scene Analysis' },
                    { title: 'The Wire Street Scene Review' },
                    { title: 'Succession Board Meeting Assessment' },
                    { title: 'Black Mirror Tech Scene Analysis' },
                    { title: 'Game of Thrones Battle Scene Review' }
                ],
                'Scene Description pipeline': [
                    { title: 'Chernobyl Reactor Scene Review' },
                    { title: 'The Marvelous Mrs. Maisel Standup Analysis' },
                    { title: 'Killing Eve Chase Scene Assessment' },
                    { title: 'The Crown Diana Interview Analysis' },
                    { title: 'Stranger Things Eleven Powers Review' },
                    { title: 'Succession Logan Speech Assessment' },
                    { title: 'The Witcher Monster Hunt Analysis' },
                    { title: 'Better Call Saul Legal Maneuver Review' }
                ],
                'Story Tree': [
                    { title: 'Breaking Bad Season 1 Arc Summary' },
                    { title: 'The Crown Episode 3 Political Subplot' },
                    { title: 'Stranger Things Season 2 Development' },
                    { title: 'Mad Men Season 4 Opening Analysis' },
                    { title: 'The Wire Season 2 Setup Review' },
                    { title: 'Succession Power Struggle Assessment' },
                    { title: 'Black Mirror Episode Arc Analysis' },
                    { title: 'Game of Thrones Red Wedding Impact' }
                ],
                'Character Summaries': [
                    { title: 'Walter White Transformation Arc' },
                    { title: 'Tony Soprano Therapy Session Analysis' },
                    { title: 'Don Draper Identity Crisis Review' },
                    { title: 'Jimmy McGill Evolution Assessment' },
                    { title: 'Eleven Power Discovery Analysis' },
                    { title: 'Kendall Roy Ambition Review' },
                    { title: 'Fleabag Self-Destruction Assessment' },
                    { title: 'Ted Lasso Optimism Analysis' }
                ]
            };
            
            const content = bucketContent[bucket] || bucketContent['Content Intelligence'];
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of content) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1)
                });
                timeLeft -= itemTime;
            }
            
            return items;
        }

        // Helper function to get generic content with points calculation
        function getGenericContentWithPoints(sessionDuration, baseRate, multiplier) {
            const genericContent = [
                { title: 'Blade Runner 2029' },
                { title: 'Stranger Things S3:E1' },
                { title: 'The Witcher S2:E3' },
                { title: 'Breaking Bad Pilot' },
                { title: 'The Crown Opening' },
                { title: 'Black Mirror Episode' }
            ];
            
            const items = [];
            let timeLeft = sessionDuration;
            
            for (const item of genericContent) {
                if (timeLeft <= 0) break;
                // Generate random duration between 8 seconds and 2 minutes (120 seconds)
                const randomDuration = Math.floor(Math.random() * (120 - 8 + 1)) + 8;
                const itemTime = Math.min(randomDuration, timeLeft);
                const itemTimeSeconds = itemTime;
                const itemPoints = Math.round((itemTimeSeconds * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: item.title,
                    duration: formatTime(itemTime),
                    points: itemPoints.toFixed(1)
                });
                timeLeft -= itemTime;
            }
            
            return items;
        }

                // NEW: Toggle fast mode (behavior depends on entry point)
        function toggleFastMode() {
            // Check if indexing is active
            if (!appState.isIndexing) {
                console.log('Fast Mode: Please start an indexing session first');
                return;
            }
            
            // Check cooldown
            if (appState.debugSkipCooldown > 0) {
                console.log('Fast Mode: Still in cooldown');
                return;
            }

            // Determine fast mode behavior based on entry point
            if (appState.entryPoint === 'detection') {
                // Detection mode: Smart content navigation (requires transition system)
                if (!window.transitionSystem) {
                    console.log('Fast Mode: Transition system not available for detection mode');
                    return;
                }
                
                console.log('Fast Mode: Activating smart content navigation for detection mode...');
                
                // Set 5-second cooldown
                appState.debugSkipCooldown = 5;
                updateDebugButtonStates();

                // Initialize detection fast mode state
                if (!appState.fastMode) {
                    appState.fastMode = {
                        active: true,
                        mode: 'detection',
                        currentContentIndex: 0,
                        isInFinalSeconds: false,
                        contentStartTime: Date.now(),
                        normalSpeedBuffer: 4 // seconds to play at normal speed
                    };
                    
                    // Start smart navigation
                    startFastModeNavigation();
                    updateContentDisplay();
                    
                    console.log('Fast Mode: Activated! Will fast-forward through content, showing last 4 seconds of each piece.');
                } else {
                    // Deactivate fast mode
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                    console.log('Fast Mode: Deactivated');
                }
                
            } else if (appState.entryPoint === 'automode') {
                // Auto mode: 500x speed playback
                console.log('Fast Mode: Activating 500x speed for auto mode...');
                
                // Set 3-second cooldown
                appState.debugSkipCooldown = 3;
                updateDebugButtonStates();

                // Initialize auto mode fast mode state
                if (!appState.fastMode) {
                    appState.fastMode = {
                        active: true,
                        mode: 'automode',
                        speedMultiplier: 500,
                        originalSessionDuration: null
                    };
                    
                    // Start 500x speed playback
                    startAutoModeFastMode();
                    
                    console.log('Fast Mode: Activated! Playing at 500x speed.');
                } else {
                    // Deactivate fast mode
                    stopAutoModeFastMode();
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                    console.log('Fast Mode: Deactivated - returning to normal speed');
                }
            } else {
                console.log('Fast Mode: Unsupported entry point:', appState.entryPoint);
                return;
            }
            
            Tracker.logRumiAction('FAST_MODE_TOGGLED', { 
                timestamp: Date.now(),
                active: appState.fastMode?.active || false,
                mode: appState.fastMode?.mode || 'unknown',
                entryPoint: appState.entryPoint,
                currentShow: appState.detectedShow?.title || 'Unknown'
            });

            // Start cooldown countdown
            startDebugCooldown('skip');
        }

        // NEW: Auto mode fast mode - 500x speed playback
        function startAutoModeFastMode() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Starting 500x speed playback...');
            
            // Store original session duration for restoration
            appState.fastMode.originalSessionDuration = appState.sessionDuration;
            appState.fastMode.originalStartTime = appState.indexingStartTime;
            
            // Calculate accelerated session duration (500x faster)
            const originalDurationMs = appState.sessionDuration * 60 * 1000; // Convert to milliseconds
            const acceleratedDurationMs = originalDurationMs / appState.fastMode.speedMultiplier;
            
            console.log(`Auto Mode Fast Mode: Original session ${appState.sessionDuration} min, accelerated to ${(acceleratedDurationMs / 1000).toFixed(1)}s`);
            
            // Update session start time to simulate 500x speed
            const currentTime = Date.now();
            const elapsedTime = currentTime - appState.indexingStartTime;
            const acceleratedElapsedTime = elapsedTime * appState.fastMode.speedMultiplier;
            
            // Adjust start time so that elapsed time appears much longer
            appState.indexingStartTime = currentTime - acceleratedElapsedTime;
            
            // Set up completion timer
            const remainingTime = acceleratedDurationMs - (elapsedTime / appState.fastMode.speedMultiplier);
            
            if (remainingTime > 0) {
                console.log(`Auto Mode Fast Mode: Session will complete in ${(remainingTime / 1000).toFixed(1)}s`);
                
                appState.fastMode.completionTimer = setTimeout(() => {
                    if (appState.fastMode && appState.fastMode.active) {
                        completeAutoModeFastModeSession();
                    }
                }, remainingTime);
            } else {
                // Session should complete immediately
                console.log('Auto Mode Fast Mode: Session duration exceeded, completing immediately');
                setTimeout(() => completeAutoModeFastModeSession(), 100);
            }
        }

        // NEW: Stop auto mode fast mode
        function stopAutoModeFastMode() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Stopping 500x speed...');
            
            // Clear completion timer
            if (appState.fastMode.completionTimer) {
                clearTimeout(appState.fastMode.completionTimer);
                appState.fastMode.completionTimer = null;
            }
            
            // Restore original timing (calculate actual elapsed time at normal speed)
            if (appState.fastMode.originalStartTime) {
                const currentTime = Date.now();
                const acceleratedElapsedTime = currentTime - appState.indexingStartTime;
                const normalElapsedTime = acceleratedElapsedTime / appState.fastMode.speedMultiplier;
                
                // Set start time to reflect normal elapsed time
                appState.indexingStartTime = currentTime - normalElapsedTime;
                
                console.log(`Auto Mode Fast Mode: Restored to normal timing, actual elapsed: ${(normalElapsedTime / 1000 / 60).toFixed(1)} min`);
            }
        }

        // NEW: Complete auto mode fast mode session
        function completeAutoModeFastModeSession() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Session completed - showing receipt...');
            
            // Deactivate fast mode
            appState.fastMode.active = false;
            
            // Calculate final session stats
            const sessionDurationMinutes = appState.sessionDuration || 45;
            const totalPoints = sessionDurationMinutes * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1);
            
            // Create receipt
            const receipt = {
                sessionId: `automode_fast_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDurationMinutes,
                numberOfShows: 1, // Auto mode typically has one continuous session
                playedContent: appState.playedContent || [],
                mode: 'automode',
                fastMode: true,
                speedMultiplier: 500
            };
            
            // Stop indexing
            stopIndexing();
            
            // Show receipt
            showSessionReceipt(receipt);
            
            // Clean up fast mode state
            appState.fastMode = null;
            
            console.log('Auto Mode Fast Mode: Receipt displayed, session complete');
        }

        // NEW: Smart fast mode navigation system
        function startFastModeNavigation() {
            if (!appState.fastMode || !appState.fastMode.active) return;
            
            const currentShow = appState.detectedShow;
            if (!currentShow) return;
            
            const showDurationSeconds = (currentShow.duration || 22) * 60; // Convert minutes to seconds
            const normalSpeedBuffer = appState.fastMode.normalSpeedBuffer;
            
            console.log(`Fast Mode: Starting navigation for "${currentShow.title}" (${showDurationSeconds}s duration)`);
            
            // Immediately skip to 4 seconds before the end
            const skipToTime = showDurationSeconds - normalSpeedBuffer;
            
            // Update the content start time to simulate fast-forward
            const currentTime = Date.now();
            const elapsedTime = (currentTime - appState.indexingStartTime) / 1000;
            
            // Calculate how much time to "skip"
            const timeToSkip = skipToTime;
            
            // Update content item start time to simulate we've been watching for most of the duration
            appState.contentItemStartTime = elapsedTime - skipToTime;
            
            console.log(`Fast Mode: Skipping to ${skipToTime}s (${normalSpeedBuffer}s from end)`);
            console.log(`Fast Mode: Content will transition in ${normalSpeedBuffer} seconds`);
            
            // Set flag that we're in the final seconds
            appState.fastMode.isInFinalSeconds = true;
            
            // Update content display to show current state
            triggerContentDisplayUpdate('fast_mode_transition');
            
            // Schedule the transition to next content
                    setTimeout(() => {
                if (appState.fastMode && appState.fastMode.active) {
                    transitionToNextContentInFastMode();
                }
            }, normalSpeedBuffer * 1000);
        }

                // NEW: Handle transition to next content in fast mode
        function transitionToNextContentInFastMode() {
            if (!appState.fastMode || !appState.fastMode.active) return;
            
            console.log('Fast Mode: Transitioning to next content...');
            
            // Initialize fast mode content index if not set
            if (typeof appState.fastMode.currentContentIndex === 'undefined') {
                appState.fastMode.currentContentIndex = 0;
            }
            
            // Get next show from channel using fast mode index
            getNextShowFromChannelForFastMode().then(nextShow => {
                if (nextShow && appState.fastMode && appState.fastMode.active) {
                    console.log(`Fast Mode: Transitioning to "${nextShow.title}" (index ${appState.fastMode.currentContentIndex + 1})`);
                    
                    // Increment fast mode index BEFORE transition
                    appState.fastMode.currentContentIndex++;
                    
                    // Use transition system to switch shows
                    transitionToShowWithSystem(nextShow).then(() => {
                        appState.fastMode.isInFinalSeconds = false;
                        
                        // Update visual content display and all UI elements
                        triggerContentDisplayUpdate('fast_mode_transition');
                        updateUI();
                        updatePointsDisplay();
                        
                        // Start navigation for the new content after a brief delay
                        setTimeout(() => {
                            if (appState.fastMode && appState.fastMode.active) {
                                startFastModeNavigation();
                            }
                        }, 1000); // 1 second delay to let transition complete
                    });
                } else {
                    console.log('Fast Mode: No next content available - completing session');
                    
                    // Deactivate fast mode
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                    
                    // Complete the session and show receipt
                    if (window.transitionSystem) {
                        console.log('Fast Mode: Completing session with transition system...');
                        completeSessionWithTransitionSystem();
            } else {
                        console.log('Fast Mode: Completing session normally...');
                        // Fallback to regular session completion
                        stopIndexing();
                        
                        // Show receipt if we have session data
                        if (appState.sessionEarnings > 0) {
                            const receipt = {
                                sessionId: `session_${Date.now()}`,
                                totalPoints: appState.sessionEarnings,
                                totalTimeIndexed: Math.floor((Date.now() - appState.indexingStartTime) / 60000),
                                numberOfShows: (appState.transitionCount || 0) + 1,
                                playedContent: appState.playedContent || []
                            };
                            showSessionReceipt(receipt);
                        }
                    }
                    
                    console.log('Fast Mode: Session completed - showing final receipt');
                }
            }).catch(error => {
                console.error('Fast Mode: Error getting next content:', error);
                
                // On error, also complete the session
                console.log('Fast Mode: Error occurred - completing session');
                
                // Safely clear fast mode state
                if (appState.fastMode) {
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                }
                
                if (window.transitionSystem) {
                    completeSessionWithTransitionSystem();
                } else {
                    stopIndexing();
                }
            });
        }

        // NEW: Debug function to skip to tomorrow (move pending points to lifetime)
        function debugSkipToTomorrow() {
            // Check cooldown
            if (appState.debugTomorrowCooldown > 0) {
                console.log('Debug skip to tomorrow: Still in cooldown');
                return;
            }

            console.log('Debug skip to tomorrow: Executing...');

            // Set 10-second cooldown
            appState.debugTomorrowCooldown = 10;
            updateDebugButtonStates();

            // Move pending points to lifetime points
            const pendingPoints = appState.totalPendingPoints;
            appState.pointsEarned += pendingPoints;
            appState.totalPendingPoints = 0;

            // Update points display
            updatePointsDisplay();

            console.log(`Debug skip to tomorrow: Moved ${pendingPoints.toFixed(2)} points to lifetime`);
            Tracker.logRumiAction('DEBUG_SKIP_TO_TOMORROW', { 
                pointsMoved: pendingPoints,
                newLifetimePoints: appState.pointsEarned
            });

            // Start cooldown countdown
            startDebugCooldown('tomorrow');
        }

        // NEW: Function to update debug button states based on cooldowns and error states
        function updateDebugButtonStates() {
            const fastModeBtn = document.getElementById('debug-fast-mode-btn');
            const skipTomorrowBtn = document.getElementById('debug-skip-tomorrow-btn');

            if (fastModeBtn) {
                // Auto-initialize transition system if indexing and in detection mode
                if (appState.isIndexing && appState.entryPoint === 'detection' && !window.transitionSystem) {
                    console.log('Auto-initializing transition system for Fast Mode...');
                    initializeTransitionSystem();
                }
                
                // Debug the button state
                console.log('Fast Mode Button Debug:', {
                    isIndexing: appState.isIndexing,
                    entryPoint: appState.entryPoint,
                    transitionSystem: !!window.transitionSystem,
                    debugSkipCooldown: appState.debugSkipCooldown
                });
                
                if (!appState.isIndexing || (appState.entryPoint === 'detection' && !window.transitionSystem)) {
                    console.log('Fast Mode Button: DISABLED - Missing requirements');
                    fastModeBtn.disabled = true;
                    fastModeBtn.classList.add('cooldown');
                    fastModeBtn.textContent = appState.entryPoint === 'automode' ? 'Fast Mode (500x)' : 'Fast Mode (4s)';
                } else if (appState.debugSkipCooldown > 0) {
                    console.log('Fast Mode Button: DISABLED - Cooldown active');
                    fastModeBtn.disabled = true;
                    fastModeBtn.classList.add('cooldown');
                    fastModeBtn.textContent = `Fast Mode (${appState.debugSkipCooldown}s)`;
                } else {
                    console.log('Fast Mode Button: ENABLED - All conditions met');
                    fastModeBtn.disabled = false;
                    fastModeBtn.classList.remove('cooldown');
                    
                    // Set button text based on entry point and current state
                    const isActive = appState.fastMode && appState.fastMode.active;
                    if (isActive) {
                        fastModeBtn.textContent = appState.fastMode.mode === 'automode' ? 'Fast Mode (500x)' : 'Fast Mode (ON)';
                    } else {
                        fastModeBtn.textContent = appState.entryPoint === 'automode' ? 'Fast Mode (500x)' : 'Fast Mode (4s)';
                    }
                    
                    // Force remove any blocking styles
                    fastModeBtn.style.pointerEvents = 'auto';
                    fastModeBtn.style.cursor = 'pointer';
                }
            }

            if (skipTomorrowBtn) {
                if (appState.debugTomorrowCooldown > 0) {
                    skipTomorrowBtn.disabled = true;
                    skipTomorrowBtn.classList.add('cooldown');
                    skipTomorrowBtn.textContent = `Skip to Tomorrow (${appState.debugTomorrowCooldown}s)`;
                } else {
                    skipTomorrowBtn.disabled = false;
                    skipTomorrowBtn.classList.remove('cooldown');
                    skipTomorrowBtn.textContent = 'Skip to Tomorrow';
                }
            }
        }

        // NEW: Function to handle debug button cooldowns
        function startDebugCooldown(type) {
            const cooldownInterval = setInterval(() => {
                if (type === 'skip') {
                    appState.debugSkipCooldown--;
                    if (appState.debugSkipCooldown <= 0) {
                        clearInterval(cooldownInterval);
                    }
                } else if (type === 'tomorrow') {
                    appState.debugTomorrowCooldown--;
                    if (appState.debugTomorrowCooldown <= 0) {
                        clearInterval(cooldownInterval);
                    }
                }
                updateDebugButtonStates();
            }, 1000);
        }

        // NEW: Function to show user choice prompt
        function showUserChoicePrompt() {
            appState.showChoicePrompt = true;
            
            // Choose colors based on entry point
            const primaryColor = (appState.entryPoint === 'automode') ? '#ffff00' : '#00ff41';
            
            // Create and show the choice prompt overlay
            const promptHTML = `
                <div id="user-choice-prompt" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                ">
                    <div style="
                        background: #1a1a1a;
                        border: 2px solid ${primaryColor};
                        border-radius: 12px;
                        padding: 24px;
                        max-width: 400px;
                        text-align: center;
                    ">
                        <div style="
                            font-size: 16px;
                            color: ${primaryColor};
                            font-weight: 700;
                            margin-bottom: 16px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">
                            Choose Your Next Content
                        </div>
                        <div style="
                            font-size: 12px;
                            color: #ccc;
                            margin-bottom: 20px;
                            line-height: 1.4;
                        ">
                            <strong>Continue with Rumi:</strong> Go to the Genre Channel where Rumi curates content based on your interests and session goals. You can let it play continuously or switch back to direct recommendations anytime.
                        </div>
                        <div style="
                            font-size: 12px;
                            color: #ccc;
                            margin-bottom: 20px;
                            line-height: 1.4;
                        ">
                            <strong>Let Streamer Choose:</strong> Give control back to the streamer to select the next piece of content.
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button onclick="chooseRumiControl()" style="
                                flex: 1;
                                background: ${primaryColor};
                                color: #000;
                                border: none;
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 12px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                            ">
                                Continue with Rumi
                            </button>
                            <button onclick="chooseStreamerControl()" style="
                                flex: 1;
                                background: #222;
                                color: ${primaryColor};
                                border: 2px solid ${primaryColor};
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 12px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                            ">
                                Let Streamer Choose
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', promptHTML);
        }

        // NEW: Function to handle Rumi control choice
        function chooseRumiControl() {
            appState.userChoice = 'rumi';
            appState.showChoicePrompt = false;
            
            // MODAL FIX: Mark this as a user-initiated channel change
            appState.userInitiatedChannelChange = true;
            console.log('üéØ Modal button clicked - marking as user-initiated channel change');
            
            // Remove the prompt
            const prompt = document.getElementById('user-choice-prompt');
            if (prompt) {
                prompt.remove();
            }

            // Go directly to genre channel and auto-start next content
            showGenreChannel();
            Tracker.logRumiAction('USER_CHOICE_MADE', { choice: 'rumi', action: 'genre_channel' });
        }

        // NEW: Function to handle streamer control choice
        function chooseStreamerControl() {
            appState.userChoice = 'streamer';
            appState.showChoicePrompt = false;
            
            // MODAL FIX: Mark this as a user-initiated action
            appState.userInitiatedChannelChange = true;
            console.log('üéØ Modal button clicked - marking as user-initiated action');
            
            // Remove the prompt
            const prompt = document.getElementById('user-choice-prompt');
            if (prompt) {
                prompt.remove();
            }
            
            // Trigger a random piece of content to start (like the "show interrupt" debug button)
            simulateShowChange();
            
            Tracker.logRumiAction('USER_CHOICE_MADE', { choice: 'streamer', action: 'show_interrupt' });
        }

        // Add debounce mechanism for channel expansion updates
        let channelExpansionTimeout = null;
        let lastChannelExpansionState = false;

        // NEW: Function to show genre channel and auto-start next content
        function showGenreChannel() {
            console.log('Showing genre channel for Rumi recommendations');
            
            // Don't stop indexing - continue the session
            // Just switch to genre channel view while keeping the session active
            currentChannel = 'genre';
            
            // Use debounced channel expansion to prevent rapid toggling
            setChannelExpansionState(true);
            
            // Update UI to show genre channel
            updateUI();
            
            // Continue the current session but switch to genre channel content
            // The session should continue running with the genre channel's next content
            setTimeout(() => {
                // Send message to genre channel to continue with next content
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                const message = {
                    type: 'continueWithNextContent',
                    payload: {
                        continueSession: true,
                        currentShow: detectedShow ? detectedShow.title : 'Unknown',
                        sessionActive: appState.isIndexing
                    }
                };
                
                if (channelFrame && channelFrame.contentWindow) {
                    channelFrame.contentWindow.postMessage(message, '*');
                }
                if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                    channelFrameIndexing.contentWindow.postMessage(message, '*');
                }
                
                console.log('Sent continue session message to genre channel');
                
                // Add a delayed UI update to ensure button text updates after content change
                setTimeout(() => {
                    console.log('Performing delayed UI update after genre channel activation');
                    updateUI();
                    updatePointsDisplay();
                }, 2000); // 2 second delay to allow content to update
                
            }, 1000);
            
            Tracker.logRumiAction('Genre channel activated', { 
                continueSession: true,
                previousShow: detectedShow ? detectedShow.title : 'Unknown',
                sessionActive: appState.isIndexing
            });
        }

        // NEW: Debounced channel expansion state setter
        function setChannelExpansionState(expanded) {
            // Debug logging
            console.log(`setChannelExpansionState called: expanded=${expanded}, isIndexing=${appState.isIndexing}, userInitiated=${appState.userInitiatedChannelChange}`);
            
            // Prevent automatic channel state changes during active indexing sessions
            // unless it's a user-initiated action
            if (appState.isIndexing && !appState.userInitiatedChannelChange) {
                console.log(`üö´ Preventing channel expansion change during active session (${expanded})`);
                return;
            }
            
            // Clear any pending timeout
            if (channelExpansionTimeout) {
                clearTimeout(channelExpansionTimeout);
            }
            
            // Only update if the state is actually changing
            if (appState.channelExpanded !== expanded) {
                console.log(`Setting channel expansion state: ${expanded} (was: ${appState.channelExpanded})`);
                
                // Set the state immediately
                appState.channelExpanded = expanded;
                lastChannelExpansionState = expanded;
                
                // Debounce the UI update to prevent rapid toggling
                channelExpansionTimeout = setTimeout(() => {
                    updateExpandableChannelUI();
                    channelExpansionTimeout = null;
                }, 100); // 100ms debounce
            } else {
                console.log(`Channel expansion state already set to: ${expanded}`);
            }
            
            // Reset the user-initiated flag after processing
            appState.userInitiatedChannelChange = false;
        }

        // NEW: Helper function to update current multiplier based on elapsed time and dynamic milestones
        function updateCurrentMultiplier(elapsedTime) {
            const sessionDuration = calculateSessionDuration();
            const milestones = calculateDynamicMultiplierMilestones(sessionDuration);
            
            // Find the current multiplier based on elapsed time
            let currentMultiplier = 1.0;
            const progress = elapsedTime / sessionDuration;
            
            for (let i = 0; i < milestones.length; i++) {
                if (progress >= milestones[i].time) {
                    currentMultiplier = milestones[i].multiplier;
                } else {
                    break;
                }
            }
            
            // Only update if the multiplier has changed significantly (avoid micro-updates)
            if (Math.abs(currentMultiplier - appState.currentMultiplier) >= 0.1) {
                const oldMultiplier = appState.currentMultiplier;
                appState.currentMultiplier = currentMultiplier;
                
                console.log(`üéØ Multiplier updated: ${oldMultiplier.toFixed(1)}x ‚Üí ${currentMultiplier.toFixed(1)}x at ${(progress * 100).toFixed(1)}% progress`);
                
                // Update transition system if available
                if (window.transitionSystem && window.transitionSystem.updateMultiplier) {
                    window.transitionSystem.updateMultiplier(currentMultiplier);
                }
            }
        }

        // NEW: Helper function to calculate dynamic multiplier milestones based on session duration
        function calculateDynamicMultiplierMilestones(sessionDurationSeconds) {
            const sessionDurationMinutes = sessionDurationSeconds / 60;
            
            // Base timeline duration (180 minutes = 3 hours)
            const baseTimelineDuration = 180;
            
            if (sessionDurationMinutes <= baseTimelineDuration) {
                // For sessions <= 180 minutes, use standard milestones
                return [
                    { time: 0, multiplier: 1.0 },      // Start
                    { time: 0.25, multiplier: 1.2 },   // 25% of session (1.2x milestone)
                    { time: 0.5, multiplier: 1.5 },    // 50% of session (1.5x milestone) 
                    { time: 0.75, multiplier: 1.8 }    // 75% of session (1.8x milestone)
                ];
            } else {
                // For sessions > 180 minutes, scale up the timeline and add more multipliers
                const scaleFactor = sessionDurationMinutes / baseTimelineDuration;
                const numMilestones = Math.min(Math.ceil(scaleFactor * 4), 8); // Max 8 milestones
                
                const milestones = [{ time: 0, multiplier: 1.0 }]; // Always start with 1.0x
                
                // Calculate multiplier progression from 1.0x to maximum based on content duration
                const maxMultiplier = Math.min(1.0 + (scaleFactor * 0.8), 3.0); // Cap at 3.0x
                
                // Distribute milestones evenly across the timeline
                for (let i = 1; i < numMilestones; i++) {
                    const timeRatio = i / (numMilestones - 1);
                    const multiplier = 1.0 + (timeRatio * (maxMultiplier - 1.0));
                    
                    milestones.push({
                        time: timeRatio,
                        multiplier: Math.round(multiplier * 10) / 10 // Round to 1 decimal
                    });
                }
                
                console.log(`üéØ Dynamic Timeline Scaling:`, {
                    sessionDurationMinutes: sessionDurationMinutes.toFixed(1),
                    scaleFactor: scaleFactor.toFixed(2),
                    numMilestones,
                    maxMultiplier: maxMultiplier.toFixed(1),
                    milestones
                });
                
                return milestones;
            }
        }

        // NEW: Helper function to calculate session duration based on current state
        function calculateSessionDuration() {
            // Check if we have a valid cached value (30-second cache)
            if (appState.cachedSessionDuration && appState.cachedSessionDurationTimestamp) {
                const cacheAge = Date.now() - appState.cachedSessionDurationTimestamp;
                if (cacheAge < 30000) { // 30 seconds
                    return appState.cachedSessionDuration;
                }
            }
            
            let sessionDuration;
            
            // If we have a chained session duration (extended session), use that
            if (appState.chainedSessionDuration) {
                sessionDuration = appState.chainedSessionDuration;
            } else if (appState.entryPoint === 'automode' && appState.automodeContentItems.length > 0) {
                // For automode, calculate total session duration from content items
                sessionDuration = appState.automodeContentItems.reduce((total, item) => {
                    const durationParts = item.duration.split(':');
                    return total + (parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]));
                }, 0);
            } else if (detectedShow) {
                // For show detection, use detected show duration if available
                if (detectedShow.duration && !isNaN(detectedShow.duration)) {
                    sessionDuration = detectedShow.duration * 60; // Assume duration is in minutes
                } else {
                    // Use genre/type-based averages if duration is not available
                    let genre = (detectedShow.type || '').toLowerCase();
                    if (!genre && detectedShow.genre) genre = detectedShow.genre.toLowerCase();
                    
                    // Check for specific content types first
                    if (genre.includes('sitcom') || genre.includes('comedy')) {
                        sessionDuration = 22 * 60; // 22 min for sitcoms/comedy
                    } else if (genre.includes('sketch') || genre.includes('variety')) {
                        sessionDuration = 30 * 60; // 30 min for sketch/variety shows
                    } else if (genre.includes('reality')) {
                        sessionDuration = 60 * 60; // 60 min for reality shows
                    } else if (genre.includes('drama') || genre.includes('show') || genre.includes('series')) {
                        sessionDuration = 45 * 60; // 45 min for dramas/series
                    } else if (genre.includes('movie') || genre.includes('film')) {
                        sessionDuration = 135 * 60; // 135 min (2h 15m) for movies
                    } else if (genre.includes('documentary')) {
                        sessionDuration = 90 * 60; // 90 min for documentaries
                    } else if (genre.includes('miniseries') || genre.includes('limited')) {
                        sessionDuration = 60 * 60; // 60 min for miniseries episodes
                    } else {
                        sessionDuration = 45 * 60; // Fallback to 45 minutes
                    }
                }
            } else {
                sessionDuration = 30 * 60; // Fallback to 30 minutes
            }
            
            // Cache the calculated session duration
            appState.cachedSessionDuration = sessionDuration;
            appState.cachedSessionDurationTimestamp = Date.now();
            
            return sessionDuration;
        }

        // NEW: Helper function to format running time display
        function formatRunningTime(elapsedTime) {
            const sessionDuration = calculateSessionDuration();
            const elapsedMinutes = Math.floor(elapsedTime / 60);
            const elapsedSeconds = Math.floor(elapsedTime % 60);
            const totalMinutes = Math.floor(sessionDuration / 60);
            const totalSeconds = Math.floor(sessionDuration % 60);
            return `${elapsedMinutes}:${elapsedSeconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
        }

        // NEW: Function to handle show detection session completion
        function handleShowDetectionSessionComplete() {
            // Only handle completion once
            if (appState.sessionCompleted) return;
            appState.sessionCompleted = true;
            
            console.log('Show detection session completed');
            
            // Always record actual indexed content before showing receipt
            recordActualIndexedContentBeforeReceipt();
            
            // Record the actual indexed content
            if (detectedShow) {
                const sessionDuration = calculateSessionDuration();
                const sessionDurationMinutes = Math.floor(sessionDuration / 60);
                const totalElapsedTime = Math.floor((Date.now() - appState.indexingStartTime) / 60000);
                const actualDuration = Math.min(sessionDurationMinutes, totalElapsedTime);
                
                // Check if there was a show transition (interrupt)
                if (appState.originalShow && appState.interruptNewShow) {
                    // Calculate time spent on each show using actual interrupt timestamp
                    let originalShowTime, chainedShowTime;
                    
                    if (appState.showInterruptTimestamp) {
                        // Use actual interrupt timestamp to calculate viewing times
                        const interruptTimeMinutes = Math.floor((appState.showInterruptTimestamp - appState.indexingStartTime) / 60000);
                        originalShowTime = Math.min(interruptTimeMinutes, actualDuration);
                        chainedShowTime = Math.max(0, actualDuration - originalShowTime);
                    } else {
                        // Fallback: assume the interrupt happened at 75% of the session duration
                        const interruptTime = Math.floor(actualDuration * 0.75);
                        originalShowTime = interruptTime;
                        chainedShowTime = actualDuration - interruptTime;
                    }
                    
                    // Record the original show
                    const originalShowItem = {
                        title: `${appState.originalShow.title} ${appState.originalShow.season !== 'N/A' ? `S${appState.originalShow.season} E${appState.originalShow.episode}` : '(Film)'}`,
                        duration: originalShowTime,
                        type: 'detected_show',
                        points: Math.round((originalShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(originalShowItem);
                    
                    // Record the chained show
                    const chainedShowItem = {
                        title: `${appState.interruptNewShow.title} ${appState.interruptNewShow.season !== 'N/A' ? `S${appState.interruptNewShow.season} E${appState.interruptNewShow.episode}` : '(Film)'} (Chained)`,
                        duration: chainedShowTime,
                        type: 'chained_show',
                        points: Math.round((chainedShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(chainedShowItem);
                    
                    // Mark both content items as played to prevent duplicates
                    markContentAsPlayed(originalShowItem);
                    markContentAsPlayed(chainedShowItem);
                    
                    console.log('Recorded show transition:', {
                        originalShow: originalShowItem,
                        chainedShow: chainedShowItem,
                        interruptTimestamp: appState.showInterruptTimestamp
                    });
                } else {
                    // No show transition - record only the current show
                    const indexedContentItem = {
                        title: `${detectedShow.title} ${detectedShow.season !== 'N/A' ? `S${detectedShow.season} E${detectedShow.episode}` : '(Film)'}`,
                        duration: actualDuration,
                        type: 'detected_show',
                        points: Math.round((actualDuration * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(indexedContentItem);
                    
                    // Mark content as played to prevent duplicates
                    markContentAsPlayed(indexedContentItem);
                }
            }
            
            // Check if this was completed by user action (debug skip)
            const wasUserCompleted = appState.debugSkipCooldown > 0;
            
            if (wasUserCompleted && !appState.userChoice) {
                // Show user choice prompt for Rumi vs Streamer control (always show, not just when channel expanded)
                showUserChoicePrompt();
            } else {
                // End the session and show receipt
                setTimeout(() => {
                    stopIndexing();
                }, 2000); // Give user 2 seconds to see "Session complete"
            }
            
            Tracker.logRumiAction('Show detection session completed', { 
                wasUserCompleted: wasUserCompleted,
                detectedShow: detectedShow ? detectedShow.title : 'Unknown',
                originalShow: appState.originalShow ? appState.originalShow.title : null,
                chainedShow: appState.interruptNewShow ? appState.interruptNewShow.title : null,
                indexedContent: appState.indexedContent
            });
        }

        // NEW: Message handler for content tracking data requests
        window.addEventListener('message', function(event) {
            if (event.data.type === 'requestContentTrackingData') {
                console.log('Received content tracking data request from:', event.data.channelName);
                
                // Get the currently playing content ID
                let currentlyPlayingId = null;
                if (appState.indexedContent.length > 0) {
                    const currentContent = appState.indexedContent[appState.indexedContent.length - 1];
                    currentlyPlayingId = generateContentId(currentContent);
                }
                
                // Send content tracking data back to the channel
                event.source.postMessage({
                    type: 'contentTrackingData',
                    channelName: event.data.channelName,
                    excludeContentIds: currentlyPlayingId ? [currentlyPlayingId] : [],
                    playedContentIds: Array.from(appState.playedContent),
                    channelContentIds: Array.from(appState.channelContent.get(event.data.channelName) || [])
                }, '*');
            }
        });

        // NEW: Content tracking utility functions
        // NEW: Helper function to update current content item
        function updateCurrentContentItem(elapsedTime) {
            if (!appState.automodeContentItems.length) return;
            
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Check if we need to move to next item
            if (timeInCurrentItem >= appState.contentItemDuration) {
                moveToNextContentItem(elapsedTime);
            }
        }

        // NEW: Handle fast mode content indexing for auto mode
        function handleFastModeContentIndexing(elapsedTime) {
            if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) return;
            
            // Calculate how many content items should have been completed by now
            let totalExpectedTime = 0;
            let expectedContentIndex = 0;
            
            for (let i = 0; i < appState.automodeContentItems.length; i++) {
                const item = appState.automodeContentItems[i];
                let itemDuration;
                
                // Parse duration
                if (typeof item.duration === 'string' && item.duration.includes(':')) {
                    const durationParts = item.duration.split(':');
                    itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                } else {
                    itemDuration = item.duration || (45 * 60); // Default 45 minutes
                }
                
                if (totalExpectedTime + itemDuration <= elapsedTime) {
                    totalExpectedTime += itemDuration;
                    expectedContentIndex = i;
                } else {
                    break;
                }
            }
            
            // If we're behind where we should be, catch up by indexing content
            if (expectedContentIndex > appState.currentContentIndex) {
                console.log(`Fast Mode: Catching up content indexing. Current: ${appState.currentContentIndex}, Expected: ${expectedContentIndex}`);
                
                // Index all the content items we "skipped through"
                for (let i = appState.currentContentIndex; i < expectedContentIndex; i++) {
                    const item = appState.automodeContentItems[i];
                    if (item) {
                        // Calculate item duration
                        let itemDuration;
                        if (typeof item.duration === 'string' && item.duration.includes(':')) {
                            const durationParts = item.duration.split(':');
                            itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            itemDuration = item.duration || (45 * 60);
                        }
                        
                        // Add to indexed content
                        const indexedContentItem = {
                            title: item.title,
                            duration: Math.floor(itemDuration / 60), // Convert to minutes for display
                            type: 'automode_content',
                            points: Math.round((itemDuration * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                        };
                        
                        // Only add if not already in indexed content
                        const alreadyIndexed = appState.indexedContent.some(existing => 
                            existing.title === indexedContentItem.title && 
                            existing.type === indexedContentItem.type
                        );
                        
                        if (!alreadyIndexed) {
                            appState.indexedContent.push(indexedContentItem);
                            console.log(`Fast Mode: Indexed content item: ${item.title} (${itemDuration}s)`);
                        }
                    }
                }
                
                // Update current content index and timing
                appState.currentContentIndex = expectedContentIndex;
                
                // Calculate start time for current item
                let cumulativeTime = 0;
                for (let i = 0; i < appState.currentContentIndex; i++) {
                    const prevItem = appState.automodeContentItems[i];
                    if (prevItem) {
                        let prevDuration;
                        if (typeof prevItem.duration === 'string' && prevItem.duration.includes(':')) {
                            const durationParts = prevItem.duration.split(':');
                            prevDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            prevDuration = prevItem.duration || (45 * 60);
                        }
                        cumulativeTime += prevDuration;
                    }
                }
                
                appState.contentItemStartTime = cumulativeTime;
                
                // Set duration for current item
                if (appState.currentContentIndex < appState.automodeContentItems.length) {
                    const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                    if (currentItem) {
                        if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                            const durationParts = currentItem.duration.split(':');
                            appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            appState.contentItemDuration = currentItem.duration || (45 * 60);
                        }
                    }
                }
                
                console.log(`Fast Mode: Updated to content index ${appState.currentContentIndex}, total indexed items: ${appState.indexedContent.length}`);
            }
        }

        // NEW: Helper function to move to next content item
        function moveToNextContentItem(elapsedTime) {
            if (appState.automodeContentItems.length > 0 && appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                // Check if this content was completed by user action (debug skip)
                const wasUserCompleted = appState.debugSkipCooldown > 0;
                
                appState.currentContentIndex++;
                // Use the passed elapsed time to avoid timing mismatch
                appState.contentItemStartTime = elapsedTime;
                
                // Calculate duration for new content item
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    // Handle both duration strings (e.g., "0:45") and numeric durations
                    if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                        // Parse duration string (e.g., "0:45") to seconds
                        const durationParts = currentItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        // Use duration as-is (already in seconds)
                        appState.contentItemDuration = currentItem.duration;
                    }
                }
                
                // If content was completed by user action and channel is open, show choice prompt
                if (wasUserCompleted && appState.channelExpanded && !appState.userChoice) {
                    showUserChoicePrompt();
                }
                
                Tracker.logRumiAction('Content item transitioned', { 
                    newItem: currentItem.title,
                    index: appState.currentContentIndex,
                    wasUserCompleted: wasUserCompleted
                });
            } else {
                // Reached end of all content - trigger session completion
                console.log('End of channel content reached - completing session');
                
                if (!appState.sessionCompleted) {
                    appState.sessionCompleted = true;
                    
                    if (appState.entryPoint === 'detection' && detectedShow) {
                        // For show detection mode, use existing completion handler
                        handleShowDetectionSessionComplete();
                    } else {
                        // For automode or other entry points, complete session directly
                        console.log('Auto-completing session after reaching end of content');
                        
                        // Set session end reason
                        appState.sessionEndReason = 'content_complete';
                        
                        // Log the completion
                        Tracker.logRumiAction('Session completed - end of content', { 
                            entryPoint: appState.entryPoint,
                            totalContentItems: appState.automodeContentItems.length,
                            completedIndex: appState.currentContentIndex
                        });
                        
                        // Give user 2 seconds to see "Session complete" message, then show receipt
                        setTimeout(() => {
                            stopIndexing();
                        }, 2000);
                    }
                }
            }
        }

        // NEW: Helper function to scroll text for current content item
        function scrollText(text, elapsedTime, visibleWidth) {
            if (!text) return '';
            
            // Only scroll if text is longer than visible width
            if (text.length <= visibleWidth) {
                return text;
            }
            
            // Calculate scroll position based on time within current content item
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Start scrolling after transition on is complete (0.5 seconds)
            const scrollStartTime = 0.5;
            const scrollEndTime = appState.contentItemDuration - 3.0; // Stop scrolling 3 seconds before end
            
            if (timeInCurrentItem < scrollStartTime || timeInCurrentItem > scrollEndTime) {
                // Don't scroll during transitions, just show the beginning of the text
                return text.substring(0, visibleWidth);
            }
            
            // Calculate effective scroll time (subtract transition periods)
            const effectiveScrollTime = timeInCurrentItem - scrollStartTime;
            const scrollSpeed = 1.6; // characters per second (doubled from 0.8)
            const scrollOffset = Math.floor(effectiveScrollTime * scrollSpeed) % text.length;
            
            // Scroll from right to left
            const startPos = scrollOffset;
            const endPos = Math.min(startPos + visibleWidth, text.length);
            let scrolledText = text.substring(startPos, endPos);
            
            // If we're near the end, wrap around
            if (endPos === text.length && startPos + visibleWidth > text.length) {
                const remainingChars = visibleWidth - (text.length - startPos);
                scrolledText += ' ‚Ä¢ ' + text.substring(0, remainingChars);
            }
            
            return scrolledText;
        }
        // ============================================================================
// TRANSITION SYSTEM INTEGRATION
// ============================================================================

// Global transition system instance
let transitionSystem = null;

// Initialize transition system with UI callbacks
function initializeTransitionSystem() {
    if (typeof TransitionSystem === 'undefined') {
        console.warn('TransitionSystem not loaded - skipping initialization');
        return;
    }

    console.log('Initializing transition system...');
    
    window.transitionSystem = new TransitionSystem();
    transitionSystem = window.transitionSystem; // Keep local reference for compatibility
    
    // Set up UI callbacks
    transitionSystem.state.uiCallbacks = {
        onStateChange: (newState) => {
            console.log('Transition system state changed:', newState);
            // Sync with app state
            appState.isIndexing = newState.isIndexing;
            appState.isTransitioning = newState.isTransitioning;
            updateUI();
        },
        
        onShowChange: (newShow) => {
            console.log('Show changed:', newShow);
            
            // Update app state with new show
            if (appState.entryPoint === 'detection') {
                // Store the previous show as completed
                if (appState.detectedShow) {
                    markContentAsPlayedWithTransition(appState.detectedShow);
                }
                
                // Update to new show
                const previousShow = appState.detectedShow;
                appState.detectedShow = newShow;
                
                // Set originalShow only on first transition
                if (!appState.originalShow) {
                    appState.originalShow = previousShow;
                }
                
                // Always update the most recent transition
                appState.interruptNewShow = newShow;
                appState.showInterruptTimestamp = Date.now();
                
                // Track transition count
                appState.transitionCount = (appState.transitionCount || 0) + 1;
                
                console.log(`Transition #${appState.transitionCount} ${appState.originalShow ? 'chain' : 'initial'}: ${previousShow.title} ‚Üí ${newShow.title}`);
                console.log('Total transitions in session:', appState.transitionCount);
                
                // Update global detectedShow variable for compatibility
                detectedShow = newShow;
                
                // Reset content items to include the new show
                const sessionDuration = calculateSessionDuration();
                appState.automodeContentItems = getShowDetectionContent(newShow, sessionDuration);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = (Date.now() - appState.indexingStartTime) / 1000; // Current elapsed time
                
                // Calculate duration for new content item
                if (appState.automodeContentItems.length > 0) {
                    const newItem = appState.automodeContentItems[0];
                    if (typeof newItem.duration === 'string' && newItem.duration.includes(':')) {
                        const durationParts = newItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        appState.contentItemDuration = newItem.duration || 45 * 60;
                    }
                }
                
                // Extend session duration to accommodate the new show
                const currentElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                const remainingTimeForNewShow = (newShow.duration || 45) * 60; // Convert to seconds
                
                // If this is the first extension, start from current elapsed time
                // If this is a subsequent extension, add to the existing chained duration
                const baseSessionDuration = appState.chainedSessionDuration || currentElapsedTime;
                const extendedSessionDuration = baseSessionDuration + remainingTimeForNewShow;
                
                // Update chained session duration
                appState.chainedSessionDuration = extendedSessionDuration;
                
                // Clear session duration cache to force recalculation
                appState.cachedSessionDuration = null;
                appState.cachedSessionDurationTimestamp = null;
                
                console.log(`Show transition: ${appState.originalShow.title} ‚Üí ${newShow.title}`);
                console.log('Extended session duration:', extendedSessionDuration / 60, 'minutes');
                console.log('New content item duration:', appState.contentItemDuration);
                console.log('Content item start time:', appState.contentItemStartTime);
            }
            
            // Update all UI elements
            updateUI();
            updatePointsDisplay();
            
            // Force update the animation panel immediately
            if (appState.indexingStartTime) {
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                updateAnimationPanel(elapsedTime);
            }
            
            // Update content display to show locked previous content
            triggerContentDisplayUpdate('show_transition');
            
            // Update button text with current show title
            updateButtonWithCurrentShow(newShow);
        },
        
        onMultiplierChange: (newMultiplier) => {
            console.log('Multiplier changed:', newMultiplier);
            appState.currentMultiplier = newMultiplier;
            updatePointsDisplay();
        },
        
        onProgressUpdate: (progress) => {
            console.log('Progress updated:', progress);
            // Update session earnings based on progress
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                const timeIndexedMinutes = progress.timeIndexed;
                const points = timeIndexedMinutes * (appState.baseRate || 0.1) * progress.multiplier;
                appState.sessionEarnings = points;
                updatePointsDisplay();
            }
        },
        
        onSessionComplete: (receipt) => {
            console.log('Session completed:', receipt);
            appState.sessionCompleted = true;
            // Store receipt for display
            appState.sessionReceipt = receipt;
            showSessionReceipt(receipt);
        }
    };
    
    console.log('Transition system initialized successfully');
}

// Integrate transition system with existing content tracking
function integrateTransitionSystemWithContentTracking() {
    if (!transitionSystem) return;
    
    // Sync played content with transition system
    appState.playedContent.forEach(contentId => {
        transitionSystem.markContentAsCompleted(contentId);
    });
    
    // Sync channel content
    appState.channelContent.forEach((contentSet, channelName) => {
        contentSet.forEach(contentId => {
            // Mark as in channel but not completed
            if (!transitionSystem.isContentCompleted(contentId)) {
                // This content is available in the channel
                console.log(`Content ${contentId} available in channel ${channelName}`);
            }
        });
    });
    
    console.log('Transition system integrated with content tracking');
}

// Enhanced content tracking functions that work with transition system
function markContentAsPlayedWithTransition(content) {
    const contentId = generateContentId(content);
    
    // Use existing function
    markContentAsPlayed(content);
    
    // Also mark in transition system
    if (transitionSystem) {
        transitionSystem.markContentAsCompleted(contentId);
    }
}

// Enhanced show transition function
async function transitionToShowWithSystem(newShow) {
    if (!transitionSystem || !appState.detectedShow) {
        console.warn('Transition system or current show not available');
        return;
    }
    
    try {
        // Use transition system for smooth transition
        await transitionSystem.transitionToShow(newShow);
        
        // Update app state
        appState.interruptNewShow = newShow;
        appState.showInterruptTimestamp = Date.now();
        
        console.log('Show transition completed via transition system');
        
    } catch (error) {
        console.error('Error during show transition:', error);
        // Fallback to direct state update
        appState.interruptNewShow = newShow;
        appState.showInterruptTimestamp = Date.now();
    }
}

// Enhanced session management
function startIndexingWithTransitionSystem() {
    // Use existing startIndexing logic
    startIndexing();
    
    // Initialize transition system if not already done
    if (!transitionSystem) {
        initializeTransitionSystem();
    }
    
    // Initialize transition system with current show
    if (appState.entryPoint === 'detection' && appState.detectedShow) {
        const showData = {
            id: generateContentId(appState.detectedShow),
            title: appState.detectedShow.title,
            duration: appState.detectedShow.duration || 45,
            type: 'show'
        };
        
        // Update button text with initial show
        updateButtonWithCurrentShow(appState.detectedShow);
        
        // Update content display
        triggerContentDisplayUpdate('session_start');
        
        transitionSystem.initialize(showData, {
            baseRate: appState.baseRate || 0.1,
            multiplierThresholds: [
                { time: 60, multiplier: 1.2 },
                { time: 120, multiplier: 1.5 },
                { time: 180, multiplier: 2.0 }
            ]
        });
        
        console.log('Transition system initialized with detected show:', showData);
    }
}

// Enhanced session completion
function completeSessionWithTransitionSystem() {
    if (!transitionSystem) {
        console.warn('Transition system not available for session completion');
        return;
    }
    
    // Complete current show in transition system
    transitionSystem.completeCurrentShow();
    
    // Get session receipt
    const receipt = transitionSystem.getSessionReceipt();
    
    // Update app state
    appState.sessionCompleted = true;
    appState.sessionReceipt = receipt;
    
    // Show receipt
    showSessionReceipt(receipt);
    
    console.log('Session completed via transition system');
}

// Function to show session receipt (placeholder - implement UI as needed)
function showSessionReceipt(receipt) {
    console.log('=== SESSION RECEIPT ===');
    console.log('Session ID:', receipt.sessionId);
    console.log('Total Time:', receipt.totalTime);
    console.log('Final Multiplier:', receipt.finalMultiplier);
    console.log('Total Points:', receipt.totalPoints);
    console.log('Content Played:');
    
    // Handle both receipt.content and receipt.playedContent
    const contentArray = receipt.content || receipt.playedContent || [];
    if (Array.isArray(contentArray) && contentArray.length > 0) {
        contentArray.forEach(item => {
            console.log(`  - ${item.title}: ${item.timeIndexed}min, ${item.points} points (${item.multiplier}x)`);
        });
    } else {
        console.log('  No content played in this session');
    }
    console.log('=====================');
    
    // TODO: Implement UI display for receipt
    // This could be a modal, overlay, or dedicated receipt view
}

// Debug function for transition system
function debugTransitionSystem() {
    if (!transitionSystem) {
        console.log('Transition system not initialized');
        return;
    }
    
    console.log('=== TRANSITION SYSTEM DEBUG ===');
    const state = transitionSystem.getCurrentState();
    console.log('Current State:', state);
    console.log('Log:', transitionSystem.getLog());
    console.log('=== END TRANSITION SYSTEM DEBUG ===');
}

        // NEW: Update content display in the channel iframe
        function updateContentDisplay() {
            console.log('updateContentDisplay: Sending update message to channel iframe');
            
            // Send message to channel iframe to update content blocks
            const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('updateContentDisplay: Channel iframe not found or not loaded');
                return;
            }
            
            console.log('=== UPDATING CONTENT DISPLAY ===');
            console.log('Trigger: updateContentDisplay called');
            
            // Get transition system data if available
            let playedContent = [];
            if (window.transitionSystem && window.transitionSystem.state && window.transitionSystem.state.playedContent) {
                playedContent = window.transitionSystem.state.playedContent;
                console.log('Played content from transition system:', playedContent.length, 'items');
            } else {
                console.log('No transition system or playedContent available');
            }
            
            // Prepare content data to send to channel
            const contentData = {
                playedContent: playedContent,
                currentShow: appState.detectedShow,
                elapsedTime: appState.indexingStartTime ? 
                    Math.floor((Date.now() - appState.indexingStartTime) / 60000) : 0,
                // NEW: Add fast mode context to preserve content visibility
                fastModeActive: appState.fastMode && appState.fastMode.active,
                preserveAllContent: true, // Always preserve all content blocks
                // NEW: Add session start context to prevent clearing content
                isSessionStart: appState.indexingStartTime && (Date.now() - appState.indexingStartTime) < 5000, // First 5 seconds of session
                // NEW: Add transition context to preserve existing content during transitions
                isTransition: appState.isTransitioning || false,
                // NEW: Indicate this is a state update, not a content replacement
                updateType: 'status_update' // vs 'content_replacement'
            };
            
            // Send message to channel iframe to update content blocks
            try {
                channelFrame.contentWindow.postMessage({
                    type: 'updateContentBlocks',
                    data: contentData
                }, '*');
                console.log('Sent content update message to channel:', contentData);
                console.log('=== END CONTENT DISPLAY UPDATE ===');
            } catch (error) {
                console.error('Error sending message to channel iframe:', error);
            }
        }

        // NEW: Manual trigger for testing content display
        function testContentDisplay() {
            console.log('=== MANUAL CONTENT DISPLAY TEST ===');
            console.log('Current app state:', {
                isIndexing: appState.isIndexing,
                detectedShow: appState.detectedShow?.title,
                transitionSystem: !!window.transitionSystem
            });
            
            // Add some test content to transition system if available
            if (window.transitionSystem) {
                const testContent = {
                    title: 'Test Show S1:E1',
                    timeIndexed: 22,
                    points: 4.4,
                    multiplier: 1.0,
                    duration: 22,
                    service: 'Netflix'
                };
                window.transitionSystem.state.playedContent.push(testContent);
                console.log('Added test content to transition system');
            }
            
            triggerContentDisplayUpdate('manual_test');
        }

        // NEW: Trigger content display update with specific transition context
        function triggerContentDisplayUpdate(context = 'general') {
            console.log(`=== CONTENT DISPLAY TRIGGER: ${context.toUpperCase()} ===`);
            
            const triggers = {
                'session_start': 'Session started - initializing content blocks',
                'show_transition': 'Show transition - updating current/completed blocks',
                'fast_mode_transition': 'Fast mode transition - rapid block updates',
                'session_complete': 'Session completed - finalizing all blocks',
                'manual_update': 'Manual update requested',
                'general': 'General content display update'
            };
            
            console.log('Context:', triggers[context] || 'Unknown trigger context');
            console.log('Current detected show:', appState.detectedShow?.title || 'None');
            console.log('Transition system available:', !!window.transitionSystem);
            
            // Call the main update function
            updateContentDisplay();
        }
        
        // NEW: Update button text with current show title
        function updateButtonWithCurrentShow(show) {
            const ctaButton = document.getElementById('cta-button');
            const stopIndexingButton = document.getElementById('stop-indexing-button');
            
            if (!show) return;
            
            // Format show title for button
            let buttonText = '';
            if (show.season && show.episode) {
                buttonText = `STOP WATCHING ${show.title} ${show.season}:${show.episode}`;
            } else if (show.year) {
                buttonText = `STOP WATCHING ${show.title} (${show.year})`;
            } else {
                buttonText = `STOP WATCHING ${show.title}`;
            }
            
            // Update both buttons if they exist
            if (ctaButton) {
                ctaButton.textContent = buttonText;
                console.log('Updated CTA button text:', buttonText);
            }
            
            if (stopIndexingButton) {
                stopIndexingButton.textContent = buttonText;
                console.log('Updated stop indexing button text:', buttonText);
            }
        }

        // NEW: Test function for multiple transitions
        function testMultipleTransitions() {
            console.log('=== TESTING MULTIPLE TRANSITIONS ===');
            
            if (!window.transitionSystem) {
                console.log('Transition system not available');
                return;
            }
            
            // Test shows for transitions
            const testShows = [
                { title: 'Friends', season: 'S1', episode: 'E1', duration: 24, service: 'HBO' },
                { title: 'The Office', season: 'S3', episode: 'E20', duration: 22, service: 'Peacock' },
                { title: 'Stranger Things', season: 'S4', episode: 'E9', duration: 51, service: 'Netflix' },
                { title: 'Breaking Bad', season: 'S5', episode: 'E16', duration: 47, service: 'AMC' }
            ];
            
            console.log('Current transition count:', appState.transitionCount || 0);
            console.log('Available test shows:', testShows.length);
            
            // Show current state
            const currentState = window.transitionSystem.getCurrentState();
            console.log('Current show:', currentState.currentShow?.title || 'None');
            console.log('Played content count:', currentState.playedContent.length);
            
            // Instructions for manual testing
            console.log('');
            console.log('To test multiple transitions:');
            console.log('1. Start a session with startIndexingWithTransitionSystem()');
            console.log('2. Add some time: transitionSystem.updateIndexingProgress(1)');
            console.log('3. Transition to show 1: transitionToShowWithSystem(testShows[0])');
            console.log('4. Add more time: transitionSystem.updateIndexingProgress(1)');
            console.log('5. Transition to show 2: transitionToShowWithSystem(testShows[1])');
            console.log('6. Continue pattern for 3rd, 4th transitions...');
            console.log('');
            console.log('Use debugTransitionSystem() to check state after each transition');
            
            // Make test shows available globally for easy access
            window.testShows = testShows;
            console.log('Test shows available as window.testShows');
            
            console.log('=== END MULTIPLE TRANSITIONS TEST ===');
        }

        // ============================================================================
        // END TRANSITION SYSTEM INTEGRATION
        // ============================================================================

        // NEW: Test function for automatic transitions with short durations
        function testAutomaticTransitions() {
            console.log('=== TESTING AUTOMATIC TRANSITIONS ===');
            
            if (!appState.isIndexing) {
                console.log('Please start an indexing session first');
                return;
            }
            
            if (!window.transitionSystem) {
                console.log('Transition system not available');
                return;
            }
            
            // Set very short durations for testing (10 seconds per show)
            const testDuration = 10; // 10 seconds
            appState.contentItemDuration = testDuration;
            
            console.log(`Set show duration to ${testDuration} seconds for testing`);
            console.log('Current show will auto-transition to next show in channel after 10 seconds');
            console.log('Watch the console for transition messages...');
            
            // Reset the start time for current content item
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.contentItemStartTime = elapsedTime;
            
            console.log('Test started! Automatic transition will happen in 10 seconds...');
            console.log('=== END TEST SETUP ===');
        }

        // NEW: Debug function to test fast mode and channel expansion fixes
        function testFastModeAndChannelFixes() {
            console.log('=== TESTING FAST MODE AND CHANNEL FIXES ===');
            
            // Debug current state first
            console.log('Current app state:', {
                isIndexing: appState.isIndexing,
                channelExpanded: appState.channelExpanded,
                userInitiatedChannelChange: appState.userInitiatedChannelChange
            });
            
            // Test 1: Channel expansion protection during indexing
            console.log('\nTest 1: Channel expansion protection during indexing');
            if (appState.isIndexing) {
                console.log('Session is active - testing channel expansion protection');
                const originalState = appState.channelExpanded;
                
                // IMPORTANT: Ensure the userInitiatedChannelChange flag is false for this test
                appState.userInitiatedChannelChange = false;
                console.log('Reset userInitiatedChannelChange to false for test');
                
                // Try to change channel state without user initiation (should be blocked)
                console.log(`Attempting automatic change from ${originalState} to ${!originalState}`);
                setChannelExpansionState(!originalState);
                console.log(`Result - Original: ${originalState}, Current: ${appState.channelExpanded}`);
                
                if (appState.channelExpanded === originalState) {
                    console.log('‚úÖ Channel expansion protection working - automatic change blocked');
                } else {
                    console.log('‚ùå Channel expansion protection failed - automatic change allowed');
                }
                
                // Try to change with user initiation (should work)
                console.log(`\nTesting user-initiated change from ${appState.channelExpanded} to ${!appState.channelExpanded}`);
                appState.userInitiatedChannelChange = true;
                setChannelExpansionState(!appState.channelExpanded);
                console.log(`After user-initiated change: ${appState.channelExpanded}`);
                
                if (appState.channelExpanded !== originalState) {
                    console.log('‚úÖ User-initiated channel change working');
                } else {
                    console.log('‚ùå User-initiated channel change failed');
                }
                
                // Restore original state
                appState.userInitiatedChannelChange = true;
                setChannelExpansionState(originalState);
                console.log(`Restored to original state: ${appState.channelExpanded}`);
            } else {
                console.log('No active session - start indexing first to test channel protection');
            }
            
            // Test 2: Fast mode content preservation
            console.log('\nTest 2: Fast mode content preservation');
            if (appState.fastMode && appState.fastMode.active) {
                console.log('Fast mode is active - testing content preservation');
                triggerContentDisplayUpdate('fast_mode_test');
                console.log('Content display update triggered with fast mode context');
            } else if (appState.isIndexing) {
                console.log('Session active but fast mode not active - you can test by enabling fast mode');
            } else {
                console.log('No active session - start indexing and enable fast mode to test');
            }
            
            // Test 3: Content display data structure
            console.log('\nTest 3: Content display data structure');
            const testData = {
                playedContent: [],
                currentShow: appState.detectedShow,
                elapsedTime: 0,
                fastModeActive: appState.fastMode && appState.fastMode.active,
                preserveAllContent: true
            };
            console.log('Test content data structure:', testData);
            
            console.log('\n=== END FAST MODE AND CHANNEL FIXES TEST ===');
        }

        window.initializeTransitionSystem = initializeTransitionSystem;
        window.debugTransitionSystem = debugTransitionSystem;
        window.startIndexingWithTransitionSystem = startIndexingWithTransitionSystem;
        window.transitionToShowWithSystem = transitionToShowWithSystem;
        window.completeSessionWithTransitionSystem = completeSessionWithTransitionSystem;
        window.testMultipleTransitions = testMultipleTransitions;
        window.testAutomaticTransitions = testAutomaticTransitions;
        window.testFastModeAndChannelFixes = testFastModeAndChannelFixes;
        
        // NEW: Simple test function for channel protection
        function testChannelProtection() {
            console.log('=== SIMPLE CHANNEL PROTECTION TEST ===');
            console.log('Current state:', {
                isIndexing: appState.isIndexing,
                channelExpanded: appState.channelExpanded,
                userInitiated: appState.userInitiatedChannelChange
            });
            
            if (!appState.isIndexing) {
                console.log('‚ùå No active session - start indexing first');
                return;
            }
            
            const originalState = appState.channelExpanded;
            
            // Test 1: Automatic change (should be blocked)
            console.log('\n1. Testing automatic change (should be blocked):');
            appState.userInitiatedChannelChange = false;
            setChannelExpansionState(!originalState);
            
            if (appState.channelExpanded === originalState) {
                console.log('‚úÖ PASS: Automatic change was blocked');
            } else {
                console.log('‚ùå FAIL: Automatic change was allowed');
            }
            
            // Test 2: User-initiated change (should work)
            console.log('\n2. Testing user-initiated change (should work):');
            appState.userInitiatedChannelChange = true;
            setChannelExpansionState(!originalState);
            
            if (appState.channelExpanded !== originalState) {
                console.log('‚úÖ PASS: User-initiated change worked');
            } else {
                console.log('‚ùå FAIL: User-initiated change was blocked');
            }
            
            // Restore original state
            appState.userInitiatedChannelChange = true;
            setChannelExpansionState(originalState);
            
            console.log('\n=== END SIMPLE TEST ===');
        }
        
        window.testChannelProtection = testChannelProtection;
        
        // NEW: Test function to verify content preservation during indexing start
        function testContentPreservationOnIndexingStart() {
            console.log('=== TESTING CONTENT PRESERVATION ON INDEXING START ===');
            
            if (appState.isIndexing) {
                console.log('‚ùå Session already active - stop indexing first to test');
                return;
            }
            
            // Check if channel has content before starting
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel iframe not found or not loaded');
                return;
            }
            
            console.log('‚úÖ Channel iframe found');
            console.log('1. Check if channel has content before starting indexing');
            console.log('2. Start indexing');
            console.log('3. Verify content is preserved');
            
            // Start indexing and monitor
            console.log('\nStarting indexing session...');
            startIndexing();
            
            // Check content after a brief delay
            setTimeout(() => {
                console.log('\nChecking content preservation after indexing start...');
                
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    const programTrack = iframeDocument.getElementById('program-track');
                    
                    if (programTrack) {
                        const programSlots = programTrack.querySelectorAll('.program-slot');
                        console.log(`Program track found with ${programSlots.length} slots`);
                        
                        const visibleSlots = Array.from(programSlots).filter(slot => 
                            slot.style.display !== 'none' && slot.style.visibility !== 'hidden'
                        );
                        
                        console.log(`${visibleSlots.length} slots are visible`);
                        
                        if (visibleSlots.length > 0) {
                            console.log('‚úÖ PASS: Content preserved during indexing start');
                            visibleSlots.slice(0, 3).forEach((slot, index) => {
                                const title = slot.querySelector('.program-title')?.textContent || 'Unknown';
                                console.log(`  Slot ${index + 1}: ${title}`);
                            });
                        } else {
                            console.log('‚ùå FAIL: All content disappeared during indexing start');
                        }
                    } else {
                        console.log('‚ùå Program track not found in channel');
                    }
                } catch (e) {
                    console.log('‚ùå Cannot access channel content (CORS):', e.message);
                }
                
                console.log('\n=== END CONTENT PRESERVATION TEST ===');
            }, 1000);
        }
        
        window.testContentPreservationOnIndexingStart = testContentPreservationOnIndexingStart;
        
        // NEW: Better test that uses message passing to verify content preservation
        function testContentPreservationViaMsgs() {
            console.log('=== TESTING CONTENT PRESERVATION VIA MESSAGES ===');
            
            if (appState.isIndexing) {
                console.log('‚ùå Session already active - stop indexing first to test');
                return;
            }
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel iframe not found or not loaded');
                return;
            }
            
            let contentBeforeIndexing = [];
            let contentAfterIndexing = [];
            
            // Step 1: Get content before starting indexing
            console.log('Step 1: Getting content before indexing starts...');
            
            // Set up message listener for content responses
            const messageHandler = (event) => {
                if (event.data.type === 'currentContentResponse') {
                    if (contentBeforeIndexing.length === 0) {
                        contentBeforeIndexing = event.data.content || [];
                        console.log(`‚úÖ Content before indexing: ${contentBeforeIndexing.length} items`);
                        
                        if (contentBeforeIndexing.length > 0) {
                            console.log('  First item:', contentBeforeIndexing[0].title);
                            
                            // Step 2: Start indexing
                            console.log('\nStep 2: Starting indexing...');
                            startIndexing();
                            
                            // Step 3: Check content after indexing starts
                            setTimeout(() => {
                                console.log('\nStep 3: Getting content after indexing started...');
                                channelFrame.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
                            }, 1000);
                        } else {
                            console.log('‚ùå No content found before indexing - populate channel first');
                            window.removeEventListener('message', messageHandler);
                        }
                    } else {
                        // This is the response after indexing started
                        contentAfterIndexing = event.data.content || [];
                        console.log(`‚úÖ Content after indexing: ${contentAfterIndexing.length} items`);
                        
                        // Compare results
                        console.log('\n=== COMPARISON RESULTS ===');
                        if (contentAfterIndexing.length === contentBeforeIndexing.length) {
                            console.log('‚úÖ PASS: Same number of content items preserved');
                            console.log(`  Before: ${contentBeforeIndexing.length} items`);
                            console.log(`  After: ${contentAfterIndexing.length} items`);
                            
                            // Check if first item is the same
                            if (contentBeforeIndexing[0] && contentAfterIndexing[0] && 
                                contentBeforeIndexing[0].title === contentAfterIndexing[0].title) {
                                console.log('‚úÖ PASS: First item preserved correctly');
                                console.log(`  Item: ${contentAfterIndexing[0].title}`);
                            } else {
                                console.log('‚ö†Ô∏è WARNING: First item may have changed');
                            }
                        } else {
                            console.log('‚ùå FAIL: Content count changed during indexing start');
                            console.log(`  Before: ${contentBeforeIndexing.length} items`);
                            console.log(`  After: ${contentAfterIndexing.length} items`);
                        }
                        
                        console.log('\n=== END CONTENT PRESERVATION TEST ===');
                        window.removeEventListener('message', messageHandler);
                    }
                }
            };
            
            window.addEventListener('message', messageHandler);
            
            // Request initial content
            channelFrame.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
        }
        
        window.testContentPreservationViaMsgs = testContentPreservationViaMsgs;
        
        // NEW: Test function to validate visual styles and CSS classes
        function testVisualStyles() {
            console.log('=== TESTING VISUAL STYLES AND CSS CLASSES ===');
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel iframe not found or not loaded');
                return;
            }
            
            let testResults = {
                visibility: { pass: 0, fail: 0, total: 0 },
                cssClasses: { pass: 0, fail: 0, total: 0 },
                statusIcons: { pass: 0, fail: 0, total: 0 }
            };
            
            // Set up message listener for style validation
            const styleTestHandler = (event) => {
                if (event.data.type === 'styleValidationResponse') {
                    const results = event.data.results;
                    console.log('\n=== STYLE VALIDATION RESULTS ===');
                    
                    // Test 1: Block Visibility
                    console.log('\n1. Block Visibility Test:');
                    results.blocks.forEach((block, index) => {
                        const isVisible = block.display !== 'none' && block.visibility !== 'hidden';
                        console.log(`  Block ${index + 1} (${block.title}): ${isVisible ? '‚úÖ VISIBLE' : '‚ùå HIDDEN'}`);
                        console.log(`    Display: ${block.display}, Visibility: ${block.visibility}`);
                        
                        testResults.visibility.total++;
                        if (isVisible) testResults.visibility.pass++;
                        else testResults.visibility.fail++;
                    });
                    
                    // Test 2: CSS Classes
                    console.log('\n2. CSS Classes Test:');
                    results.blocks.forEach((block, index) => {
                        console.log(`  Block ${index + 1} (${block.title}):`);
                        console.log(`    Classes: ${block.classes.join(', ') || 'none'}`);
                        
                        testResults.cssClasses.total++;
                        
                        // Check for proper class usage
                        const hasValidClasses = block.classes.includes('program-slot');
                        if (hasValidClasses) {
                            console.log(`    ‚úÖ Has proper base class`);
                            testResults.cssClasses.pass++;
                        } else {
                            console.log(`    ‚ùå Missing base class 'program-slot'`);
                            testResults.cssClasses.fail++;
                        }
                        
                        // Check state classes
                        const stateClasses = block.classes.filter(cls => 
                            ['completed', 'current', 'playing'].includes(cls)
                        );
                        if (stateClasses.length > 0) {
                            console.log(`    State classes: ${stateClasses.join(', ')}`);
                        }
                    });
                    
                    // Test 3: Status Icons
                    console.log('\n3. Status Icons Test:');
                    results.blocks.forEach((block, index) => {
                        testResults.statusIcons.total++;
                        
                        if (block.statusIcon) {
                            console.log(`  Block ${index + 1}: ‚úÖ Has status icon "${block.statusIcon}"`);
                            testResults.statusIcons.pass++;
                        } else {
                            console.log(`  Block ${index + 1}: ‚ö™ No status icon`);
                            // No status icon is not necessarily a failure
                            testResults.statusIcons.pass++;
                        }
                    });
                    
                    // Test 4: Fast Mode Specific Checks
                    if (appState.fastMode && appState.fastMode.active) {
                        console.log('\n4. Fast Mode Specific Tests:');
                        const allVisible = results.blocks.every(block => 
                            block.display !== 'none' && block.visibility !== 'hidden'
                        );
                        console.log(`  All blocks visible in fast mode: ${allVisible ? '‚úÖ PASS' : '‚ùå FAIL'}`);
                    }
                    
                    // Test 5: Indexing State Checks
                    if (appState.isIndexing) {
                        console.log('\n5. Indexing State Tests:');
                        const programTrackVisible = results.programTrackDisplay === 'block';
                        console.log(`  Program track visible during indexing: ${programTrackVisible ? '‚úÖ PASS' : '‚ùå FAIL'}`);
                    }
                    
                    // Summary
                    console.log('\n=== TEST SUMMARY ===');
                    console.log(`Visibility: ${testResults.visibility.pass}/${testResults.visibility.total} passed`);
                    console.log(`CSS Classes: ${testResults.cssClasses.pass}/${testResults.cssClasses.total} passed`);
                    console.log(`Status Icons: ${testResults.statusIcons.pass}/${testResults.statusIcons.total} passed`);
                    
                    const totalTests = testResults.visibility.total + testResults.cssClasses.total + testResults.statusIcons.total;
                    const totalPassed = testResults.visibility.pass + testResults.cssClasses.pass + testResults.statusIcons.pass;
                    
                    console.log(`\nüéØ OVERALL SCORE: ${totalPassed}/${totalTests} tests passed (${Math.round(totalPassed/totalTests*100)}%)`);
                    
                    if (totalPassed === totalTests) {
                        console.log('üéâ ALL TESTS PASSED! Visual styles are working correctly.');
                    } else if (totalPassed / totalTests >= 0.8) {
                        console.log('‚ö†Ô∏è Most tests passed, but some issues detected.');
                    } else {
                        console.log('‚ùå Multiple style issues detected. Review the results above.');
                    }
                    
                    console.log('\n=== END VISUAL STYLES TEST ===');
                    window.removeEventListener('message', styleTestHandler);
                }
            };
            
            window.addEventListener('message', styleTestHandler);
            
            // Request style validation from channel
            console.log('Requesting style validation from channel...');
            channelFrame.contentWindow.postMessage({ type: 'validateStyles' }, '*');
        }
        
        window.testVisualStyles = testVisualStyles;
        
        // NEW: Test styles in different modes (normal, fast mode, indexing)
        function testStylesInAllModes() {
            console.log('=== TESTING STYLES IN ALL MODES ===');
            
            // Test 1: Normal mode (ensure we're not in any special mode)
            console.log('\nüîÑ Testing Normal Mode Styles...');
            if (appState.fastMode) appState.fastMode.active = false;
            if (appState.isIndexing) {
                console.log('‚ö†Ô∏è Currently indexing, stopping for clean test');
                stopIndexing();
                setTimeout(() => testNormalModeStyles(), 1000);
            } else {
                testNormalModeStyles();
            }
            
            function testNormalModeStyles() {
                console.log('üìä Normal Mode - Running style validation...');
                testVisualStyles();
                
                setTimeout(() => {
                    // Test 2: Fast mode
                    console.log('\nüîÑ Testing Fast Mode Styles...');
                    if (!appState.fastMode) appState.fastMode = {};
                    appState.fastMode.active = true;
                    console.log('‚ö° Fast mode activated');
                    
                    // Trigger content update to apply fast mode styles
                    triggerContentDisplayUpdate('fast_mode_test');
                    
                    setTimeout(() => {
                        console.log('üìä Fast Mode - Running style validation...');
                        testVisualStyles();
                        
                        setTimeout(() => {
                            // Test 3: Indexing mode
                            console.log('\nüîÑ Testing Indexing Mode Styles...');
                            appState.fastMode.active = false;
                            
                            // Simulate indexing start
                            if (!appState.isIndexing) {
                                console.log('üé¨ Starting indexing for style test...');
                                startIndexing();
                            }
                            
                            setTimeout(() => {
                                console.log('üìä Indexing Mode - Running style validation...');
                                testVisualStyles();
                                
                                setTimeout(() => {
                                    // Cleanup
                                    console.log('\nüßπ Cleaning up test modes...');
                                    if (appState.fastMode) appState.fastMode.active = false;
                                    if (appState.isIndexing) stopIndexing();
                                    console.log('‚úÖ All mode tests completed!');
                                }, 2000);
                            }, 2000);
                        }, 2000);
                    }, 2000);
                }, 2000);
            }
        }
        
        window.testStylesInAllModes = testStylesInAllModes;
        
        // NEW: Quick style validation test (just checks current state)
        function quickStyleTest() {
            console.log('=== QUICK STYLE VALIDATION ===');
            console.log('Current app state:');
            console.log('- Is indexing:', appState.isIndexing);
            console.log('- Fast mode active:', appState.fastMode?.active || false);
            console.log('- Show detected:', appState.detectedShow?.title || 'None');
            
            testVisualStyles();
        }

        // NEW: Test function for modal activation protection
        function testModalActivationProtection() {
            console.log('=== Testing Modal Activation Protection ===');
            
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel frame not found or not accessible');
                return;
            }
            
            let preModalContent = null;
            let postModalContent = null;
            
            // Step 1: Get content before modal activation
            console.log('üìä Step 1: Getting content before modal activation...');
            channelFrame.contentWindow.postMessage({ 
                type: 'requestContentCount',
                requestId: 'pre-modal'
            }, '*');
            
            // Listen for the response
            const messageHandler = (event) => {
                if (event.data && event.data.type === 'contentCountResponse') {
                    if (event.data.requestId === 'pre-modal') {
                        preModalContent = event.data.content;
                        console.log(`‚úÖ Pre-modal: ${preModalContent.count} content items`);
                        console.log('Pre-modal items:', preModalContent.items.map(item => item.title));
                        
                                                // Step 2: Simulate modal button click (Continue with Rumi)
                        console.log('üîÑ Step 2: Simulating modal button click (Continue with Rumi)...');
                        
                        // Simulate what happens when user clicks "Continue with Rumi" button
                        setTimeout(() => {
                            console.log('Simulating "Continue with Rumi" button click...');
                            // This is what the actual button click does
                            appState.userInitiatedChannelChange = true;
                            showGenreChannel();
                            
                            // Step 3: Get content after modal activation
                            setTimeout(() => {
                                console.log('üìä Step 3: Getting content after modal activation...');
                                channelFrame.contentWindow.postMessage({ 
                                    type: 'requestContentCount',
                                    requestId: 'post-modal'
                                }, '*');
                            }, 1000);
                        }, 500);
                        
                    } else if (event.data.requestId === 'post-modal') {
                        postModalContent = event.data.content;
                        console.log(`‚úÖ Post-modal: ${postModalContent.count} content items`);
                        console.log('Post-modal items:', postModalContent.items.map(item => item.title));
                        
                        // Step 4: Compare results
                        console.log('üîç Step 4: Comparing results...');
                        const contentLoss = preModalContent.count - postModalContent.count;
                        
                        if (contentLoss === 0) {
                            console.log('‚úÖ SUCCESS: No content loss during modal activation!');
                            console.log(`‚úÖ Content preserved: ${preModalContent.count} ‚Üí ${postModalContent.count}`);
                            
                            // Check if items are identical
                            const preItems = preModalContent.items.map(item => item.title).sort();
                            const postItems = postModalContent.items.map(item => item.title).sort();
                            const itemsIdentical = JSON.stringify(preItems) === JSON.stringify(postItems);
                            
                            if (itemsIdentical) {
                                console.log('‚úÖ Content identical: Modal protection working correctly');
                            } else {
                                console.log('‚ö†Ô∏è Content different: Items changed during modal activation');
                                console.log('Pre-modal:', preItems);
                                console.log('Post-modal:', postItems);
                            }
                        } else {
                            console.log(`‚ùå CONTENT LOSS: Lost ${contentLoss} items during modal activation`);
                            console.log(`‚ùå Content changed: ${preModalContent.count} ‚Üí ${postModalContent.count}`);
                            console.log('‚ùå Modal protection may not be working correctly');
                        }
                        
                        // Cleanup
                        window.removeEventListener('message', messageHandler);
                        console.log('=== Modal Protection Test Complete ===');
                    }
                }
            };
            
            window.addEventListener('message', messageHandler);
        }
        
        window.quickStyleTest = quickStyleTest;

        // NEW: Test function for vertical layout stability
        function testVerticalLayoutStability() {
            console.log('=== Testing Vertical Layout Stability ===');
            
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel frame not found or not accessible');
                return;
            }
            
            let initialPositions = [];
            let testCount = 0;
            const maxTests = 5;
            
            // Function to get current positions
            function getCurrentPositions() {
                return new Promise((resolve) => {
                    const messageHandler = (event) => {
                        if (event.data && event.data.type === 'layoutPositionsResponse') {
                            window.removeEventListener('message', messageHandler);
                            resolve(event.data.positions);
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    channelFrame.contentWindow.postMessage({ type: 'getLayoutPositions' }, '*');
                    
                    // Timeout after 2 seconds
                    setTimeout(() => {
                        window.removeEventListener('message', messageHandler);
                        resolve(null);
                    }, 2000);
                });
            }
            
            // Function to run a single test
            async function runLayoutTest() {
                testCount++;
                console.log(`\nüìä Layout Test ${testCount}/${maxTests}:`);
                
                // Get current positions
                const positions = await getCurrentPositions();
                if (!positions) {
                    console.log('‚ùå Could not get layout positions');
                    return false;
                }
                
                console.log(`Found ${positions.length} content blocks`);
                positions.forEach((pos, index) => {
                    console.log(`  Block ${index + 1}: top=${pos.top}px, left=${pos.left}%, height=${pos.height}px`);
                });
                
                if (testCount === 1) {
                    // Store initial positions
                    initialPositions = positions;
                    console.log('‚úÖ Initial positions recorded');
                    return true;
                } else {
                    // Compare with initial positions
                    let layoutStable = true;
                    
                    if (positions.length !== initialPositions.length) {
                        console.log(`‚ùå Content count changed: ${initialPositions.length} ‚Üí ${positions.length}`);
                        layoutStable = false;
                    } else {
                        for (let i = 0; i < positions.length; i++) {
                            const initial = initialPositions[i];
                            const current = positions[i];
                            
                            // Check for vertical shifts (top position changes)
                            if (Math.abs(current.top - initial.top) > 1) {
                                console.log(`‚ùå Block ${i + 1} shifted vertically: ${initial.top}px ‚Üí ${current.top}px`);
                                layoutStable = false;
                            }
                            
                            // Check for height changes
                            if (Math.abs(current.height - initial.height) > 1) {
                                console.log(`‚ö†Ô∏è Block ${i + 1} height changed: ${initial.height}px ‚Üí ${current.height}px`);
                            }
                        }
                    }
                    
                    if (layoutStable) {
                        console.log('‚úÖ Layout stable - no vertical shifts detected');
                    }
                    
                    return layoutStable;
                }
            }
            
            // Function to trigger UI updates (simulating playback)
            function triggerUIUpdates() {
                console.log('üîÑ Triggering UI updates to simulate playback...');
                
                // Trigger various updates that might cause layout shifts
                updateUI();
                triggerContentDisplayUpdate('layout_test');
                
                // Update points display
                if (typeof updatePointsDisplay === 'function') {
                    updatePointsDisplay();
                }
                
                // Update progress if in session
                if (appState.isIndexing) {
                    updateProgress();
                }
            }
            
            // Run the test sequence
            async function runTestSequence() {
                console.log('Starting vertical layout stability test...');
                
                // Initial measurement
                const initialTest = await runLayoutTest();
                if (!initialTest) {
                    console.log('‚ùå Failed to get initial layout measurements');
                    return;
                }
                
                let allTestsPassed = true;
                
                // Run tests with UI updates
                for (let i = 2; i <= maxTests; i++) {
                    // Trigger UI updates
                    triggerUIUpdates();
                    
                    // Wait for updates to complete
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Test layout stability
                    const testPassed = await runLayoutTest();
                    if (!testPassed) {
                        allTestsPassed = false;
                    }
                }
                
                // Final summary
                console.log('\nüéØ VERTICAL LAYOUT STABILITY TEST RESULTS:');
                if (allTestsPassed) {
                    console.log('‚úÖ ALL TESTS PASSED: Layout is stable during playback');
                    console.log('‚úÖ No vertical shifting detected in content boxes');
                } else {
                    console.log('‚ùå SOME TESTS FAILED: Vertical layout shifts detected');
                    console.log('‚ùå Content boxes are shifting during playback');
                }
                
                console.log('=== Vertical Layout Test Complete ===');
            }
            
            runTestSequence();
        }
        
        // NEW: Test function to validate content preservation during show transitions
        function testTransitionContentPreservation() {
            console.log('=== TESTING TRANSITION CONTENT PRESERVATION ===');
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('‚ùå Channel iframe not found or not loaded');
                return;
            }
            
            // Variables to store test data across handler calls
            let preTransitionCount = 0;
            let preTransitionItems = [];
            let previousShow = null;
            
            // First, get the current content count
            console.log('Step 1: Getting current content before transition...');
            
            const transitionTestHandler = (event) => {
                if (event.data.type === 'contentCountResponse' && event.data.testContext === 'pre-transition') {
                    preTransitionCount = event.data.count;
                    preTransitionItems = event.data.items;
                    
                    console.log(`Pre-transition content: ${preTransitionCount} items`);
                    console.log('Pre-transition items:', preTransitionItems);
                    
                    // Now simulate a show transition
                    console.log('\nStep 2: Simulating show transition...');
                    
                    // Create a test transition
                    const testNewShow = {
                        title: 'Test Transition Show',
                        season: 'S1',
                        episode: 'E1',
                        duration: 45,
                        service: 'Test Service'
                    };
                    
                    // Mark as transitioning
                    appState.isTransitioning = true;
                    
                    // Update detected show
                    previousShow = appState.detectedShow;
                    appState.detectedShow = testNewShow;
                    
                    // Trigger a show transition content update
                    triggerContentDisplayUpdate('show_transition');
                    
                    // Wait a moment for the transition to process
                    setTimeout(() => {
                        console.log('\nStep 3: Checking content after transition...');
                        
                        // Request content count again
                        channelFrame.contentWindow.postMessage({
                            type: 'contentCountRequest',
                            testContext: 'post-transition'
                        }, '*');
                        
                        // Clean up transition state
                        appState.isTransitioning = false;
                        appState.detectedShow = previousShow; // Restore original show
                        
                    }, 1000);
                    
                } else if (event.data.type === 'contentCountResponse' && event.data.testContext === 'post-transition') {
                    const postTransitionCount = event.data.count;
                    const postTransitionItems = event.data.items;
                    
                    console.log(`Post-transition content: ${postTransitionCount} items`);
                    console.log('Post-transition items:', postTransitionItems);
                    
                    // Compare results
                    console.log('\n=== TRANSITION PRESERVATION RESULTS ===');
                    
                    if (postTransitionCount === 0) {
                        console.log('‚ùå CRITICAL ISSUE: All content disappeared during transition!');
                        console.log('This confirms the reported bug.');
                    } else if (postTransitionCount < preTransitionCount) {
                        console.log(`‚ö†Ô∏è CONTENT LOSS: ${preTransitionCount - postTransitionCount} items lost during transition`);
                        console.log('Some content preservation working, but not complete.');
                    } else if (postTransitionCount === preTransitionCount) {
                        console.log('‚úÖ CONTENT PRESERVED: All items maintained during transition');
                        console.log('Transition content preservation is working correctly!');
                        
                        // Check if items are the same
                        const itemsMatch = preTransitionItems.length === postTransitionItems.length &&
                            preTransitionItems.every((item, index) => 
                                item.title === postTransitionItems[index]?.title
                            );
                        
                        if (itemsMatch) {
                            console.log('‚úÖ CONTENT IDENTICAL: Same items in same order');
                        } else {
                            console.log('üîÑ CONTENT REORDERED: Same count but different order/items');
                        }
                    } else {
                        console.log(`üîÑ CONTENT CHANGED: ${postTransitionCount - preTransitionCount} items difference`);
                        console.log('Content may have been updated rather than lost.');
                    }
                    
                    // Additional debugging info
                    console.log('\nDetailed comparison:');
                    console.log('Before:', preTransitionItems.map(item => item.title));
                    console.log('After:', postTransitionItems.map(item => item.title));
                    
                    console.log('\n=== END TRANSITION PRESERVATION TEST ===');
                    window.removeEventListener('message', transitionTestHandler);
                }
            };
            
            window.addEventListener('message', transitionTestHandler);
            
            // Start the test by requesting current content
            channelFrame.contentWindow.postMessage({
                type: 'contentCountRequest',
                testContext: 'pre-transition'
            }, '*');
        }
        
        window.testTransitionContentPreservation = testTransitionContentPreservation;
        // Update points display
    </script>
</body>
</html> 