<!DOCTYPE html>
<!-- CACHE BUST: v1.3 - Fixed duplicate content issue - 2025-06-24 01:00 - FORCE RELOAD -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Rumi Genre Channel</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=SF+Mono:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
            background: #000000;
            color: #ffffff;
            padding: 16px;
        }

        .container {
            max-width: 520px;
            margin: 0 auto;
            background: #111111;
            border: 2px solid #333333;
            border-radius: 8px;
            overflow: hidden;
        }

        .header {
            background: #000000;
            padding: 16px;
            border-bottom: 1px solid #333333;
        }

        .rumi-logo {
            font-weight: 700;
            font-size: 16px;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .timeline-container {
            margin-bottom: 10px;
            overflow: hidden;
            max-width: 100%;
            position: relative;
        }

        .program-track-container {
            overflow: hidden;
            margin-bottom: 10px;
            max-width: 100%;
            position: relative;
        }

        .timeline {
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            border-radius: 6px;
            padding: 6px 10px;
            position: relative;
            margin-bottom: 6px;
            border: 1px solid #333333;
            width: 100%;
            transition: width 0.3s ease;
            min-width: 100%;
            max-width: 100%;
            flex-shrink: 0;
        }

        .timeline.expanded {
            border-color: #00ff41;
            background: #1a2a1a;
        }

        .timeline-row {
            display: flex;
            align-items: center;
            width: 100%;
            min-width: 100%;
        }

        .timeline-marker {
            flex: 1;
            text-align: center;
            font-size: 7px;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: relative;
            padding: 3px 0;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-marker:first-child {
            text-align: left;
        }

        .timeline-marker::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 3px;
            background: #333333;
        }

        .timeline-marker:first-child::after {
            left: 0; /* Align the tick mark with the text */
            transform: translateX(0);
        }

        .timeline-marker:last-child {
            text-align: right;
        }

        .timeline-marker:last-child::after {
            left: auto; /* Unset the left property */
            right: 0;   /* Align the tick mark to the right */
            transform: translateX(0);
        }

        .timeline-marker.multiplier {
            color: #00ff41;
            font-weight: 600;
        }

        .timeline-marker.info {
            color: #888888;
            font-size: 7px;
            letter-spacing: 0.3px;
        }

        .timeline-info {
            position: absolute;
            top: -25px;
            left: 10px;
            font-size: 7px;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .multiplier-display {
            position: absolute;
            top: -20px;
            right: 10px;
            font-size: 7px;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .channel-section {
            padding: 16px;
        }

        .channel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .channel-title-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .channel-title {
            font-size: 12px;
            font-weight: 600;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .edit-link {
            font-size: 9px;
            color: #00ff41;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .edit-link:hover {
            color: #00cc33;
        }

        .channel-controls {
            display: flex;
            gap: 6px;
        }

        .btn {
            background: #000000;
            color: #ffffff;
            border: 1px solid #333333;
            padding: 5px 10px;
            font-size: 9px;
            font-family: 'SF Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            border-color: #00ff41;
            color: #00ff41;
        }

        .btn.primary {
            background: #00ff41;
            color: #000000;
            border-color: #00ff41;
        }

        .btn.primary:hover {
            background: #00cc33;
        }

        .btn-group {
            display: flex;
            gap: 3px;
        }

        .program-track {
            display: flex;
            background: #1a1a1a;
            border-radius: 6px;
            overflow: visible;
            min-height: 70px;
            height: 70px; /* LAYOUT FIX: Fixed height to prevent vertical shifting */
            position: relative;
            width: 100%;
            transition: width 0.3s ease;
            min-width: 100%;
            max-width: 100%;
            border: 2px solid #333; /* DEBUG: Add border to see container */
        }

        .program-slot {
            position: absolute;
            padding: 10px;
            border: 1px solid #333333;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: visible;
            background: #1a1a1a;
            min-height: 50px; /* DEBUG: Ensure minimum height */
            min-width: 80px; /* DEBUG: Ensure minimum width */
            box-sizing: border-box; /* LAYOUT FIX: Consistent box model */
            top: 0; /* LAYOUT FIX: Default top position */
            height: 100%; /* LAYOUT FIX: Fill container height */
        }

        .program-slot:hover {
            background: #222222;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .program-slot.has-overflow:hover {
            transform: scaleX(var(--scale-factor, 2.0));
            transform-origin: var(--hover-transform-origin, left center);
            padding-left: calc(10px / var(--scale-factor, 2.0));
            padding-right: calc(10px / var(--scale-factor, 2.0));
            z-index: 20;
        }

        .program-slot.no-overflow:hover {
            /* No scaling for blocks without overflow */
        }

        .program-slot:hover .remove-btn {
            opacity: 1;
        }

        /* Make remove button always visible for shorter content blocks */
        .program-slot.no-overflow .remove-btn {
            opacity: 0.7;
        }

        .program-slot.no-overflow:hover .remove-btn {
            opacity: 1;
        }

        .program-slot.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: transparent;
            border: 2px dashed #333333;
            z-index: 1;
        }

        .program-slot.empty:hover {
            border-color: #00ff41;
            color: #00ff41;
        }

        .program-title {
            font-size: 10px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 3px;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .program-slot.has-overflow:hover .program-title {
            /* Counter-scale to prevent text stretching and reveal overflow */
            transform: scaleX(var(--counter-scale-factor, 0.5));
            transform-origin: left center; /* Always scale from the left */
            overflow: visible;
        }

        .program-meta {
            font-size: 8px;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .program-service {
            font-size: 7px;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .program-slot.has-overflow:hover .program-meta,
        .program-slot.has-overflow:hover .program-service {
            /* Counter-scale to prevent text stretching and reveal overflow */
            transform: scaleX(var(--counter-scale-factor, 0.5));
            transform-origin: left center; /* Always scale from the left */
            overflow: visible;
        }

        /* Transition state styles for program slots */
        .program-slot.completed {
            opacity: 0.7;
            background: #2a2a2a;
            border: 1px solid #444;
        }
        
        .program-slot.current {
            transform: scale(1.02);
            box-shadow: 0 0 8px rgba(0, 255, 65, 0.4);
            border: 2px solid #00ff41;
            background: #1a2a1a;
        }
        
        .program-slot.playing {
            /* Additional styles for playing state if needed */
        }
        
        /* Only show green border on first slot if it's marked as current/playing */
        .program-slot:first-child.current,
        .program-slot:first-child.playing {
            border-color: #00ff41;
        }
        
        /* Status icon styles */
        .status-icon {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 8px;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }
        
        .program-slot.completed .status-icon {
            color: #00ff41;
        }
        
        .program-slot.current .status-icon,
        .program-slot.playing .status-icon {
            color: #00ff41;
        }

        .remove-btn {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #ff4444;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .remove-btn:hover {
            background: #ff6666;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            z-index: 60;
        }

        .remove-btn.protected {
            background: #666666;
            color: #cccccc;
            cursor: not-allowed;
            opacity: 0.3;
        }

        .remove-btn.protected:hover {
            background: #666666;
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .program-slot.has-overflow:hover .remove-btn {
            /* Counter-scale and position correctly */
            transform: scaleX(var(--counter-scale-factor, 0.5));
            transform-origin: right center; /* Always scale from the right */
            right: calc(3px / var(--scale-factor, 2.0));
            z-index: 50;
        }

        .program-slot.has-overflow:hover .remove-btn:hover {
            /* Ensure hover state works even with scaling */
            z-index: 60;
            transform: scaleX(var(--counter-scale-factor, 0.5)) scale(1.1);
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 10px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 8px;
            color: #888;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .selector {
            width: 100%;
            background: #000000;
            color: #ffffff;
            border: 1px solid #333333;
            padding: 6px 10px;
            font-size: 9px;
            font-family: 'SF Mono', monospace;
            border-radius: 4px;
        }

        .selector:focus {
            outline: none;
            border-color: #00ff41;
        }

        .search-input {
            width: 100%;
            background: #000000;
            color: #ffffff;
            border: 1px solid #333333;
            padding: 6px 10px;
            font-size: 9px;
            font-family: 'SF Mono', monospace;
            border-radius: 4px;
        }

        .search-input:focus {
            outline: none;
            border-color: #00ff41;
        }

        .search-results {
            max-height: 150px;
            overflow-y: auto;
            background: #000000;
            border: 1px solid #333333;
            border-radius: 4px;
            margin-top: 6px;
        }

        .result-item {
            padding: 6px 10px;
            cursor: pointer;
            border-bottom: 1px solid #222222;
            transition: background 0.2s;
        }

        .result-item:hover {
            background: #222222;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-title {
            font-size: 9px;
            color: #ffffff;
            margin-bottom: 2px;
        }

        .result-meta {
            font-size: 7px;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .queue-section {
            background: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 12px;
            margin-top: 16px;
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .queue-title {
            font-size: 11px;
            font-weight: 600;
            color: #00ff41;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .queue-summary {
            font-size: 9px;
            color: #888888;
        }

        .queue-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #000000;
            border-radius: 4px;
            border: 1px solid #333333;
        }

        .queue-item-info {
            flex: 1;
        }

        .queue-item-title {
            font-size: 9px;
            color: #ffffff;
            margin-bottom: 2px;
        }

        .queue-item-meta {
            font-size: 7px;
            color: #888888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .queue-remove-btn {
            background: none;
            border: none;
            color: #ff4444;
            cursor: pointer;
            font-size: 11px;
            padding: 3px;
        }

        .queue-remove-btn:hover {
            color: #ff6666;
        }

        .program-slot.is-cropped::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 40px; /* Reduced width for smaller extension */
            background: linear-gradient(to left, #1a1a1a 40%, transparent);
            pointer-events: none; /* Ensure it doesn't block mouse events */
        }

        /* Edit mode styles */
        .edit-mode {
            border-color: #00ff41;
            box-shadow: 0 0 0 1px #00ff41;
        }

        .edit-submenu {
            background: #1a1a1a;
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            display: none;
        }

        .edit-submenu.visible {
            display: block;
        }

        .edit-submenu-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .edit-submenu-controls {
            display: flex;
            gap: 6px;
            align-items: flex-end;
        }

        .edit-btn {
            background: #333333;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 6px 12px;
            font-size: 9px;
            font-family: 'SF Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 4px;
            white-space: nowrap;
        }

        .edit-btn:hover {
            background: #00ff41;
            color: #000000;
        }

        .edit-btn.cancel {
            background: #333333;
            color: #888888;
            border-color: #666666;
        }

        .edit-btn.cancel:hover {
            background: #666666;
            color: #ffffff;
        }

        .edit-submenu .form-group {
            flex: 1;
            min-width: 0;
        }

        .edit-submenu .edit-submenu-controls {
            flex-shrink: 0;
        }

        /* Responsive adjustments for very small screens */
        @media (max-width: 540px) {
            .edit-submenu-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .edit-submenu-controls {
                justify-content: flex-end;
                margin-top: 8px;
            }
            
            .form-row {
                flex-direction: column;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="channel-section">
            <div class="channel-header">
                <div class="channel-title-section">
                    <div class="channel-title">GENRE CHANNEL</div>
                    <div class="edit-link" onclick="toggleEditPanel()">EDIT GENRE</div>
                </div>
            </div>

            <div class="timeline-container" id="timeline-container">
                <div class="timeline" id="timeline">
                    <div class="timeline-row" id="timeline-markers">
                        <div class="timeline-marker">0</div>
                        <div class="timeline-marker">30</div>
                        <div class="timeline-marker">60</div>
                        <div class="timeline-marker">90</div>
                        <div class="timeline-marker">120</div>
                        <div class="timeline-marker">150</div>
                        <div class="timeline-marker">180</div>
                    </div>
                    <div class="timeline-row" id="multiplier-markers">
                        <div class="timeline-marker multiplier" style="color: #00ff41; font-weight: 600;">1.0x</div>
                        <div class="timeline-marker multiplier" style="color: #ffaa00; font-weight: 600;">1.2x</div>
                        <div class="timeline-marker multiplier" style="color: #a985ff; font-weight: 600;">1.8x</div>
                    </div>
                </div>
                <div class="multiplier-display" id="multiplier-display">1.0x</div>

                <!-- Auto-Populate by Genre Submenu -->
                <div class="edit-submenu" id="auto-populate-submenu">
                    <div class="edit-submenu-row">
                        <div class="form-group">
                            <label>SELECT GENRE</label>
                            <select class="selector" id="genre-select-submenu" onchange="handleGenreChangeSubmenu(this)">
                                <option value="">Choose a genre...</option>
                                <option value="Comedy">Comedy</option>
                                <option value="Sitcom">Sitcom</option>
                                <option value="Standup">Standup</option>
                                <option value="Sketch">Sketch</option>
                                <option value="Parody">Parody</option>
                                <option value="Drama">Drama</option>
                                <option value="Reality">Reality</option>
                                <option value="Thriller">Thriller</option>
                                <option value="Sci-Fi">Sci-Fi</option>
                                <option value="Horror">Horror</option>
                                <option value="Documentary">Documentary</option>
                                <option value="Animation">Animation</option>
                            </select>
                        </div>
                        <div class="edit-submenu-controls">
                            <button class="edit-btn" onclick="autoPopulate()">AUTO-POPULATE</button>
                            <button class="edit-btn cancel" onclick="cancelEdit()">CANCEL</button>
                        </div>
                    </div>
                </div>

                <!-- Add Individual Content Submenu -->
                <div class="edit-submenu" id="individual-content-submenu">
                    <div class="edit-submenu-row">
                        <div class="form-group">
                            <label>SEARCH</label>
                            <input type="text" class="search-input" id="search-input-submenu" placeholder="Search shows and movies..." oninput="searchContentSubmenu()">
                        </div>
                        <div class="form-group">
                            <label>OR CHOOSE FROM GENRE</label>
                            <select class="selector" id="content-dropdown-submenu" onchange="selectContentSubmenu()">
                                <option value="">Select content...</option>
                            </select>
                        </div>
                        <div class="edit-submenu-controls">
                            <button class="edit-btn" onclick="addContentSubmenu()">ADD</button>
                            <button class="edit-btn cancel" onclick="cancelEdit()">CANCEL</button>
                        </div>
                    </div>
                    <div class="search-results" id="search-results-submenu" style="display: none;"></div>
                </div>
            </div>

            <div class="program-track-container">
                <div class="program-track" id="program-track">
                    <div class="program-slot empty" onclick="openAddContentMode()">
                        + ADD SHOW
                    </div>
                </div>
            </div>

            <div class="queue-section" id="queue-section" style="display: none;">
                <div class="queue-header">
                    <div class="queue-title">QUEUE</div>
                    <div class="queue-summary" id="queue-summary">0 items â€¢ 0 min</div>
                </div>
                <div class="queue-items" id="queue-items"></div>
            </div>
        </div>
    </div>

    <script>
        console.log('Genre Channel script starting...');
        
        // Timeline configuration
        const TIMELINE_DURATION = 180; // 180 minutes total timeline
        let currentTimelineDuration = TIMELINE_DURATION; // Dynamic timeline duration

        // Content database by genre with enhanced information
        const genreContent = {
            'Comedy': [
                {title: 'The Office', type: 'show', duration: 22, service: 'PEACOCK', season: 'S3', episode: 'E20'},
                {title: 'Parks and Recreation', type: 'show', duration: 22, service: 'PEACOCK', season: 'S3', episode: 'E7'},
                {title: 'Community', type: 'show', duration: 22, service: 'NETFLIX', season: 'S2', episode: 'E14'},
                {title: '30 Rock', type: 'show', duration: 22, service: 'HULU', season: 'S5', episode: 'E10'},
                {title: 'Arrested Development', type: 'show', duration: 22, service: 'NETFLIX', season: 'S1', episode: 'E1'},
                {title: 'Veep', type: 'show', duration: 28, service: 'HBO MAX', season: 'S4', episode: 'E6'}
            ],
            'Sitcom': [
                {title: 'The Office', type: 'show', duration: 22, service: 'NETFLIX', season: 'S2', episode: 'E7'},
                {title: 'Parks & Rec', type: 'show', duration: 22, service: 'HULU', season: 'S3', episode: 'E4'},
                {title: 'Brooklyn 99', type: 'show', duration: 22, service: 'HULU', season: 'S4', episode: 'E12'},
                {title: '30 Rock', type: 'show', duration: 22, service: 'HULU', season: 'S5', episode: 'E8'},
                {title: 'Friends', type: 'show', duration: 22, service: 'HBO MAX', season: 'S6', episode: 'E15'},
                {title: 'Seinfeld', type: 'show', duration: 22, service: 'NETFLIX', season: 'S4', episode: 'E11'},
                {title: 'Modern Family', type: 'show', duration: 22, service: 'HULU', season: 'S7', episode: 'E3'},
                {title: 'Anchorman', type: 'movie', duration: 94, service: 'NETFLIX'}
            ],
            'Standup': [
                {title: 'Dave Chappelle', type: 'show', duration: 60, service: 'NETFLIX'},
                {title: 'John Mulaney', type: 'show', duration: 65, service: 'NETFLIX'},
                {title: 'Ali Wong', type: 'show', duration: 55, service: 'NETFLIX'},
                {title: 'Hannibal Buress', type: 'show', duration: 58, service: 'NETFLIX'},
                {title: 'Kevin Hart', type: 'show', duration: 60, service: 'NETFLIX'},
                {title: 'Tig Notaro', type: 'show', duration: 55, service: 'NETFLIX'},
                {title: 'The Hangover', type: 'movie', duration: 100, service: 'HBO MAX'}
            ],
            'Sketch': [
                {title: 'SNL', type: 'show', duration: 90, service: 'HULU', season: 'S47', episode: 'E15'},
                {title: 'Key & Peele', type: 'show', duration: 22, service: 'NETFLIX', season: 'S3', episode: 'E8'},
                {title: 'I Think You Should Leave', type: 'show', duration: 15, service: 'NETFLIX', season: 'S2', episode: 'E4'},
                {title: 'A Black Lady Sketch Show', type: 'show', duration: 30, service: 'HBO MAX', season: 'S3', episode: 'E6'},
                {title: 'Scary Movie', type: 'movie', duration: 88, service: 'HULU'}
            ],
            'Parody': [
                {title: 'Scary Movie', type: 'movie', duration: 88, service: 'HULU'},
                {title: 'Not Another Teen Movie', type: 'movie', duration: 89, service: 'NETFLIX'},
                {title: 'Airplane!', type: 'movie', duration: 88, service: 'HULU'},
                {title: 'The Naked Gun', type: 'movie', duration: 85, service: 'HULU'},
                {title: 'Key & Peele', type: 'show', duration: 22, service: 'NETFLIX', season: 'S3', episode: 'E8'}
            ],
            'Drama': [
                {title: 'The Crown', type: 'show', duration: 58, service: 'NETFLIX', season: 'S6', episode: 'E10'},
                {title: 'Breaking Bad', type: 'show', duration: 47, service: 'NETFLIX', season: 'S5', episode: 'E16'},
                {title: 'Succession', type: 'show', duration: 60, service: 'HBO MAX', season: 'S3', episode: 'E9'},
                {title: 'The Sopranos', type: 'show', duration: 55, service: 'HBO MAX', season: 'S1', episode: 'E1'},
                {title: 'Mad Men', type: 'show', duration: 48, service: 'AMC+', season: 'S1', episode: 'E1'},
                {title: 'The Wire', type: 'show', duration: 60, service: 'HBO MAX', season: 'S1', episode: 'E1'}
            ],
            'Reality': [
                {title: 'Survivor', type: 'show', duration: 60, service: 'PARAMOUNT+', season: 'S42', episode: 'E13'},
                {title: 'The Bachelor', type: 'show', duration: 120, service: 'HULU', season: 'S26', episode: 'E10'},
                {title: 'Top Chef', type: 'show', duration: 60, service: 'BRAVO', season: 'S19', episode: 'E15'},
                {title: 'Amazing Race', type: 'show', duration: 60, service: 'PARAMOUNT+', season: 'S33', episode: 'E12'}
            ],
            'Crime': [
                {title: 'True Detective', type: 'show', duration: 60, service: 'HBO MAX', season: 'S3', episode: 'E8'},
                {title: 'Mindhunter', type: 'show', duration: 60, service: 'NETFLIX', season: 'S2', episode: 'E9'},
                {title: 'The Wire', type: 'show', duration: 60, service: 'HBO MAX', season: 'S5', episode: 'E10'},
                {title: 'Luther', type: 'show', duration: 60, service: 'BRITBOX', season: 'S5', episode: 'E4'}
            ],
            'Sci-Fi': [
                {title: 'Blade Runner 2049', type: 'movie', duration: 164, service: 'HBO MAX'},
                {title: 'Dune', type: 'movie', duration: 155, service: 'HBO MAX'},
                {title: 'The Expanse', type: 'show', duration: 45, service: 'AMAZON', season: 'S1', episode: 'E1'},
                {title: 'Black Mirror', type: 'show', duration: 60, service: 'NETFLIX', season: 'S3', episode: 'E4'},
                {title: 'Westworld', type: 'show', duration: 60, service: 'HBO MAX', season: 'S1', episode: 'E1'},
                {title: 'Severance', type: 'show', duration: 50, service: 'APPLE TV+', season: 'S1', episode: 'E1'}
            ],
            'Horror': [
                {title: 'The Haunting', type: 'show', duration: 60, service: 'NETFLIX', season: 'S2', episode: 'E10'},
                {title: 'Midnight Mass', type: 'show', duration: 60, service: 'NETFLIX', season: 'S1', episode: 'E7'},
                {title: 'The Walking Dead', type: 'show', duration: 45, service: 'AMC+', season: 'S11', episode: 'E24'},
                {title: 'American Horror Story', type: 'show', duration: 45, service: 'HULU', season: 'S10', episode: 'E10'}
            ],
            'Thriller': [
                {title: 'Stranger Things', type: 'show', duration: 51, service: 'NETFLIX', season: 'S4', episode: 'E9'},
                {title: 'Mindhunter', type: 'show', duration: 50, service: 'NETFLIX', season: 'S1', episode: 'E1'},
                {title: 'Ozark', type: 'show', duration: 60, service: 'NETFLIX', season: 'S1', episode: 'E1'},
                {title: 'The Night Of', type: 'show', duration: 78, service: 'HBO MAX', season: 'S1', episode: 'E1'},
                {title: 'Severance', type: 'show', duration: 50, service: 'APPLE TV+', season: 'S1', episode: 'E1'}
            ],
            'Documentary': [
                {title: 'Planet Earth II', type: 'show', duration: 50, service: 'DISCOVERY+', season: 'S1', episode: 'E1'},
                {title: 'My Octopus Teacher', type: 'movie', duration: 85, service: 'NETFLIX'},
                {title: 'The Last Dance', type: 'show', duration: 50, service: 'NETFLIX', season: 'S1', episode: 'E1'},
                {title: 'Free Solo', type: 'movie', duration: 100, service: 'DISNEY+'},
                {title: 'Icarus', type: 'movie', duration: 121, service: 'NETFLIX'},
                {title: 'American Factory', type: 'movie', duration: 110, service: 'NETFLIX'}
            ],
            'Animation': [
                {title: 'BoJack Horseman', type: 'show', duration: 25, service: 'NETFLIX', season: 'S6', episode: 'E16'},
                {title: 'Rick and Morty', type: 'show', duration: 22, service: 'HULU', season: 'S5', episode: 'E10'},
                {title: 'Arcane', type: 'show', duration: 40, service: 'NETFLIX', season: 'S1', episode: 'E9'},
                {title: 'Love Death + Robots', type: 'show', duration: 15, service: 'NETFLIX', season: 'S3', episode: 'E9'}
            ]
        };

        // State management
        let currentContent = [];
        let selectedContent = null;
        let currentGenre = null; // Start with no genre, will be set based on detected show
        let queue = [];
        let hasProcessedCurrentDetectedShow = false; // Track if we've already processed the current detected show
        
        // Edit mode state management
        let editMode = null; // null, 'genre', or 'individual'
        let previousTimelineState = null; // Store timeline state before edit mode

        // === DEBUG: Auto-set genre for testing ===
        const DEBUG_AUTO_GENRE = false; // Set to false to disable
        // =========================================

        document.addEventListener('DOMContentLoaded', function() {
            console.log('Genre Channel loaded and ready');
            
            // Clean up any existing weird content containers
            cleanupWeirdContentContainers();
            
            // DEBUG: Auto-set genre and populate lineup for testing
            if (DEBUG_AUTO_GENRE) {
                currentGenre = 'Sci-Fi';
                createLineup(true);
            }
            
            // Don't auto-populate with a default genre - let user choose
            // if (!currentGenre) {
            //     currentGenre = 'Drama'; // Default to Drama
            //     createLineup(true); // Pass true to indicate initial load
            // }
            
            // Update the dropdowns to reflect the initial state
            updateGenreDropdown(); // This will populate the individual content dropdown

            // --- FIX: Show program track if content exists on load ---
            if (Array.isArray(currentContent) && currentContent.length > 0) {
                document.getElementById('program-track').style.display = 'block';
                updateProgramTrack();
            }
            
            // DEBUG: Force show program track for testing
            console.log('Initial currentContent length:', currentContent.length);
            if (currentContent.length > 0) {
                console.log('Showing program track on load');
                document.getElementById('program-track').style.display = 'block';
                updateProgramTrack();
            }
            // --------------------------------------------------------
            
            // Listen for messages from the parent window (the extension popup)
            window.addEventListener('message', function(event) {
                console.log('Genre Channel received message:', event.data);
                
                if (event.data.type === 'rumi:showDetected') {
                    console.log('=== SHOW DETECTION HANDLER START ===');
                    console.log('Detected show:', event.data.payload);
                    
                    const detectedShow = event.data.payload;
                    
                    // Add null check to prevent TypeError
                    if (!detectedShow) {
                        console.log('No show detected (null payload), skipping genre mapping');
                        console.log('=== SHOW DETECTION HANDLER COMPLETE (NO SHOW) ===');
                        return;
                    }
                    
                    // Map detected show genre to our available genres (case-insensitive)
                    const genreMapping = {
                        'drama': 'Drama',
                        'comedy': 'Comedy', 
                        'thriller': 'Thriller',
                        'sci-fi': 'Sci-Fi',
                        'scifi': 'Sci-Fi',
                        'horror': 'Horror',
                        'action': 'Action',
                        'romance': 'Romance',
                        'documentary': 'Documentary',
                        'animation': 'Animation'
                    };
                    
                    // Convert detected show genre to lowercase for case-insensitive matching
                    const detectedGenreLower = detectedShow.genre ? detectedShow.genre.toLowerCase() : '';
                    const mappedGenre = genreMapping[detectedGenreLower] || 'Drama';
                    if (!genreContent[mappedGenre]) {
                        console.warn('Mapped genre not found in genreContent:', mappedGenre, 'Defaulting to Drama');
                        currentGenre = 'Drama';
                    } else {
                        currentGenre = mappedGenre;
                    }
                    console.log('Final currentGenre set to:', currentGenre);
                    
                    // Update the channel title
                    const channelTitle = document.querySelector('.channel-title');
                    if (channelTitle) {
                        channelTitle.textContent = `${currentGenre.toUpperCase()} CHANNEL`;
                        console.log('Channel title updated to:', channelTitle.textContent);
                    }
                    
                    // Update the genre dropdown
                    const genreSelect = document.getElementById('genre-select');
                    if (genreSelect) {
                        genreSelect.value = currentGenre;
                        console.log('Genre dropdown updated to:', genreSelect.value);
                    }
                    
                    // Add the detected show as the first item in currentContent
                    const detectedShowItem = {
                        title: detectedShow.title,
                        type: 'detected_show',
                        duration: detectedShow.duration || 45,
                        service: 'DETECTED',
                        season: detectedShow.season || '',
                        episode: detectedShow.episode || '',
                        startTime: 0,
                        originalDuration: detectedShow.duration || 45
                    };
                    
                    // Clear existing content and add detected show as first item
                    currentContent = [detectedShowItem];
                    console.log('Added detected show to currentContent:', detectedShowItem);
                    
                    // Create lineup with the new genre
                    console.log('About to call createLineup(true) for auto-population');
                    console.log('Current genre:', currentGenre);
                    console.log('Available genre content:', genreContent[currentGenre] ? genreContent[currentGenre].length : 0, 'items');
                    createLineup(true); // Pass true to indicate this is initial load with detected show
                    
                    console.log('Final currentContent after createLineup:', JSON.stringify(currentContent, null, 2));
                    console.log('Final currentGenre:', currentGenre);
                    console.log('Final hasProcessedCurrentDetectedShow:', hasProcessedCurrentDetectedShow);
                    console.log('=== SHOW DETECTION HANDLER COMPLETE ===');
                    
                    // Send confirmation back to parent that show detection was received and processed
                    window.parent.postMessage({
                        type: 'showDetectionReceived',
                        payload: {
                            showTitle: detectedShow.title,
                            genre: mappedGenre,
                            contentCount: currentContent ? currentContent.length : 0
                        }
                    }, '*');
                }
                
                // NEW: Handle content request from main app
                if (event.data.type === 'requestCurrentContent') {
                    console.log('Received request for current content');
                    
                    // Send current content back to parent
                    window.parent.postMessage({
                        type: 'currentContentResponse',
                        content: currentContent || []
                    }, '*');
                    
                    console.log('Sent current content to parent:', currentContent);
                }

                // NEW: Handle content block updates from main app
                if (event.data.type === 'updateContentBlocks') {
                    console.log('Received content block update:', event.data.data);
                    updateContentBlocksDisplay(event.data.data);
                }
                
                // NEW: Handle style validation requests
                if (event.data.type === 'validateStyles') {
                    console.log('ðŸŽ¨ Channel received style validation request');
                    
                    const programSlots = document.querySelectorAll('.program-slot');
                    const programTrack = document.getElementById('program-track');
                    
                    const blockData = Array.from(programSlots).map(slot => {
                        const computedStyle = window.getComputedStyle(slot);
                        const title = slot.querySelector('.program-title')?.textContent?.trim() || 'Unknown';
                        const statusIcon = slot.querySelector('.status-icon')?.textContent?.trim() || '';
                        
                        return {
                            title: title,
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            opacity: computedStyle.opacity,
                            classes: Array.from(slot.classList),
                            statusIcon: statusIcon,
                            backgroundColor: computedStyle.backgroundColor,
                            color: computedStyle.color,
                            borderColor: computedStyle.borderColor
                        };
                    });
                    
                    const validationResults = {
                        blocks: blockData,
                        programTrackDisplay: programTrack ? window.getComputedStyle(programTrack).display : 'not found',
                        totalBlocks: programSlots.length,
                        timestamp: new Date().toISOString()
                    };
                    
                    console.log('ðŸŽ¨ Sending style validation results:', validationResults);
                    
                    event.source.postMessage({
                        type: 'styleValidationResponse',
                        results: validationResults
                    }, '*');
                }
                
                // NEW: Handle content count requests (for transition testing)
                if (event.data.type === 'contentCountRequest') {
                    console.log('ðŸ“Š Channel received content count request');
                    
                    const programSlots = document.querySelectorAll('.program-slot');
                    const contentItems = Array.from(programSlots).map(slot => {
                        const title = slot.querySelector('.program-title')?.textContent?.trim() || '';
                        const time = slot.querySelector('.program-time')?.textContent?.trim() || '';
                        return { title, time };
                    });
                    
                    console.log(`ðŸ“Š Sending content count response: ${programSlots.length} items`);
                    
                    event.source.postMessage({
                        type: 'contentCountResponse',
                        count: programSlots.length,
                        items: contentItems,
                        testContext: event.data.testContext || null // Pass through test context for transition testing
                    }, '*');
                }
                
                // NEW: Handle layout position requests (for vertical stability testing)
                if (event.data.type === 'getLayoutPositions') {
                    console.log('ðŸ“ Channel received layout position request');
                    
                    const programSlots = document.querySelectorAll('.program-slot:not(.empty)');
                    const positions = [];
                    
                    programSlots.forEach(slot => {
                        const rect = slot.getBoundingClientRect();
                        const style = window.getComputedStyle(slot);
                        const title = slot.querySelector('.program-title')?.textContent?.trim() || 'Unknown';
                        
                        positions.push({
                            title: title,
                            top: Math.round(rect.top),
                            left: Math.round(parseFloat(slot.style.left) || 0),
                            width: Math.round(rect.width),
                            height: Math.round(rect.height),
                            computedTop: Math.round(parseFloat(style.top) || 0),
                            computedHeight: Math.round(parseFloat(style.height) || rect.height),
                            offsetTop: slot.offsetTop,
                            offsetLeft: slot.offsetLeft
                        });
                    });
                    
                    console.log(`ðŸ“ Sending layout positions for ${positions.length} blocks`);
                    
                    event.source.postMessage({
                        type: 'layoutPositionsResponse',
                        positions: positions
                    }, '*');
                }
                
                // NEW: Handle layout sizing validation requests
                if (event.data.type === 'validateLayoutSizing') {
                    console.log('ðŸ” Channel: Received layout sizing validation request');
                    
                    const programTrack = document.getElementById('program-track');
                    const timeline = document.getElementById('timeline');
                    
                    if (!programTrack || !timeline) {
                        event.source.postMessage({
                            type: 'layoutValidationResponse',
                            error: 'Timeline or program track not found'
                        }, '*');
                        return;
                    }
                    
                    // Get timeline dimensions
                    const timelineRect = timeline.getBoundingClientRect();
                    const timelineWidth = timelineRect.width;
                    
                    // Get all program slots
                    const programSlots = document.querySelectorAll('.program-slot:not(.empty)');
                    
                    const blocks = Array.from(programSlots).map((slot, index) => {
                        const rect = slot.getBoundingClientRect();
                        const computedStyle = window.getComputedStyle(slot);
                        
                        // Extract content data
                        const titleElement = slot.querySelector('.program-title');
                        const metaElement = slot.querySelector('.program-meta');
                        
                        let title = titleElement ? titleElement.textContent : 'Unknown';
                        let duration = 0;
                        let startTime = 0;
                        
                        // Parse duration from meta text (e.g., "MOVIE â€¢ 165min")
                        if (metaElement) {
                            const metaText = metaElement.textContent;
                            const durationMatch = metaText.match(/(\d+)min/);
                            if (durationMatch) {
                                duration = parseInt(durationMatch[1]);
                            }
                        }
                        
                        // Find corresponding content item to get accurate data
                        const contentItem = currentContent.find(item => {
                            const itemTitle = item.title + (item.season && item.episode ? ` ${item.season}:${item.episode}` : '');
                            return itemTitle === title || item.title === title;
                        });
                        
                        if (contentItem) {
                            duration = contentItem.originalDuration || contentItem.duration;
                            startTime = contentItem.startTime || 0;
                        }
                        
                        return {
                            index: index,
                            title: title,
                            duration: duration,
                            startTime: startTime,
                            computedWidth: computedStyle.width.replace('px', ''),
                            computedLeft: computedStyle.left.replace('px', ''),
                            computedWidthPercent: ((rect.width / timelineWidth) * 100).toFixed(2),
                            computedLeftPercent: (((rect.left - timelineRect.left) / timelineWidth) * 100).toFixed(2),
                            actualPixelWidth: rect.width,
                            actualPixelLeft: rect.left - timelineRect.left
                        };
                    });
                    
                    const validationData = {
                        timelineDuration: currentTimelineDuration,
                        timelineWidth: timelineWidth,
                        totalBlocks: blocks.length,
                        blocks: blocks,
                        timestamp: Date.now()
                    };
                    
                    console.log('ðŸ“Š Channel: Sending validation data:', validationData);
                    
                    event.source.postMessage({
                        type: 'layoutValidationResponse',
                        data: validationData
                    }, '*');
                }
            });

            // Let the parent window know that the iframe is loaded and ready
            console.log('Sending genreChannelReady message to parent');
            window.parent.postMessage({ type: 'genreChannelReady' }, '*');
            
            // Make test functions available globally for console access
            window.testDuplicatePrevention = testDuplicatePrevention;
            window.debugContentState = debugContentState;
            window.forceShowProgramTrack = forceShowProgramTrack;
            window.debugPositioning = debugPositioning;
            console.log('âœ… Debug functions available: testDuplicatePrevention(), debugContentState(), forceShowProgramTrack(), debugPositioning()');
            
            // Also make them available via a global test object for easier access
            window.ChannelTests = {
                testDuplicatePrevention: testDuplicatePrevention,
                debugContentState: debugContentState,
                forceShowProgramTrack: forceShowProgramTrack,
                debugPositioning: debugPositioning,
                runAllTests: function() {
                    console.log('ðŸ§ª Running all channel tests...');
                    this.testDuplicatePrevention();
                    setTimeout(() => this.debugContentState(), 1000);
                }
            };
            
            // Add a simple way to run the test via console
            console.log('ðŸ’¡ To test duplicate prevention, open browser console and run:');
            console.log('   Right-click on the channel area â†’ Inspect â†’ Console tab');
            console.log('   Then type: ChannelTests.testDuplicatePrevention()');
            console.log('   Or run all tests: ChannelTests.runAllTests()');
        });

        // Update channel title based on genre
        function updateChannelTitle() {
            const channelTitle = document.querySelector('.channel-title');
            if (currentGenre) {
                channelTitle.textContent = `${currentGenre.toUpperCase()} CHANNEL`;
            } else {
                channelTitle.textContent = 'GENRE CHANNEL';
            }
        }

        // Update genre dropdown content based on the global currentGenre
        function updateGenreDropdown() {
            const genreSelect = document.getElementById('genre-select-submenu');
            const contentDropdown = document.getElementById('content-dropdown-submenu');

            // Sync the dropdown with the current state
            if (currentGenre) {
                genreSelect.value = currentGenre;
            } else {
                genreSelect.value = ''; // No genre selected yet
            }

            contentDropdown.innerHTML = '<option value="">Select content...</option>';

            if (currentGenre && genreContent[currentGenre]) {
                const content = genreContent[currentGenre];
                content.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.title;

                    // Format display text based on content type
                    let displayText = item.title;
                    if (item.type === 'show' && item.season && item.episode) {
                        displayText += ` ${item.season}:${item.episode}`;
                    }
                    displayText += ` (${item.duration}min)`;

                    option.textContent = displayText;
                    option.dataset.type = item.type;
                    option.dataset.duration = item.duration;
                    option.dataset.service = item.service;
                    option.dataset.season = item.season || '';
                    option.dataset.episode = item.episode || '';
                    contentDropdown.appendChild(option);
                });
            }
        }

        // Handle the user changing the genre from the dropdown
        function handleGenreChange(selectElement) {
            currentGenre = selectElement.value; // Update state from the DOM
            updateGenreDropdown(); // Refresh the UI based on the new state
        }

        // Create lineup from selected genre
        function createLineup(isInitialLoad = false) {
            const genre = currentGenre; // Use the globally set genre
            console.log('=== CREATE LINEUP ===');
            console.log('Genre:', genre, 'Initial load:', isInitialLoad);

            if (!genre) {
                console.log('No genre selected yet, waiting for show detection...');
                return;
            }

            const content = genreContent[genre];
            console.log('Content found:', content ? content.length : 0, 'items');
            
            if (content) {
                const lineupContent = [];
                let currentTime = 0;

                // Always preserve the first block if it is a detected/playing show or automode content
                let preserveFirst = false;
                let firstItem = null;
                if (currentContent.length > 0) {
                    firstItem = currentContent[0];
                    // Detected show, automode, or currently playing logic
                    if (
                        (firstItem.type === 'detected_show') ||
                        (firstItem.startTime === 0 && firstItem.type && firstItem.type.toLowerCase().includes('show')) ||
                        (firstItem.service === 'DETECTED')
                    ) {
                        preserveFirst = true;
                    }
                }
                if (preserveFirst && firstItem) {
                    lineupContent.push({ ...firstItem, startTime: 0 });
                    currentTime = firstItem.duration;
                    console.log('Preserved first block:', firstItem.title);
                }

                // Note: Don't clear currentContent here as we need to preserve the detected show

                // NEW: Get content tracking data from parent window to prevent duplicates
                let excludeContentIds = new Set();
                let playedContentIds = new Set();
                
                // Add the preserved show's ID to exclude it from genre content
                if (preserveFirst && firstItem) {
                    const preservedId = getContentId(firstItem);
                    excludeContentIds.add(preservedId);
                    console.log('Excluding preserved show from genre content');
                }
                
                // Simplified approach: Always auto-populate immediately, then optimize later
                console.log('Auto-populating channel with genre content...');
                
                try {
                    // Request content tracking data from parent window (for future optimization)
                    window.parent.postMessage({ 
                        type: 'requestContentTrackingData',
                        channelName: 'genre-channel'
                    }, '*');
                    
                    // Check if we already have content tracking data for filtering
                    if (window.contentTrackingData) {
                        excludeContentIds = new Set([...excludeContentIds, ...window.contentTrackingData.excludeContentIds]);
                        playedContentIds = window.contentTrackingData.playedContentIds;
                        console.log('Using cached content tracking data for filtering');
                        populateLineupWithFilteredContent(content, currentTime, lineupContent, excludeContentIds, playedContentIds);
                    } else {
                        // No content tracking data available, proceed with normal auto-population
                        console.log('No content tracking data, proceeding with normal auto-population');
                        populateLineupWithContent(content, currentTime, lineupContent);
                    }
                    
                } catch (error) {
                    console.error('Error with content tracking, using fallback auto-population:', error);
                    // Always fallback to auto-population
                    populateLineupWithContent(content, currentTime, lineupContent);
                }
                
            } else {
                console.error(`No content found for genre: ${genre}`);
            }
        }

        // Helper function to populate lineup with filtered content (prevents duplicates)
        function populateLineupWithFilteredContent(content, currentTime, lineupContent, excludeContentIds, playedContentIds) {
            // Create a set of existing content IDs to prevent duplicates within the channel
            const existingIds = new Set(lineupContent.map(item => getContentId(item)));
            
            // Filter content to exclude played content and duplicates
            const filteredContent = content.filter(item => {
                const contentId = getContentId(item);
                
                // Exclude if it's in the excludeContentIds set (sent from parent)
                if (excludeContentIds.has(contentId)) {
                    return false;
                }
                
                // Exclude if it's in playedContentIds set (sent from parent)
                if (playedContentIds.has(contentId)) {
                    return false;
                }
                
                // Exclude if it's already in the current channel lineup
                if (existingIds.has(contentId)) {
                    console.log(`ðŸš« Skipping duplicate in filtered population: "${item.title}" (ID: ${contentId})`);
                    return false;
                }
                
                return true;
            });
            
            console.log('Filtered content:', filteredContent.length, 'items');
            
            // Populate remaining time slots with filtered genre content
            for (const item of filteredContent) {
                // For auto-population, respect the 180-minute limit
                if (currentTime >= TIMELINE_DURATION) {
                    break;
                }

                const remainingTime = TIMELINE_DURATION - currentTime;
                
                // Enforce a minimum duration of 15 minutes for any block
                if (remainingTime < 15) {
                    break;
                }

                let itemDuration = item.duration;

                // If the item exceeds the remaining time, crop it.
                if (item.duration > remainingTime) {
                    itemDuration = remainingTime;
                }

                const positionedItem = {
                    ...item,
                    originalDuration: item.duration, // Always store original
                    duration: itemDuration,          // This is the visible duration
                    startTime: currentTime
                };

                lineupContent.push(positionedItem);
                existingIds.add(getContentId(item)); // Track added content to prevent duplicates
                currentTime += itemDuration;
                console.log(`âœ… Added "${item.title}" during filtered auto-population (no duplicates)`);

                // If the duration was cropped, we must be at the end.
                if (itemDuration < item.duration) {
                    break;
                }
            }

            currentContent = lineupContent;
            console.log('Lineup created:', lineupContent.length, 'items,', currentTime, 'minutes');

            // Update channel title but don't re-assign the global genre
            updateChannelTitle();

            // Show program track after genre is selected
            document.getElementById('program-track').style.display = 'block';
            updateProgramTrack();
        }

        // Helper function to populate lineup (extracted from original createLineup logic)
        function populateLineupWithContent(content, currentTime, lineupContent) {
            console.log('=== POPULATE LINEUP WITH CONTENT ===');
            console.log('Available content:', content.length, 'items');
            console.log('Starting currentTime:', currentTime, 'minutes');
            console.log('Starting lineupContent:', lineupContent.length, 'items');
            
            // Create a set of existing content IDs to prevent duplicates
            const existingIds = new Set(lineupContent.map(item => getContentId(item)));
            
            // Populate remaining time slots with new genre content
            for (const item of content) {
                // For auto-population, respect the 180-minute limit
                if (currentTime >= TIMELINE_DURATION) {
                    break;
                }

                const remainingTime = TIMELINE_DURATION - currentTime;
                
                // Enforce a minimum duration of 15 minutes for any block
                if (remainingTime < 15) {
                    break;
                }

                // Check for duplicates before adding
                const itemId = getContentId(item);
                if (existingIds.has(itemId)) {
                    console.log(`ðŸš« Skipping duplicate during auto-population: "${item.title}" (ID: ${itemId})`);
                    continue;
                }

                let itemDuration = item.duration;

                // If the item exceeds the remaining time, crop it.
                if (item.duration > remainingTime) {
                    itemDuration = remainingTime;
                }

                const positionedItem = {
                    ...item,
                    originalDuration: item.duration, // Always store original
                    duration: itemDuration,          // This is the visible duration
                    startTime: currentTime
                };

                lineupContent.push(positionedItem);
                existingIds.add(itemId); // Add to existing IDs set
                currentTime += itemDuration;
                console.log(`âœ… Added "${item.title}" during auto-population (no duplicates)`);

                // If the duration was cropped, we must be at the end.
                if (itemDuration < item.duration) {
                    break;
                }
            }

            currentContent = lineupContent;
            console.log('Lineup created:', lineupContent.length, 'items,', currentTime, 'minutes');

            // Update channel title but don't re-assign the global genre
            updateChannelTitle();

            // Show program track after genre is selected
            document.getElementById('program-track').style.display = 'block';
            updateProgramTrack();
        }

        // Search content
        function searchContent() {
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            const query = searchInput.value.toLowerCase();
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            const results = [];
            // Filter by current genre if set
            const searchContent = currentGenre ? genreContent[currentGenre] : Object.values(genreContent).flat();
            searchContent.forEach(item => {
                if (item.title.toLowerCase().includes(query)) {
                    results.push(item);
                }
            });
            
            displaySearchResults(results);
        }

        // Display search results
        function displaySearchResults(results) {
            const searchResults = document.getElementById('search-results');
            
            if (results.length === 0) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchResults.innerHTML = '';
            results.forEach(item => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';
                
                let metaText = `${item.type} â€¢ ${item.duration}min`;
                if (item.type === 'show' && item.season && item.episode) {
                    metaText += ` â€¢ ${item.season}:${item.episode}`;
                }
                metaText += ` â€¢ ${item.service}`;
                
                resultDiv.innerHTML = `
                    <div class="result-title">${item.title}</div>
                    <div class="result-meta">${metaText}</div>
                `;
                resultDiv.onclick = () => selectSearchResult(item);
                searchResults.appendChild(resultDiv);
            });
            
            searchResults.style.display = 'block';
        }

        // Select search result
        function selectSearchResult(item) {
            selectedContent = item;
            document.getElementById('search-input').value = item.title;
            document.getElementById('search-results').style.display = 'none';
        }

        // Select content from dropdown
        function selectContent() {
            const dropdown = document.getElementById('content-dropdown');
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            
            if (selectedOption.value) {
                selectedContent = {
                    title: selectedOption.value,
                    type: selectedOption.dataset.type,
                    duration: parseInt(selectedOption.dataset.duration),
                    service: selectedOption.dataset.service,
                    season: selectedOption.dataset.season,
                    episode: selectedOption.dataset.episode
                };
            }
        }

        // Add content to channel (append to end)
        function addContent() {
            if (!selectedContent) {
                alert('Please select content first');
                return;
            }
            
            // Check for duplicates before adding
            if (isDuplicateContent(selectedContent)) {
                alert(`"${selectedContent.title}" is already in the channel. Duplicates are not allowed.`);
                return;
            }
            
            // Find the next available start time
            let nextStartTime = 0;
            if (currentContent.length > 0) {
                const sortedContent = [...currentContent].sort((a, b) => (a.startTime + a.duration) - (b.startTime + b.duration));
                nextStartTime = sortedContent[sortedContent.length - 1].startTime + sortedContent[sortedContent.length - 1].duration;
            }
            
            const newContent = {
                ...selectedContent,
                originalDuration: selectedContent.duration, // Ensure this property exists
                startTime: nextStartTime
            };
            
            currentContent.push(newContent);
            console.log(`âœ… Added "${newContent.title}" to channel (no duplicates)`);
            
            // Show program track if not already visible
            document.getElementById('program-track').style.display = 'block';
            updateProgramTrack();
            selectedContent = null;
            document.getElementById('search-input').value = '';
            document.getElementById('content-dropdown').value = '';
            updateMultiplier();
        }

        // Function to calculate total content duration
        function calculateTotalContentDuration() {
            const total = currentContent.reduce((total, item) => {
                const endTime = item.startTime + item.duration;
                return Math.max(total, endTime);
            }, 0);
            
            console.log('calculateTotalContentDuration:', total, 'minutes');
            console.log('Content details:', currentContent.map(item => ({
                title: item.title,
                startTime: item.startTime,
                duration: item.duration,
                endTime: item.startTime + item.duration
            })));
            
            return total;
        }

        // Function to expand or contract timeline as needed
        function expandTimelineIfNeeded() {
            const totalDuration = calculateTotalContentDuration();
            const needsExpansion = totalDuration > currentTimelineDuration;
            const needsContraction = totalDuration < currentTimelineDuration && currentTimelineDuration > TIMELINE_DURATION;
            
            console.log('expandTimelineIfNeeded called:');
            console.log('- totalDuration:', totalDuration);
            console.log('- currentTimelineDuration:', currentTimelineDuration);
            console.log('- needsExpansion:', needsExpansion);
            console.log('- needsContraction:', needsContraction);
            console.log('- TIMELINE_DURATION:', TIMELINE_DURATION);
            
            if (needsExpansion) {
                // Calculate new timeline duration (round up to nearest 30 minutes)
                const newDuration = Math.ceil(totalDuration / 30) * 30;
                const oldDuration = currentTimelineDuration;
                currentTimelineDuration = newDuration; // Remove artificial cap, let it expand naturally
                
                console.log('EXPANSION TRIGGERED:');
                console.log('- oldDuration:', oldDuration);
                console.log('- newDuration:', newDuration);
                console.log('- currentTimelineDuration set to:', currentTimelineDuration);
                
                console.log('About to call updateTimelineMarkers...');
                
                // Update timeline markers
                try {
                    updateTimelineMarkers();
                    console.log('updateTimelineMarkers completed successfully');
                } catch (error) {
                    console.error('Error in updateTimelineMarkers:', error);
                }
                
                // Update multiplier display
                try {
                    updateMultiplier();
                    console.log('updateMultiplier completed successfully');
                } catch (error) {
                    console.error('Error in updateMultiplier:', error);
                }
                
                console.log(`Timeline expanded from ${oldDuration} to ${currentTimelineDuration} minutes`);
                return true;
            } else if (needsContraction) {
                // Calculate new timeline duration (round down to nearest 30 minutes)
                const newDuration = Math.floor(totalDuration / 30) * 30;
                // Don't go below the base timeline duration
                const oldDuration = currentTimelineDuration;
                currentTimelineDuration = Math.max(newDuration, TIMELINE_DURATION);
                
                console.log('About to call updateTimelineMarkers for contraction...');
                
                // Update timeline markers
                try {
                    updateTimelineMarkers();
                    console.log('updateTimelineMarkers completed successfully for contraction');
                } catch (error) {
                    console.error('Error in updateTimelineMarkers for contraction:', error);
                }
                
                // Update multiplier display
                try {
                    updateMultiplier();
                    console.log('updateMultiplier completed successfully for contraction');
                } catch (error) {
                    console.error('Error in updateMultiplier for contraction:', error);
                }
                
                console.log(`Timeline contracted from ${oldDuration} to ${currentTimelineDuration} minutes`);
                return true;
            }
            
            console.log('No timeline change needed');
            return false;
        }

        // Function to update timeline markers
        function updateTimelineMarkers() {
            const timelineRow = document.getElementById('timeline-markers');
            const multiplierRow = document.getElementById('multiplier-markers');
            const timeline = document.getElementById('timeline');
            const programTrack = document.getElementById('program-track');
            
            console.log('updateTimelineMarkers called');
            console.log('- currentTimelineDuration:', currentTimelineDuration);
            console.log('- timelineRow exists:', !!timelineRow);
            console.log('- multiplierRow exists:', !!multiplierRow);
            
            if (!timelineRow) return;
            
            // Clear existing markers
            timelineRow.innerHTML = '';
            if (multiplierRow) {
                multiplierRow.innerHTML = '';
            }
            
            // Generate timeline markers based on currentTimelineDuration
            const markerInterval = 30; // 30min per marker
            const markerCount = Math.ceil(currentTimelineDuration / markerInterval) + 1;
            timelineRow.innerHTML = '';
            multiplierRow.innerHTML = '';
            for (let i = 0; i < markerCount; i++) {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.textContent = i * markerInterval;
                timelineRow.appendChild(marker);

                // Multiplier logic: distribute from 1.0x to max across the timeline (dynamic scaling)
                const baseMultiplier = 1.0;
                const scaleFactor = currentTimelineDuration / 180; // Base timeline is 180 minutes
                const maxMultiplier = Math.min(1.0 + (scaleFactor * 0.8), 3.0); // Cap at 3.0x, same as main timeline
                const multiplier = (markerCount === 1)
                    ? baseMultiplier
                    : (baseMultiplier + (i / (markerCount - 1)) * (maxMultiplier - baseMultiplier));
                const multiplierDiv = document.createElement('div');
                multiplierDiv.className = 'timeline-marker';
                multiplierDiv.style.color = (i === 0 || i === markerCount - 1) ? '#00ff41' : '#ffaa00';
                multiplierDiv.textContent = multiplier.toFixed(1) + 'X';
                multiplierRow.appendChild(multiplierDiv);
            }
            
            console.log('Created timeline markers:', timelineRow.children);
            
            // Add multiplier markers based on current timeline duration
            if (multiplierRow) {
                const multiplier = getMultiplier();
                
                // Create multiplier marker
                const multiplierMarker = document.createElement('div');
                multiplierMarker.className = 'timeline-marker multiplier';
                multiplierMarker.style.color = '#00ff41';
                multiplierMarker.style.fontWeight = '600';
                multiplierMarker.textContent = `${multiplier.toFixed(1)}x`;
                multiplierRow.appendChild(multiplierMarker);
                
                console.log('Created multiplier marker:', `${multiplier.toFixed(1)}x`);
            }
        }

        // Function to calculate width based on current timeline duration
        function calculateWidth(duration) {
            return (duration / currentTimelineDuration) * 100;
        }

        // Function to calculate left position based on current timeline duration
        function calculateLeftPosition(minutes) {
            return (minutes / currentTimelineDuration) * 100;
        }

        // Find gaps in the timeline
        function findGaps() {
            const gaps = [];
            let currentTime = 0;
            
            // Sort content by start time
            const sortedContent = [...currentContent].sort((a, b) => a.startTime - b.startTime);
            
            sortedContent.forEach(item => {
                if (item.startTime > currentTime) {
                    gaps.push({
                        start: currentTime,
                        end: item.startTime,
                        duration: item.startTime - currentTime
                    });
                }
                currentTime = item.startTime + item.duration;
            });
            
            // Check for gap at the end
            if (currentTime < currentTimelineDuration) {
                gaps.push({
                    start: currentTime,
                    end: currentTimelineDuration,
                    duration: currentTimelineDuration - currentTime
                });
            }
            
            return gaps;
        }

        // Check if text content overflows its container
        function hasTextOverflow(element) {
            return element.scrollWidth > element.clientWidth;
        }

        // Determine intelligent scaling direction based on available space
        function getScalingDirection(leftPosition, blockWidth) {
            const spaceOnLeft = leftPosition;
            const spaceOnRight = 100 - (leftPosition + blockWidth);

            // Scale in the direction with more available space
            if (spaceOnRight >= spaceOnLeft) {
                return 'left center'; // More space on the right, so expand right
            } else {
                return 'right center'; // More space on the left, so expand left
            }
        }

        // Update program track display with absolute positioning
        function updateProgramTrack() {
            const track = document.getElementById('program-track');
            track.innerHTML = '';

            // If no content, show only the genre auto-populate prompt
            if (currentContent.length === 0) {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'program-slot empty';
                emptySlot.style.left = '0%';
                emptySlot.style.width = '100%';
                emptySlot.style.top = '0px'; // LAYOUT FIX: Explicit top position
                emptySlot.style.height = '100%'; // LAYOUT FIX: Ensure consistent height
                emptySlot.onclick = openGenreEditMode;
                emptySlot.textContent = 'SELECT GENRE TO START';
                track.appendChild(emptySlot);
                return;
            }

            console.log('updateProgramTrack called, currentContent:', currentContent);
            console.log('currentContent length:', currentContent.length);
            
            // Check if timeline needs expansion
            const timelineExpanded = expandTimelineIfNeeded();
            
            // Sort content by start time
            const sortedContent = [...currentContent].sort((a, b) => a.startTime - b.startTime);
            console.log('Sorted content for display:', sortedContent);
            
            sortedContent.forEach((item, index) => {
                console.log(`Creating program slot ${index}:`, item);
                const slot = document.createElement('div');
                slot.className = 'program-slot';
                const leftPosition = calculateLeftPosition(item.startTime);
                const blockWidth = calculateWidth(item.duration);
                
                slot.style.left = `${leftPosition}%`;
                slot.style.width = `${blockWidth}%`;
                slot.style.top = '0px'; // LAYOUT FIX: Explicit top position to prevent vertical shifting
                slot.style.height = '100%'; // LAYOUT FIX: Ensure consistent height
                
                // Set intelligent scaling direction
                const scalingDirection = getScalingDirection(leftPosition, blockWidth);
                slot.style.setProperty('--hover-transform-origin', scalingDirection);

                // If a block's true end time exceeds the timeline, style it as cropped
                const isCropped = item.originalDuration && (item.startTime + item.originalDuration > currentTimelineDuration);
                if (isCropped) {
                    slot.classList.add('is-cropped');
                }

                // Format content display
                let titleText = item.title;
                // Use original duration if available (for cropped items), otherwise use normal duration
                const durationToShow = item.originalDuration || item.duration;
                let metaText = `${item.type} â€¢ ${durationToShow}min`;

                if (item.type === 'show' && item.season && item.episode) {
                    titleText += ` ${item.season}:${item.episode}`;
                }
                
                slot.innerHTML = `
                    <div class="program-title">${titleText}</div>
                    <div class="program-meta">${metaText}</div>
                    <div class="program-service">${item.service}</div>
                `;
                
                // Add click handler for show transition
                // During indexing sessions, allow transitions to all shows
                // Only protect the first item if we're NOT in an active indexing session
                const shouldProtectFromClicks = false; // Allow all shows to be clickable for transitions
                
                if (!shouldProtectFromClicks) {
                    slot.style.cursor = 'pointer';
                    slot.onclick = (e) => {
                        // Don't trigger if clicking on remove button
                        if (e.target.classList.contains('remove-btn')) return;
                        
                        console.log('Show selected for transition:', item);
                        
                        // Send transition message to parent
                        window.parent.postMessage({
                            type: 'rumi:showSelected',
                            payload: { showData: item }
                        }, '*');
                    };
                    
                    // Add hover effect for clickable items
                    slot.addEventListener('mouseenter', () => {
                        slot.style.backgroundColor = '#ffaa0020';
                        slot.style.borderColor = '#ffaa00';
                    });
                    
                    slot.addEventListener('mouseleave', () => {
                        slot.style.backgroundColor = '';
                        slot.style.borderColor = '';
                    });
                    
                    // Add visual indicator for clickable items
                    slot.style.borderColor = '#00ff4150';
                    slot.title = 'Click to transition to this show';
                } else {
                    slot.style.cursor = 'default';
                    slot.title = 'Currently playing';
                }
                
                track.appendChild(slot);
                console.log(`Added program slot for: ${titleText}`);

                // Check for text overflow after the element is in the DOM
                setTimeout(() => {
                    const titleElement = slot.querySelector('.program-title');
                    const metaElement = slot.querySelector('.program-meta');
                    const serviceElement = slot.querySelector('.program-service');

                    const elements = [titleElement, metaElement, serviceElement];
                    let maxScaleFactor = 1.0;

                    elements.forEach(el => {
                        if (hasTextOverflow(el)) {
                            const scaleFactor = el.scrollWidth / el.clientWidth;
                            if (scaleFactor > maxScaleFactor) {
                                maxScaleFactor = scaleFactor;
                            }
                        }
                    });

                    if (maxScaleFactor > 1.0) {
                        const requiredScale = maxScaleFactor * 1.05; // Ideal scale with padding
                        let maxAllowedScale = Infinity;

                        // Calculate the maximum scale allowed by the timeline boundaries
                        if (getScalingDirection(leftPosition, blockWidth) === 'left center') {
                            // Expanding right
                            const spaceOnRight = 100 - leftPosition;
                            maxAllowedScale = spaceOnRight / blockWidth;
                        } else {
                            // Expanding left
                            const spaceOnLeft = leftPosition + blockWidth;
                            maxAllowedScale = spaceOnLeft / blockWidth;
                        }

                        // Use the smaller of the two: what's required vs. what's allowed
                        const finalScale = Math.min(requiredScale, maxAllowedScale);
                        const counterScale = 1 / finalScale;

                        slot.classList.add('has-overflow');
                        slot.style.setProperty('--scale-factor', finalScale);
                        slot.style.setProperty('--counter-scale-factor', counterScale);
                    }

                    // Now that overflow is determined, add the remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = 'Ã—';
                    
                    // Check if this content is protected from removal (currently playing detected show)
                    const isProtectedFromRemoval = currentContent.indexOf(item) === 0 && 
                                                  isContentDetectionMode() && 
                                                  isFirstItemCurrentlyPlaying();
                    
                    if (isProtectedFromRemoval) {
                        removeBtn.classList.add('protected');
                        removeBtn.title = 'Currently playing - cannot remove';
                        removeBtn.style.opacity = '0.3';
                        removeBtn.style.cursor = 'not-allowed';
                        removeBtn.onclick = (e) => {
                            e.stopPropagation();
                            alert('Cannot remove currently playing content. This show is actively being tracked.');
                        };
                    } else {
                        removeBtn.onclick = (e) => {
                            e.stopPropagation();
                            removeContent(currentContent.indexOf(item));
                        };
                    }
                    
                    slot.appendChild(removeBtn);
                }, 0);
            });
            
            // Add gap indicators
            const gaps = findGaps();
            gaps.forEach(gap => {
                const gapSlot = document.createElement('div');
                gapSlot.className = 'program-slot empty';
                gapSlot.style.left = `${calculateLeftPosition(gap.start)}%`;
                gapSlot.style.width = `${calculateWidth(gap.duration)}%`;
                gapSlot.style.top = '0px'; // LAYOUT FIX: Explicit top position
                gapSlot.style.height = '100%'; // LAYOUT FIX: Ensure consistent height
                gapSlot.onclick = () => addContentAtPosition(gap.start);
                gapSlot.textContent = '+';
                track.appendChild(gapSlot);
            });
            
            console.log('updateProgramTrack complete, track children count:', track.children.length);
        }

        // Add content at a specific timeline position
        function addContentAtPosition(startTime) {
            if (!selectedContent) {
                // Open edit mode for individual content
                openAddContentMode();
                return;
            }
            
            // Check for duplicates before adding
            if (isDuplicateContent(selectedContent)) {
                alert(`"${selectedContent.title}" is already in the channel. Duplicates are not allowed.`);
                return;
            }
            
            // Add content with start time
            const newContent = {
                ...selectedContent,
                originalDuration: selectedContent.duration, // Ensure this property exists
                startTime: startTime
            };
            
            currentContent.push(newContent);
            console.log(`âœ… Added "${newContent.title}" to channel at ${startTime}min (no duplicates)`);
            
            // Show program track if not already visible
            document.getElementById('program-track').style.display = 'block';
            updateProgramTrack();
            selectedContent = null;
            document.getElementById('search-input-submenu').value = '';
            document.getElementById('content-dropdown-submenu').value = '';
            updateMultiplier();
        }

        // Remove content from channel and slide remaining blocks
        function removeContent(index) {
            // Check if we're in content detection mode and trying to remove the first item
            if (index === 0 && isContentDetectionMode() && isFirstItemCurrentlyPlaying()) {
                alert('Cannot remove currently playing content. This show is actively being tracked.');
                return;
            }
            
            const removedItem = currentContent[index];
            currentContent.splice(index, 1);
            
            // Slide remaining blocks to the left
            currentContent.forEach(item => {
                if (item.startTime > removedItem.startTime) {
                    item.startTime -= removedItem.duration;
                }
            });
            
            // Check if timeline needs contraction
            expandTimelineIfNeeded();
            
            updateProgramTrack();
            updateMultiplier();
        }

        // Generate a unique ID for a piece of content
        function getContentId(item) {
            let id = item.title;
            if (item.type === 'show' && item.season && item.episode) {
                id += `-${item.season}-${item.episode}`;
            }
            return id;
        }

        // Check if content is already in the channel (duplicate prevention)
        function isDuplicateContent(newItem) {
            if (!newItem || !currentContent || currentContent.length === 0) {
                return false;
            }
            
            const newItemId = getContentId(newItem);
            
            // Check if any existing content has the same ID
            const isDuplicate = currentContent.some(existingItem => {
                const existingId = getContentId(existingItem);
                return existingId === newItemId;
            });
            
            if (isDuplicate) {
                console.log(`ðŸš« Duplicate detected: "${newItem.title}" (ID: ${newItemId}) already exists in channel`);
                return true;
            }
            
            return false;
        }

        // Add to queue, preventing duplicates
        function addToQueue() {
            if (currentContent.length === 0) {
                alert('No content to add to queue');
                return;
            }

            const queueIds = new Set(queue.map(getContentId));
            const newContent = currentContent.filter(item => !queueIds.has(getContentId(item)));

            if (newContent.length === 0) {
                alert('All content from this channel is already in the queue.');
                return;
            }
            
            queue.push(...newContent);
            updateQueue();
            document.getElementById('queue-section').style.display = 'block';
        }

        // Play now, preventing duplicates
        function playNow() {
            if (currentContent.length === 0) {
                alert('No content to play');
                return;
            }
            
            const queueIds = new Set(queue.map(getContentId));
            const newContent = currentContent.filter(item => !queueIds.has(getContentId(item)));

            // Even if there's nothing new to add, we can still "play" the existing queue
            if (newContent.length > 0) {
                queue.push(...newContent);
                updateQueue();
            }
            
            document.getElementById('queue-section').style.display = 'block';
            
            // Simulate starting playback
            alert('Starting playback of channel content...');
        }

        // Update queue display
        function updateQueue() {
            const queueItems = document.getElementById('queue-items');
            const queueSummary = document.getElementById('queue-summary');
            
            queueItems.innerHTML = '';
            queue.forEach((item, index) => {
                const queueItem = document.createElement('div');
                queueItem.className = 'queue-item';
                
                let titleText = item.title;
                if (item.type === 'show' && item.season && item.episode) {
                    titleText += ` ${item.season}:${item.episode}`;
                }
                
                queueItem.innerHTML = `
                    <div class="queue-item-info">
                        <div class="queue-item-title">${titleText}</div>
                        <div class="queue-item-meta">${item.type} â€¢ ${item.duration}min â€¢ ${item.service}</div>
                    </div>
                    <button class="queue-remove-btn" onclick="removeFromQueue(${index})">Ã—</button>
                `;
                queueItems.appendChild(queueItem);
            });
            
            const totalDuration = queue.reduce((sum, item) => sum + item.duration, 0);
            const currentMultiplier = getMultiplier();
            const estimatedPoints = totalDuration * currentMultiplier;
            
            queueSummary.textContent = `${queue.length} items â€¢ ${totalDuration} min â€¢ ~${estimatedPoints.toFixed(1)}pts`;
        }

        // Remove from queue
        function removeFromQueue(index) {
            queue.splice(index, 1);
            updateQueue();
            
            if (queue.length === 0) {
                document.getElementById('queue-section').style.display = 'none';
            }
        }

        function getMultiplier() {
            const totalDuration = currentContent.reduce((sum, item) => sum + item.duration, 0);
            let multiplier = 1.0;

            // Simple multiplier logic based on total content duration
            if (totalDuration >= 300) {
                multiplier = 2.0; // 300+ minutes = 2.0x
            } else if (totalDuration >= 240) {
                multiplier = 1.8; // 240+ minutes = 1.8x
            } else if (totalDuration >= 180) {
                multiplier = 1.5; // 180+ minutes = 1.5x
            } else if (totalDuration >= 120) {
                multiplier = 1.3; // 120+ minutes = 1.3x
            } else if (totalDuration >= 60) {
                multiplier = 1.1; // 60+ minutes = 1.1x
            }
            
            return multiplier;
        }

        // Update multiplier display
        function updateMultiplier() {
            const multiplier = getMultiplier();
            const multiplierDisplay = document.getElementById('multiplier-display');
            // Add a null check for safety
            if (multiplierDisplay) {
                multiplierDisplay.textContent = `${multiplier.toFixed(1)}x`;
            }
        }

        // ===== NEW EDIT MODE FUNCTIONS =====

        // Open edit mode for genre selection
        function openGenreEditMode() {
            // Store current timeline state
            previousTimelineState = {
                timeline: document.getElementById('timeline').innerHTML,
                container: document.getElementById('timeline-container').className
            };
            
            // Set edit mode
            editMode = 'genre';
            
            // Hide timeline, show genre submenu
            document.getElementById('timeline').style.display = 'none';
            document.getElementById('auto-populate-submenu').classList.add('visible');
            
            // Add edit mode styling
            document.getElementById('timeline-container').classList.add('edit-mode');
            
            // Sync genre dropdown with current state
            const genreSelect = document.getElementById('genre-select-submenu');
            if (currentGenre) {
                genreSelect.value = currentGenre;
            }
        }

        // Open edit mode for adding individual content
        function openAddContentMode() {
            // Store current timeline state
            previousTimelineState = {
                timeline: document.getElementById('timeline').innerHTML,
                container: document.getElementById('timeline-container').className
            };
            
            // Set edit mode
            editMode = 'individual';
            
            // Hide timeline, show individual content submenu
            document.getElementById('timeline').style.display = 'none';
            document.getElementById('individual-content-submenu').classList.add('visible');
            
            // Add edit mode styling
            document.getElementById('timeline-container').classList.add('edit-mode');
            
            // Populate content dropdown
            updateContentDropdownSubmenu();
        }

        // Cancel edit mode and restore timeline
        function cancelEdit() {
            if (editMode === null) return;
            
            // Restore timeline state
            if (previousTimelineState) {
                document.getElementById('timeline').innerHTML = previousTimelineState.timeline;
                document.getElementById('timeline-container').className = previousTimelineState.container;
            }
            
            // Show timeline, hide submenus
            document.getElementById('timeline').style.display = 'block';
            document.getElementById('auto-populate-submenu').classList.remove('visible');
            document.getElementById('individual-content-submenu').classList.remove('visible');
            
            // Remove edit mode styling
            document.getElementById('timeline-container').classList.remove('edit-mode');
            
            // Reset state
            editMode = null;
            previousTimelineState = null;
        }

        // Auto-populate function for submenu
        function autoPopulate() {
            const genreSelect = document.getElementById('genre-select-submenu');
            const selectedGenre = genreSelect.value;
            
            if (!selectedGenre) {
                alert('Please select a genre first');
                return;
            }
            
            // Set current genre and create lineup
            currentGenre = selectedGenre;
            createLineup();
            
            // Exit edit mode
            cancelEdit();
        }

        // Handle genre change in submenu
        function handleGenreChangeSubmenu(selectElement) {
            currentGenre = selectElement.value;
            updateContentDropdownSubmenu();
        }

        // Update content dropdown for submenu
        function updateContentDropdownSubmenu() {
            const contentDropdown = document.getElementById('content-dropdown-submenu');
            contentDropdown.innerHTML = '<option value="">Select content...</option>';

            if (currentGenre && genreContent[currentGenre]) {
                const content = genreContent[currentGenre];
                content.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.title;

                    // Format display text based on content type
                    let displayText = item.title;
                    if (item.type === 'show' && item.season && item.episode) {
                        displayText += ` ${item.season}:${item.episode}`;
                    }
                    displayText += ` (${item.duration}min)`;

                    option.textContent = displayText;
                    option.dataset.type = item.type;
                    option.dataset.duration = item.duration;
                    option.dataset.service = item.service;
                    option.dataset.season = item.season || '';
                    option.dataset.episode = item.episode || '';
                    contentDropdown.appendChild(option);
                });
            }
        }

        // Search content for submenu
        function searchContentSubmenu() {
            const searchInput = document.getElementById('search-input-submenu');
            const searchResults = document.getElementById('search-results-submenu');
            const query = searchInput.value.toLowerCase();
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            const results = [];
            // Filter by current genre if set
            const searchContent = currentGenre ? genreContent[currentGenre] : Object.values(genreContent).flat();
            searchContent.forEach(item => {
                if (item.title.toLowerCase().includes(query)) {
                    results.push(item);
                }
            });
            
            displaySearchResultsSubmenu(results);
        }

        // Display search results for submenu
        function displaySearchResultsSubmenu(results) {
            const searchResults = document.getElementById('search-results-submenu');
            
            if (results.length === 0) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchResults.innerHTML = '';
            results.forEach(item => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-item';
                
                let metaText = `${item.type} â€¢ ${item.duration}min`;
                if (item.type === 'show' && item.season && item.episode) {
                    metaText += ` â€¢ ${item.season}:${item.episode}`;
                }
                metaText += ` â€¢ ${item.service}`;
                
                resultDiv.innerHTML = `
                    <div class="result-title">${item.title}</div>
                    <div class="result-meta">${metaText}</div>
                `;
                resultDiv.onclick = () => selectSearchResultSubmenu(item);
                searchResults.appendChild(resultDiv);
            });
            
            searchResults.style.display = 'block';
        }

        // Select search result for submenu
        function selectSearchResultSubmenu(item) {
            selectedContent = item;
            document.getElementById('search-input-submenu').value = item.title;
            document.getElementById('search-results-submenu').style.display = 'none';
        }

        // Select content from dropdown for submenu
        function selectContentSubmenu() {
            const dropdown = document.getElementById('content-dropdown-submenu');
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            
            if (selectedOption.value) {
                selectedContent = {
                    title: selectedOption.value,
                    type: selectedOption.dataset.type,
                    duration: parseInt(selectedOption.dataset.duration),
                    service: selectedOption.dataset.service,
                    season: selectedOption.dataset.season,
                    episode: selectedOption.dataset.episode
                };
            }
        }

        // Add content for submenu
        function addContentSubmenu() {
            if (!selectedContent) {
                alert('Please select content first');
                return;
            }
            
            // Check for duplicates before adding
            if (isDuplicateContent(selectedContent)) {
                alert(`"${selectedContent.title}" is already in the channel. Duplicates are not allowed.`);
                return;
            }
            
            // Find the next available start time
            let nextStartTime = 0;
            if (currentContent.length > 0) {
                const sortedContent = [...currentContent].sort((a, b) => (a.startTime + a.duration) - (b.startTime + b.duration));
                nextStartTime = sortedContent[sortedContent.length - 1].startTime + sortedContent[sortedContent.length - 1].duration;
            }
            
            const newContent = {
                ...selectedContent,
                originalDuration: selectedContent.duration,
                startTime: nextStartTime
            };
            
            currentContent.push(newContent);
            console.log(`âœ… Added "${newContent.title}" to channel via submenu (no duplicates)`);
            
            // Show program track if not already visible
            document.getElementById('program-track').style.display = 'block';
            updateProgramTrack();
            
            // Reset form
            selectedContent = null;
            document.getElementById('search-input-submenu').value = '';
            document.getElementById('content-dropdown-submenu').value = '';
            document.getElementById('search-results-submenu').style.display = 'none';
            
            updateMultiplier();
            
            // Exit edit mode
            cancelEdit();
        }

        // Update the edit link click handler
        function toggleEditPanel() {
            openGenreEditMode();
        }

        // Simulate show detection for demo purposes
        function simulateShowDetection() {
            const demoShows = [
                {
                    showTitle: 'BREAKING BAD',
                    showType: 'show',
                    duration: 47,
                    service: 'NETFLIX',
                    season: 'S5',
                    episode: 'E16'
                },
                {
                    showTitle: 'STRANGER THINGS',
                    showType: 'show',
                    duration: 51,
                    service: 'NETFLIX',
                    season: 'S4',
                    episode: 'E9'
                },
                {
                    showTitle: 'THE CROWN',
                    showType: 'show',
                    duration: 58,
                    service: 'NETFLIX',
                    season: 'S6',
                    episode: 'E10'
                }
            ];
            
            // Randomly select a show to simulate detection
            const randomShow = demoShows[Math.floor(Math.random() * demoShows.length)];
            
            // Simulate the detection with a slight delay
            setTimeout(() => {
                handleShowDetection(randomShow);
            }, 1000);
        }

        // Handle show detection from parent window
        function handleShowDetection(payload) {
            const { showTitle, showType, duration, service, season, episode } = payload;
            
            // Create new content item for the detected show
            const detectedShow = {
                title: showTitle,
                type: 'detected_show', // Mark as detected show for protection
                duration: duration || 60,
                service: service || 'DETECTED',
                season: season || '',
                episode: episode || '',
                originalDuration: duration || 60,
                startTime: 0 // Will be calculated below
            };
            
            // Check for duplicates before adding (but allow detected shows to be re-added if needed)
            if (isDuplicateContent(detectedShow)) {
                console.log(`âš ï¸ Detected show "${detectedShow.title}" is already in channel, skipping duplicate`);
                // Still send confirmation back to parent
                window.parent.postMessage({
                    type: 'rumi:showAdded',
                    payload: { showTitle, position: 'existing' }
                }, '*');
                return;
            }
            
            // Calculate the next available start time (add to the end)
            let nextStartTime = 0;
            if (currentContent.length > 0) {
                const sortedContent = [...currentContent].sort((a, b) => (a.startTime + a.duration) - (b.startTime + b.duration));
                nextStartTime = sortedContent[sortedContent.length - 1].startTime + sortedContent[sortedContent.length - 1].duration;
            }
            
            // Set the start time for the detected show
            detectedShow.startTime = nextStartTime;
            
            // Add the detected show to the end
            currentContent.push(detectedShow);
            console.log(`âœ… Added detected show "${detectedShow.title}" to channel (no duplicates)`);
            
            // Update the display
            updateProgramTrack();
            updateMultiplier();
            
            // Send confirmation back to parent
            window.parent.postMessage({
                type: 'rumi:showAdded',
                payload: { showTitle, position: 'end' }
            }, '*');
        }

        // NEW: Message handler for content tracking data from parent window
        window.addEventListener('message', function(event) {
            if (event.data.type === 'contentTrackingData') {
                console.log('Received content tracking data from parent:', event.data);
                
                // Store the content tracking data for use in createLineup
                window.contentTrackingData = {
                    excludeContentIds: new Set(event.data.excludeContentIds || []),
                    playedContentIds: new Set(event.data.playedContentIds || []),
                    channelContentIds: new Set(event.data.channelContentIds || [])
                };
                
                // If we're waiting for this data to complete createLineup, trigger it
                if (window.pendingLineupCreation) {
                    window.pendingLineupCreation();
                    window.pendingLineupCreation = null;
                }
            }
            
            // NEW: Handle function execution requests from parent window
            if (event.data.type === 'executeFunction') {
                const { functionName, args } = event.data;
                console.log(`ðŸ“¥ Received request to execute '${functionName}' with args:`, args);
                
                try {
                    // Check if the function exists in the global scope
                    if (typeof window[functionName] === 'function') {
                        console.log(`âœ… Executing '${functionName}'...`);
                        const result = window[functionName](...(args || []));
                        console.log(`âœ… Function '${functionName}' executed successfully`);
                        return result;
                    } else {
                        console.error(`âŒ Function '${functionName}' not found in channel iframe`);
                    }
                } catch (error) {
                    console.error(`âŒ Error executing function '${functionName}':`, error);
                }
            }
        });

        // Check if we're in content detection mode
        function isContentDetectionMode() {
            // Check if we have a detected show as the first item
            if (currentContent.length > 0) {
                const firstItem = currentContent[0];
                
                // Check for explicit detected_show type
                if (firstItem && firstItem.type === 'detected_show') {
                    return true;
                }
                
                // Check if first item has startTime: 0 (likely currently playing)
                if (firstItem && firstItem.startTime === 0) {
                    return true;
                }
                
                // Check if first item has service: 'DETECTED'
                if (firstItem && firstItem.service === 'DETECTED') {
                    return true;
                }
            }
            return false;
        }

        // Check if the first item is currently playing
        function isFirstItemCurrentlyPlaying() {
            if (currentContent.length === 0) return false;
            
            const firstItem = currentContent[0];
            
            // Check if this is a detected show (currently playing)
            if (firstItem.type === 'detected_show') {
                return true;
            }
            
            // Additional check: if the first item has startTime: 0, it's likely currently playing
            if (firstItem.startTime === 0) {
                return true;
            }
            
            // Check if first item has service: 'DETECTED'
            if (firstItem.service === 'DETECTED') {
                return true;
            }
            
            return false;
        }

        // Test function to verify content protection
        function testContentProtection() {
            console.log('=== Testing Content Protection ===');
            
            // Test 1: Check if we're in content detection mode
            const isDetectionMode = isContentDetectionMode();
            console.log('Is content detection mode:', isDetectionMode);
            
            // Test 2: Check if first item is currently playing
            const isFirstPlaying = isFirstItemCurrentlyPlaying();
            console.log('Is first item currently playing:', isFirstPlaying);
        }

        // NEW: Test function to verify duplicate prevention system
        function testDuplicatePrevention() {
            console.log('ðŸ§ª === TESTING DUPLICATE PREVENTION SYSTEM ===');
            
            // Store original content
            const originalContent = [...currentContent];
            const originalContentCount = currentContent.length;
            
            console.log(`ðŸ“Š Starting with ${originalContentCount} items in channel`);
            
            // Test 1: Try to add the same content via different methods
            if (currentContent.length > 0) {
                const testItem = currentContent[0];
                console.log(`\nðŸ”¬ Test 1: Attempting to add duplicate of "${testItem.title}"`);
                
                // Test manual addition
                selectedContent = { ...testItem };
                addContent(); // Should be blocked
                
                console.log(`ðŸ“Š After manual add attempt: ${currentContent.length} items (should be ${originalContentCount})`);
                
                // Test position-based addition
                selectedContent = { ...testItem };
                addContentAtPosition(60); // Should be blocked
                
                console.log(`ðŸ“Š After position add attempt: ${currentContent.length} items (should be ${originalContentCount})`);
                
                // Test submenu addition
                selectedContent = { ...testItem };
                addContentSubmenu(); // Should be blocked
                
                console.log(`ðŸ“Š After submenu add attempt: ${currentContent.length} items (should be ${originalContentCount})`);
                
                // Clear selected content
                selectedContent = null;
            }
            
            // Test 2: Test show detection duplicate prevention
            if (currentContent.length > 0) {
                const testShow = currentContent[0];
                console.log(`\nðŸ”¬ Test 2: Attempting to add duplicate detected show "${testShow.title}"`);
                
                const detectionPayload = {
                    showTitle: testShow.title,
                    showType: testShow.type,
                    duration: testShow.duration,
                    service: testShow.service,
                    season: testShow.season,
                    episode: testShow.episode
                };
                
                handleShowDetection(detectionPayload); // Should be blocked
                console.log(`ðŸ“Š After show detection attempt: ${currentContent.length} items (should be ${originalContentCount})`);
            }
            
            // Test 3: Test auto-population duplicate prevention
            console.log(`\nðŸ”¬ Test 3: Testing auto-population duplicate prevention`);
            
            // Create a test genre with some duplicate content
            const testGenre = 'TestGenre';
            const testContent = [
                {title: 'Test Show 1', type: 'show', duration: 30, service: 'TEST', season: 'S1', episode: 'E1'},
                {title: 'Test Show 2', type: 'show', duration: 45, service: 'TEST', season: 'S1', episode: 'E2'}
            ];
            
            // Add one of the test items manually first
            if (testContent.length > 0) {
                const firstTestItem = testContent[0];
                const manualItem = {
                    ...firstTestItem,
                    originalDuration: firstTestItem.duration,
                    startTime: originalContent.length > 0 ? 
                        Math.max(...originalContent.map(item => item.startTime + item.duration)) : 0
                };
                
                // Add manually (this should work)
                currentContent.push(manualItem);
                console.log(`âœ… Manually added "${firstTestItem.title}" for testing`);
                
                // Now try auto-population with the same content - should skip duplicates
                const lineupContent = [...currentContent];
                populateLineupWithContent(testContent, manualItem.startTime + manualItem.duration, lineupContent);
                
                // Count how many test items were added (should be only 1 new one, not the duplicate)
                const testItemsInChannel = currentContent.filter(item => item.title.startsWith('Test Show')).length;
                console.log(`ðŸ“Š Test items in channel after auto-population: ${testItemsInChannel} (should be 2 total, 1 existing + 1 new)`);
            }
            
            // Test 4: Verify duplicate detection function directly
            console.log(`\nðŸ”¬ Test 4: Testing isDuplicateContent function directly`);
            
            if (currentContent.length > 0) {
                const existingItem = currentContent[0];
                const duplicateItem = { ...existingItem };
                const uniqueItem = { title: 'Unique Test Item', type: 'show', duration: 30, service: 'TEST' };
                
                const isDup1 = isDuplicateContent(duplicateItem);
                const isDup2 = isDuplicateContent(uniqueItem);
                
                console.log(`ðŸ“Š Duplicate check for existing item: ${isDup1} (should be true)`);
                console.log(`ðŸ“Š Duplicate check for unique item: ${isDup2} (should be false)`);
            }
            
            // Restore original content
            currentContent.length = 0;
            currentContent.push(...originalContent);
            updateProgramTrack();
            
            console.log(`\nâœ… Duplicate prevention test completed. Channel restored to ${currentContent.length} items.`);
            console.log('ðŸŽ‰ === DUPLICATE PREVENTION TEST COMPLETE ===');
        }

        // Debug function to inspect current content state
        function debugContentState() {
            console.log('=== Content State Debug ===');
            console.log('Current content length:', currentContent.length);
            
            if (currentContent.length > 0) {
                console.log('First item details:', {
                    title: currentContent[0].title,
                    type: currentContent[0].type,
                    service: currentContent[0].service,
                    startTime: currentContent[0].startTime,
                    duration: currentContent[0].duration
                });
                
                console.log('Is detection mode:', isContentDetectionMode());
                console.log('Is first playing:', isFirstItemCurrentlyPlaying());
                console.log('Is protected:', currentContent.length > 0 && 
                           isContentDetectionMode() && 
                           isFirstItemCurrentlyPlaying());
            }
            
            console.log('All content items:', currentContent);
            console.log('=== Debug Complete ===');
        }

        // Debug function to force show program track
        function forceShowProgramTrack() {
            console.log('=== Force Show Program Track ===');
            const programTrack = document.getElementById('program-track');
            console.log('Program track element:', programTrack);
            console.log('Program track display style:', programTrack.style.display);
            
            programTrack.style.display = 'block';
            console.log('Set program track display to block');
            
            updateProgramTrack();
            console.log('Updated program track');
            
            console.log('Program track children count:', programTrack.children.length);
            console.log('=== Force Show Complete ===');
        }

        // Debug function to check positioning
        function debugPositioning() {
            console.log('=== Debug Positioning ===');
            
            if (currentContent.length > 0) {
                const firstItem = currentContent[0];
                console.log('First item:', firstItem);
                
                const leftPosition = calculateLeftPosition(firstItem.startTime);
                const blockWidth = calculateWidth(firstItem.duration);
                
                console.log('Calculated left position:', leftPosition + '%');
                console.log('Calculated block width:', blockWidth + '%');
                console.log('Start time:', firstItem.startTime);
                console.log('Duration:', firstItem.duration);
            }
            
            const track = document.getElementById('program-track');
            console.log('Program track dimensions:', {
                offsetWidth: track.offsetWidth,
                offsetHeight: track.offsetHeight,
                clientWidth: track.clientWidth,
                clientHeight: track.clientHeight
            });
            
            console.log('=== Positioning Debug Complete ===');
        }



        // Debug function to test show detection and auto-population
        function testShowDetection() {
            console.log('=== Testing Show Detection ===');
            
            // Simulate a detected show
            const testShow = {
                title: 'Blade Runner 2049',
                genre: 'Sci-Fi',
                duration: 164,
                season: 'N/A',
                episode: 'N/A'
            };
            
            console.log('Simulating show detection with:', testShow);
            
            // Trigger the show detection handler
            window.dispatchEvent(new MessageEvent('message', {
                data: {
                    type: 'rumi:showDetected',
                    payload: testShow
                }
            }));
            
            console.log('Show detection triggered');
            console.log('Current genre:', currentGenre);
            console.log('Current content length:', currentContent.length);
            
            setTimeout(() => {
                console.log('After timeout - Current content:', currentContent);
                if (currentContent.length > 0) {
                    console.log('First item:', currentContent[0]);
                    console.log('Program track visible:', document.getElementById('program-track').style.display);
                }
            }, 1000);
            
            console.log('=== Test Complete ===');
        }

        // NEW: Update content blocks display based on transition system data
        function updateContentBlocksDisplay(data) {
            console.log('=== UPDATING CONTENT BLOCKS IN CHANNEL ===');
            console.log('Received data:', data);
            
            // Instead of creating a separate content section, we should update the existing
            // program track blocks to reflect the transition system state
            
            const { playedContent, currentShow, elapsedTime, fastModeActive, preserveAllContent, isSessionStart, isTransition, updateType } = data;
            
            // In fast mode, session start, transitions, or when preserveAllContent is true, ensure all program blocks remain visible
            if (fastModeActive || preserveAllContent || isSessionStart || isTransition) {
                console.log('Fast mode, session start, transition, or preserve all content - keeping all blocks visible');
                const programTrack = document.getElementById('program-track');
                if (programTrack) {
                    programTrack.style.display = 'block';
                    // Ensure all program slots are visible
                    const programSlots = programTrack.querySelectorAll('.program-slot');
                    programSlots.forEach(slot => {
                        slot.style.display = 'block';
                        slot.style.visibility = 'visible';
                    });
                }
                
                // If this is a session start and we don't have transition data yet, skip the update
                if (isSessionStart && (!playedContent || playedContent.length === 0)) {
                    console.log('Session start with no transition data - preserving existing content');
                    return;
                }
                
                // If this is a transition with minimal data, only update status, don't replace content
                if (isTransition && updateType === 'status_update') {
                    console.log('Transition status update - preserving existing content, updating status only');
                    updateProgramTrackStatusOnly(playedContent, currentShow, elapsedTime);
                    return;
                }
            }
            
            // Update existing program track blocks based on transition system data
            updateProgramTrackWithTransitionData(playedContent, currentShow, elapsedTime);
            
            console.log('Content blocks display updated in channel');
            console.log('=== END CONTENT BLOCKS UPDATE ===');
        }
        
        // NEW: Helper function to update only the status of program blocks during transitions (preserves all content)
        function updateProgramTrackStatusOnly(playedContent, currentShow, elapsedTime) {
            const programBlocks = document.querySelectorAll('.program-slot');
            
            if (programBlocks.length === 0) {
                console.log('No program blocks found to update status');
                return;
            }
            
            console.log(`Updating status only for ${programBlocks.length} program blocks (preserving all content)`);
            
            // Only update visual status classes and icons, don't remove or hide any blocks
            programBlocks.forEach(block => {
                // Remove status classes but keep the block visible
                block.classList.remove('completed', 'current', 'playing');
                
                // Remove any existing status icons
                const existingIcons = block.querySelectorAll('.status-icon');
                existingIcons.forEach(icon => icon.remove());
                
                // Reset status-related styles but keep block visible
                block.style.opacity = '';
                block.style.transform = '';
                block.style.boxShadow = '';
                block.style.border = '';
                block.style.background = '';
                
                // Ensure block remains visible
                block.style.display = 'block';
                block.style.visibility = 'visible';
            });
            
            // Mark played content as completed (status only)
            if (playedContent && playedContent.length > 0) {
                playedContent.forEach((content, index) => {
                    const matchingBlock = findMatchingProgramBlock(content);
                    if (matchingBlock) {
                        console.log(`Updating status to completed: ${content.title}`);
                        matchingBlock.classList.add('completed');
                        
                        // Add checkmark icon
                        const checkIcon = document.createElement('span');
                        checkIcon.className = 'status-icon';
                        checkIcon.textContent = 'âœ“';
                        checkIcon.style.position = 'absolute';
                        checkIcon.style.top = '5px';
                        checkIcon.style.right = '5px';
                        checkIcon.style.fontSize = '12px';
                        checkIcon.style.color = '#4CAF50';
                        matchingBlock.style.position = 'relative';
                        matchingBlock.appendChild(checkIcon);
                    }
                });
            }
            
            // Mark current show as active/playing (status only)
            if (currentShow) {
                const currentBlock = findMatchingProgramBlock(currentShow);
                if (currentBlock) {
                    console.log(`Updating status to current: ${currentShow.title}`);
                    currentBlock.classList.add('current', 'playing');
                    
                    // Add play icon
                    const playIcon = document.createElement('span');
                    playIcon.className = 'status-icon';
                    playIcon.textContent = 'â–¶';
                    playIcon.style.position = 'absolute';
                    playIcon.style.top = '5px';
                    playIcon.style.right = '5px';
                    playIcon.style.fontSize = '12px';
                    playIcon.style.color = '#2196F3';
                    currentBlock.style.position = 'relative';
                    currentBlock.appendChild(playIcon);
                }
            }
            
            console.log('Status-only update completed - all content preserved');
        }
        
        // Helper function to update program track blocks with transition system data
        function updateProgramTrackWithTransitionData(playedContent, currentShow, elapsedTime) {
            const programBlocks = document.querySelectorAll('.program-slot');
            
            if (programBlocks.length === 0) {
                console.log('No program blocks found to update');
                return;
            }
            
            console.log(`Updating ${programBlocks.length} program blocks with transition data`);
            
            // Reset all blocks to default state first
            programBlocks.forEach(block => {
                block.classList.remove('completed', 'current', 'playing');
                // Reset inline styles to let CSS take over
                block.style.opacity = '';
                block.style.transform = '';
                block.style.boxShadow = '';
                block.style.border = '';
                block.style.background = '';
                
                // Remove any existing status icons
                const existingIcons = block.querySelectorAll('.status-icon');
                existingIcons.forEach(icon => icon.remove());
            });
            
            // Mark played content as completed
            if (playedContent && playedContent.length > 0) {
                playedContent.forEach((content, index) => {
                    const matchingBlock = findMatchingProgramBlock(content);
                    if (matchingBlock) {
                        console.log(`Marking block as completed: ${content.title}`);
                        matchingBlock.classList.add('completed');
                        
                        // Add checkmark icon
                        const checkIcon = document.createElement('span');
                        checkIcon.className = 'status-icon';
                        checkIcon.textContent = 'âœ“';
                        matchingBlock.style.position = 'relative';
                        matchingBlock.appendChild(checkIcon);
                    }
                });
            }
            
            // Mark current show as active/playing
            if (currentShow) {
                const currentBlock = findMatchingProgramBlock(currentShow);
                if (currentBlock) {
                    console.log(`Marking block as current: ${currentShow.title}`);
                    currentBlock.classList.add('current', 'playing');
                    
                    // Add play icon
                    const playIcon = document.createElement('span');
                    playIcon.className = 'status-icon';
                    playIcon.textContent = 'â–¶';
                    currentBlock.style.position = 'relative';
                    currentBlock.appendChild(playIcon);
                }
            }
        }
        
        // Helper function to find matching program block for content
        function findMatchingProgramBlock(content) {
            const programBlocks = document.querySelectorAll('.program-slot');
            
            for (const block of programBlocks) {
                const blockTitle = block.querySelector('.program-title')?.textContent;
                if (blockTitle && content.title && blockTitle.includes(content.title)) {
                    return block;
                }
                
                // Also try matching the full block text content
                const blockText = block.textContent;
                if (blockText && content.title && blockText.includes(content.title)) {
                    return block;
                }
            }
            
            console.log(`No matching program block found for: ${content.title}`);
            return null;
        }

        // Function to clean up any weird content containers that were incorrectly added
        function cleanupWeirdContentContainers() {
            console.log('Cleaning up weird content containers...');
            
            // Remove the incorrect content-blocks-container if it exists
            const weirdContainer = document.getElementById('content-blocks-container');
            if (weirdContainer) {
                console.log('Removing weird content-blocks-container');
                weirdContainer.remove();
            }
            
            // Remove any other weird content sections
            const weirdSections = document.querySelectorAll('.content-block, .session-content');
            weirdSections.forEach(section => {
                console.log('Removing weird content section:', section.className);
                section.remove();
            });
            
            console.log('Cleanup complete');
        }
 
        // Initialize
    </script>
</body>
</html> 