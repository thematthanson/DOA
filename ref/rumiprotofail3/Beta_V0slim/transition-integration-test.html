<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transition System Integration Test</title>
    <style>
        body {
            font-family: 'SF Mono', monospace;
            background: #000;
            color: #00ff41;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #111;
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 20px;
        }

        .test-header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 1px solid #333;
            padding-bottom: 20px;
        }

        .test-section {
            margin-bottom: 30px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 6px;
            border: 1px solid #333;
        }

        .test-button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .test-button:hover {
            background: #00cc33;
            transform: translateY(-2px);
        }

        .test-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .status-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .log-panel {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-size: 11px;
            margin-top: 20px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-entry.info { color: #00ff41; }
        .log-entry.warn { color: #ffaa00; }
        .log-entry.error { color: #ff4444; }
        .log-entry.test { color: #00aaff; }

        .integration-status {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-indicator {
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            flex: 1;
        }

        .status-indicator.success {
            background: #1a3a1a;
            border: 1px solid #00ff41;
            color: #00ff41;
        }

        .status-indicator.warning {
            background: #3a2a1a;
            border: 1px solid #ffaa00;
            color: #ffaa00;
        }

        .status-indicator.error {
            background: #3a1a1a;
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .comparison-table th,
        .comparison-table td {
            border: 1px solid #333;
            padding: 8px;
            text-align: left;
        }

        .comparison-table th {
            background: #222;
            color: #00ff41;
        }

        .comparison-table td {
            background: #1a1a1a;
        }

        .feature-status {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .feature-status.implemented { background: #00ff41; }
        .feature-status.partial { background: #ffaa00; }
        .feature-status.missing { background: #ff4444; }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>TRANSITION SYSTEM INTEGRATION TEST</h1>
            <p>Testing safe integration of transition system into main application</p>
        </div>

        <!-- Integration Status -->
        <div class="integration-status">
            <div class="status-indicator success" id="system-status">
                <strong>Transition System</strong><br>
                Ready for Integration
            </div>
            <div class="status-indicator warning" id="main-app-status">
                <strong>Main Application</strong><br>
                Integration Pending
            </div>
            <div class="status-indicator error" id="test-status">
                <strong>Tests</strong><br>
                Not Run
            </div>
        </div>

        <!-- Test Controls -->
        <div class="test-section">
            <h3>Integration Test Controls</h3>
            <div class="test-controls">
                <button class="test-button" onclick="runUnitTests()">Run Unit Tests</button>
                <button class="test-button" onclick="testIntegration()">Test Integration</button>
                <button class="test-button" onclick="simulateMainApp()">Simulate Main App</button>
                <button class="test-button" onclick="testStateManagement()">Test State Management</button>
                <button class="test-button" onclick="testUICallbacks()">Test UI Callbacks</button>
                <button class="test-button" onclick="generateIntegrationReport()">Generate Report</button>
                <button class="test-button" onclick="clearLog()">Clear Log</button>
            </div>
        </div>

        <!-- Feature Comparison -->
        <div class="test-section">
            <h3>Feature Integration Status</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Prototype Status</th>
                        <th>Main App Status</th>
                        <th>Integration Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="feature-status implemented"></span>Content Tracking</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ö†Ô∏è Partial</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                    <tr>
                        <td><span class="feature-status implemented"></span>Multiplier System</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ùå Missing</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                    <tr>
                        <td><span class="feature-status implemented"></span>Show Transitions</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ö†Ô∏è Basic</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                    <tr>
                        <td><span class="feature-status implemented"></span>Session Management</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ö†Ô∏è Partial</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                    <tr>
                        <td><span class="feature-status implemented"></span>Receipt Generation</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ùå Missing</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                    <tr>
                        <td><span class="feature-status partial"></span>UI Coordination</td>
                        <td>‚úÖ Implemented</td>
                        <td>‚ö†Ô∏è Partial</td>
                        <td>üîÑ Ready for Integration</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Current State Display -->
        <div class="test-section">
            <h3>Current State</h3>
            <div class="status-panel">
                <div class="status-item">
                    <span>Current Show:</span>
                    <span id="current-show">None</span>
                </div>
                <div class="status-item">
                    <span>Session Duration:</span>
                    <span id="session-duration">0 minutes</span>
                </div>
                <div class="status-item">
                    <span>Indexing Status:</span>
                    <span id="indexing-status">Inactive</span>
                </div>
                <div class="status-item">
                    <span>Transition State:</span>
                    <span id="transition-state">Ready</span>
                </div>
                <div class="status-item">
                    <span>Multiplier:</span>
                    <span id="multiplier">1.0x</span>
                </div>
                <div class="status-item">
                    <span>Time Indexed:</span>
                    <span id="time-indexed">0/0 minutes</span>
                </div>
            </div>
        </div>

        <!-- Test Log -->
        <div class="test-section">
            <h3>Integration Test Log</h3>
            <div class="log-panel" id="log-panel">
                <div class="log-entry info">Integration test environment initialized. Ready to test transition system integration.</div>
            </div>
        </div>
    </div>

    <script>
        // Mock Transition System (simulating the actual module)
        class MockTransitionSystem {
            constructor() {
                this.state = {
                    currentShow: null,
                    isIndexing: false,
                    isTransitioning: false,
                    multiplier: 1.0,
                    sessionTime: 0,
                    totalSessionLength: 0,
                    timeIndexed: 0,
                    multiplierThresholds: [
                        { time: 60, multiplier: 1.2 },
                        { time: 120, multiplier: 1.5 },
                        { time: 180, multiplier: 2.0 }
                    ],
                    completedContent: new Set(),
                    playedContent: [],
                    baseRate: 0.1,
                    sessionId: Date.now(),
                    uiCallbacks: {
                        onStateChange: null,
                        onShowChange: null,
                        onMultiplierChange: null,
                        onProgressUpdate: null,
                        onSessionComplete: null
                    }
                };
                
                this.log = [];
                this.testMode = true;
            }

            initialize(show, options = {}) {
                this.logEntry('Initializing transition system', 'info');
                
                this.state.currentShow = show;
                this.state.isIndexing = true;
                this.state.totalSessionLength = show.duration || 0;
                this.state.timeIndexed = 0;
                this.state.sessionTime = 0;
                this.state.multiplier = 1.0;
                
                if (options.uiCallbacks) {
                    this.state.uiCallbacks = { ...this.state.uiCallbacks, ...options.uiCallbacks };
                }
                
                this.logEntry(`Initialized with: ${show.title} (${show.duration}min)`, 'info');
                this.triggerUIUpdate('state');
            }

            updateSessionTime(seconds) {
                const oldMultiplier = this.state.multiplier;
                this.state.sessionTime = seconds;
                this.state.multiplier = this.calculateMultiplier(seconds);
                
                if (this.state.multiplier !== oldMultiplier) {
                    this.logEntry(`Multiplier changed: ${oldMultiplier.toFixed(1)}x ‚Üí ${this.state.multiplier.toFixed(1)}x`, 'info');
                    this.triggerUIUpdate('multiplier');
                }
            }

            updateIndexingProgress(minutes) {
                this.state.timeIndexed += minutes;
                this.logEntry(`Indexed ${minutes} minutes. Total: ${this.state.timeIndexed}/${this.state.totalSessionLength}`, 'info');
                this.triggerUIUpdate('progress');
            }

            calculateMultiplier(sessionTime) {
                let multiplier = 1.0;
                for (const threshold of this.state.multiplierThresholds) {
                    if (sessionTime >= threshold.time * 60) {
                        multiplier = threshold.multiplier;
                    }
                }
                return multiplier;
            }

            async transitionToShow(newShow) {
                if (!this.state.currentShow) {
                    throw new Error('No current show to transition from');
                }

                this.logEntry('=== SMOOTH SHOW TRANSITION STARTED ===', 'info');
                this.logEntry(`From: ${this.state.currentShow.title}`, 'info');
                this.logEntry(`To: ${newShow.title}`, 'info');

                this.state.isTransitioning = true;
                this.triggerUIUpdate('state');

                if (this.state.timeIndexed > 0) {
                    const points = this.state.timeIndexed * this.state.baseRate * this.state.multiplier;
                    this.state.playedContent.push({
                        title: this.state.currentShow.title,
                        timeIndexed: this.state.timeIndexed,
                        points: points,
                        multiplier: this.state.multiplier,
                        duration: this.state.currentShow.duration
                    });
                    this.logEntry(`Recorded played content: ${this.state.currentShow.title} - ${this.state.timeIndexed}min indexed, ${points.toFixed(2)} points`, 'info');
                }

                this.markContentAsCompleted(this.state.currentShow.id || this.state.currentShow.title);
                this.state.currentShow = newShow;
                this.state.totalSessionLength += newShow.duration || 0;
                this.state.timeIndexed = 0;

                this.logEntry(`Total session length increased to ${this.state.totalSessionLength} minutes`, 'info');
                this.logEntry(`Progress reset for new show: ${newShow.title}`, 'info');

                await this.delay(1000);

                this.state.isTransitioning = false;
                this.triggerUIUpdate('show');
                this.logEntry('=== SMOOTH SHOW TRANSITION COMPLETED ===', 'info');
            }

            markContentAsCompleted(contentId) {
                this.state.completedContent.add(contentId);
                this.logEntry(`Content marked as completed: ${contentId}`, 'info');
            }

            getCurrentState() {
                return {
                    currentShow: this.state.currentShow,
                    isIndexing: this.state.isIndexing,
                    isTransitioning: this.state.isTransitioning,
                    multiplier: this.state.multiplier,
                    sessionTime: this.state.sessionTime,
                    totalSessionLength: this.state.totalSessionLength,
                    timeIndexed: this.state.timeIndexed,
                    completedContent: Array.from(this.state.completedContent),
                    playedContent: [...this.state.playedContent]
                };
            }

            triggerUIUpdate(type) {
                const callbacks = this.state.uiCallbacks;
                
                switch (type) {
                    case 'state':
                        if (callbacks.onStateChange) {
                            callbacks.onStateChange(this.getCurrentState());
                        }
                        break;
                    case 'show':
                        if (callbacks.onShowChange) {
                            callbacks.onShowChange(this.state.currentShow, this.getCurrentState());
                        }
                        break;
                    case 'multiplier':
                        if (callbacks.onMultiplierChange) {
                            callbacks.onMultiplierChange(this.state.multiplier, this.getCurrentState());
                        }
                        break;
                    case 'progress':
                        if (callbacks.onProgressUpdate) {
                            callbacks.onProgressUpdate(this.state.timeIndexed, this.state.totalSessionLength, this.getCurrentState());
                        }
                        break;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            logEntry(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = {
                    timestamp,
                    message,
                    type,
                    state: this.getCurrentState()
                };
                
                this.log.push(entry);
                log(`[${timestamp}] ${message}`, type);
            }

            getSessionReceipt() {
                const totalPoints = this.state.playedContent.reduce((sum, item) => sum + item.points, 0);
                const totalTimeIndexed = this.state.playedContent.reduce((sum, item) => sum + item.timeIndexed, 0);

                return {
                    sessionId: this.state.sessionId,
                    totalPoints: totalPoints,
                    totalTimeIndexed: totalTimeIndexed,
                    numberOfShows: this.state.playedContent.length,
                    finalMultiplier: this.state.multiplier,
                    sessionDuration: this.state.sessionTime,
                    playedContent: [...this.state.playedContent],
                    timestamp: Date.now()
                };
            }
        }

        // Global variables
        let transitionSystem = null;
        let testResults = [];

        // Logging function
        function log(message, type = 'info') {
            const logPanel = document.getElementById('log-panel');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logPanel.appendChild(logEntry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        // Clear log
        function clearLog() {
            document.getElementById('log-panel').innerHTML = '';
            log('Log cleared.');
        }

        // Update UI state display
        function updateStateDisplay() {
            if (!transitionSystem) return;
            
            const state = transitionSystem.getCurrentState();
            
            document.getElementById('current-show').textContent = state.currentShow ? state.currentShow.title : 'None';
            document.getElementById('session-duration').textContent = `${state.totalSessionLength} minutes`;
            document.getElementById('indexing-status').textContent = state.isIndexing ? 'Active' : 'Inactive';
            document.getElementById('transition-state').textContent = state.isTransitioning ? 'Transitioning' : 'Ready';
            document.getElementById('multiplier').textContent = `${state.multiplier.toFixed(1)}x`;
            document.getElementById('time-indexed').textContent = `${state.timeIndexed}/${state.totalSessionLength} minutes`;
        }

        // UI Callbacks for integration testing
        const uiCallbacks = {
            onStateChange: (state) => {
                log('UI Callback: State changed', 'test');
                updateStateDisplay();
            },
            onShowChange: (show, state) => {
                log(`UI Callback: Show changed to ${show.title}`, 'test');
                updateStateDisplay();
            },
            onMultiplierChange: (multiplier, state) => {
                log(`UI Callback: Multiplier changed to ${multiplier.toFixed(1)}x`, 'test');
                updateStateDisplay();
            },
            onProgressUpdate: (timeIndexed, totalLength, state) => {
                log(`UI Callback: Progress updated - ${timeIndexed}/${totalLength} minutes`, 'test');
                updateStateDisplay();
            }
        };

        // Test functions
        function runUnitTests() {
            log('=== RUNNING UNIT TESTS ===', 'test');
            
            const tests = [
                {
                    name: 'System Initialization',
                    test: () => {
                        transitionSystem = new MockTransitionSystem();
                        const testShow = { title: 'Test Show', duration: 120, id: 'test-show' };
                        transitionSystem.initialize(testShow, { uiCallbacks });
                        
                        const state = transitionSystem.getCurrentState();
                        if (state.currentShow.title !== 'Test Show') throw new Error('Show title mismatch');
                        if (state.totalSessionLength !== 120) throw new Error('Session length mismatch');
                        if (state.multiplier !== 1.0) throw new Error('Initial multiplier mismatch');
                        
                        log('‚úì System initialization test passed', 'test');
                    }
                },
                {
                    name: 'Multiplier Progression',
                    test: () => {
                        transitionSystem.updateSessionTime(90 * 60); // 90 minutes
                        if (transitionSystem.state.multiplier !== 1.2) throw new Error('Multiplier progression failed');
                        
                        transitionSystem.updateSessionTime(150 * 60); // 150 minutes
                        if (transitionSystem.state.multiplier !== 1.5) throw new Error('Multiplier progression failed');
                        
                        log('‚úì Multiplier progression test passed', 'test');
                    }
                },
                {
                    name: 'Show Transition',
                    test: async () => {
                        const newShow = { title: 'New Show', duration: 90, id: 'new-show' };
                        await transitionSystem.transitionToShow(newShow);
                        
                        const state = transitionSystem.getCurrentState();
                        if (state.currentShow.title !== 'New Show') throw new Error('Show transition failed');
                        if (state.timeIndexed !== 0) throw new Error('Time indexed not reset');
                        if (state.totalSessionLength !== 210) throw new Error('Total session length not updated');
                        
                        log('‚úì Show transition test passed', 'test');
                    }
                },
                {
                    name: 'Content Completion',
                    test: () => {
                        transitionSystem.markContentAsCompleted('test-show');
                        if (!transitionSystem.state.completedContent.has('test-show')) {
                            throw new Error('Content completion tracking failed');
                        }
                        
                        log('‚úì Content completion test passed', 'test');
                    }
                }
            ];

            let passed = 0;
            let failed = 0;

            tests.forEach(async (testCase) => {
                try {
                    await testCase.test();
                    passed++;
                    testResults.push({ name: testCase.name, status: 'PASS' });
                } catch (error) {
                    failed++;
                    testResults.push({ name: testCase.name, status: 'FAIL', error: error.message });
                    log(`‚úó ${testCase.name} failed: ${error.message}`, 'error');
                }
            });

            log(`Unit tests completed: ${passed} passed, ${failed} failed`, 'test');
            updateTestStatus(passed, failed);
        }

        function testIntegration() {
            log('=== TESTING INTEGRATION ===', 'test');
            
            // Test 1: Integration with main app state
            log('Testing integration with main app state...', 'test');
            
            // Simulate main app state
            const mainAppState = {
                currentShow: { title: 'Blade Runner 2049', duration: 164, id: 'blade-runner-2049' },
                sessionTime: 0,
                indexedContent: [],
                automodeContentItems: [
                    { title: 'Blade Runner 2049', duration: 164 },
                    { title: 'Dune', duration: 155 },
                    { title: 'Arrival', duration: 116 }
                ]
            };
            
            // Initialize transition system with main app data
            transitionSystem = new MockTransitionSystem();
            transitionSystem.initialize(mainAppState.currentShow, { uiCallbacks });
            
            log('‚úì Integration with main app state successful', 'test');
            
            // Test 2: UI callback integration
            log('Testing UI callback integration...', 'test');
            updateStateDisplay();
            log('‚úì UI callback integration successful', 'test');
            
            // Test 3: State synchronization
            log('Testing state synchronization...', 'test');
            transitionSystem.updateSessionTime(90 * 60);
            transitionSystem.updateIndexingProgress(30);
            log('‚úì State synchronization successful', 'test');
            
            log('=== INTEGRATION TEST COMPLETED ===', 'test');
            updateIntegrationStatus('success');
        }

        function simulateMainApp() {
            log('=== SIMULATING MAIN APP INTEGRATION ===', 'test');
            
            // Simulate the main app's show detection and content management
            const mainAppSimulation = {
                detectedShow: { title: 'Blade Runner 2049', duration: 164, id: 'blade-runner-2049' },
                contentItems: [
                    { title: 'Blade Runner 2049', duration: 164, type: 'movie' },
                    { title: 'Dune', duration: 155, type: 'movie' },
                    { title: 'Arrival', duration: 116, type: 'movie' }
                ],
                sessionStartTime: Date.now()
            };
            
            // Initialize transition system
            transitionSystem = new MockTransitionSystem();
            transitionSystem.initialize(mainAppSimulation.detectedShow, { uiCallbacks });
            
            // Simulate session progression
            let sessionTime = 0;
            const sessionInterval = setInterval(() => {
                sessionTime += 60; // 1 minute increments
                transitionSystem.updateSessionTime(sessionTime);
                
                // Simulate indexing progress
                if (sessionTime % 15 === 0) { // Every 15 minutes
                    transitionSystem.updateIndexingProgress(15);
                }
                
                // Simulate show transition after 90 minutes
                if (sessionTime === 90) {
                    clearInterval(sessionInterval);
                    const nextShow = mainAppSimulation.contentItems[1];
                    transitionSystem.transitionToShow(nextShow);
                }
            }, 1000); // 1 second intervals for faster testing
            
            log('Main app simulation started - will transition after 90 seconds', 'test');
        }

        function testStateManagement() {
            log('=== TESTING STATE MANAGEMENT ===', 'test');
            
            if (!transitionSystem) {
                transitionSystem = new MockTransitionSystem();
                transitionSystem.initialize({ title: 'Test Show', duration: 120, id: 'test-show' }, { uiCallbacks });
            }
            
            // Test state persistence
            const initialState = transitionSystem.getCurrentState();
            log('Initial state captured', 'test');
            
            // Modify state
            transitionSystem.updateSessionTime(120 * 60);
            transitionSystem.updateIndexingProgress(60);
            
            const modifiedState = transitionSystem.getCurrentState();
            log('State modified and captured', 'test');
            
            // Verify state changes
            if (modifiedState.multiplier !== 1.2) throw new Error('Multiplier not updated');
            if (modifiedState.timeIndexed !== 60) throw new Error('Time indexed not updated');
            
            log('‚úì State management test passed', 'test');
        }

        function testUICallbacks() {
            log('=== TESTING UI CALLBACKS ===', 'test');
            
            if (!transitionSystem) {
                transitionSystem = new MockTransitionSystem();
                transitionSystem.initialize({ title: 'Test Show', duration: 120, id: 'test-show' }, { uiCallbacks });
            }
            
            // Test each callback type
            log('Testing state change callback...', 'test');
            transitionSystem.triggerUIUpdate('state');
            
            log('Testing multiplier change callback...', 'test');
            transitionSystem.updateSessionTime(90 * 60);
            
            log('Testing progress update callback...', 'test');
            transitionSystem.updateIndexingProgress(30);
            
            log('‚úì UI callbacks test completed', 'test');
        }

        function generateIntegrationReport() {
            log('=== GENERATING INTEGRATION REPORT ===', 'test');
            
            const report = {
                timestamp: new Date().toISOString(),
                testResults: testResults,
                systemState: transitionSystem ? transitionSystem.getCurrentState() : null,
                integrationStatus: {
                    transitionSystem: 'Ready',
                    mainApp: 'Integration Pending',
                    uiCallbacks: 'Configured',
                    stateManagement: 'Functional'
                },
                recommendations: [
                    '1. Add transition system script to main index.html',
                    '2. Initialize transition system in main app startup',
                    '3. Connect UI callbacks to existing UI update functions',
                    '4. Replace existing content tracking with transition system',
                    '5. Add multiplier display to main UI',
                    '6. Implement session receipt generation'
                ]
            };
            
            console.log('=== INTEGRATION REPORT ===');
            console.log(JSON.stringify(report, null, 2));
            
            log('Integration report generated and logged to console', 'test');
            log('Check browser console for detailed report', 'test');
        }

        function updateTestStatus(passed, failed) {
            const testStatus = document.getElementById('test-status');
            if (failed === 0) {
                testStatus.className = 'status-indicator success';
                testStatus.innerHTML = '<strong>Tests</strong><br>All Passed';
            } else {
                testStatus.className = 'status-indicator error';
                testStatus.innerHTML = `<strong>Tests</strong><br>${passed} Passed, ${failed} Failed`;
            }
        }

        function updateIntegrationStatus(status) {
            const mainAppStatus = document.getElementById('main-app-status');
            if (status === 'success') {
                mainAppStatus.className = 'status-indicator success';
                mainAppStatus.innerHTML = '<strong>Main Application</strong><br>Integration Ready';
            }
        }

        // Initialize test environment
        document.addEventListener('DOMContentLoaded', function() {
            log('Integration test environment initialized', 'info');
            log('Ready to test transition system integration with main application', 'info');
        });
    </script>
</body>
</html> 