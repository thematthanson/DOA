<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rumi Extension - Beta V0</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=SF+Mono:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #111;
            color: #fff;
            font-family: 'SF Mono', 'Menlo', 'Courier New', monospace;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 50px;
            min-height: 100vh;
        }

        .simulation-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .entry-point-panel {
            width: 220px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .entry-point-header {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            text-align: center;
            margin-bottom: 10px;
        }

        .stream-detector {
            background: #222;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stream-detector:hover {
            border-color: #00ff41;
            background: #2a2a2a;
        }

        .stream-detector .status {
            font-size: 14px;
            color: #00ff41;
            font-weight: bold;
        }

        .stream-detector .subtext {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .automode-button {
            background: #333;
            color: #ffff00;
            border: 2px solid #ffff00;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .automode-button:hover {
            background: #444;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 255, 0, 0.3);
        }

        .holistic-panel {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .holistic-section {
            width: 100%;
        }

        #holistic-show-info {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        #holistic-animation pre {
            margin: 0;
            padding: 0;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
        }

        #holistic-animation pre.automode {
            color: #ffff00 !important;
        }

        #holistic-progress {
            font-size: 11px;
            color: #fff;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
            display: block !important;
            visibility: visible !important;
            min-height: 50px;
        }

        #holistic-progress div {
            margin: 2px 0;
            text-align: center;
        }

        .settings-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }

        .message-button {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 8px;
            transition: all 0.2s ease;
        }

        .message-button:hover {
            background: #333;
            border-color: #666;
            color: #fff;
        }

        .message-button.primary {
            background: #ffff00;
            border-color: #ffff00;
            color: #000;
        }

        .message-button.primary:hover {
            background: #cccc00;
            border-color: #cccc00;
        }

        .inline-resume-button {
            background: #2a2a2a;
            border: 1px solid #ffff00;
            color: #ffff00;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-resume-button:hover {
            background: #333;
            border-color: #cccc00;
            color: #cccc00;
        }

        .inline-end-session-button {
            background: #2a2a2a;
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 2px 8px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            margin-left: 12px;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .inline-end-session-button:hover {
            background: #333;
            border-color: #ff6666;
            color: #ff6666;
        }

        .channel-switcher {
            background: #222;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .channel-switcher:hover {
            border-color: #ffff00;
            color: #ffff00;
        }

        .channel-switcher.active {
            background: #ffff00;
            color: #000;
            border-color: #ffff00;
        }

        .popup-balance {
            font-size: 11px;
            color: #666;
        }

        /* Message Area */
        .message-area {
            background: #2a2a2a; /* Darker grey background */
            color: #cccccc; /* Light grey text */
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            max-height: 46px;
            overflow: hidden;
            transition: all 0.3s ease;
            border-radius: 8px; /* Rounded corners to match extension */
        }

        .message-area.error {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff0000; /* Red text for terminal errors */
        }

        .message-area.warning {
            background: #2a2a2a; /* Same darker grey as default */
            color: #ff6600; /* Orange text for non-terminal warnings */
        }

        .message-area.info {
            background: #2a2a2a; /* Same darker grey as default */
            color: #8b5cf6; /* Purple text for settings */
        }

        .message-area.collapsed {
            padding: 6px 18px;
            font-size: 12px;
        }

        .message-area.expanded {
            max-height: none;
            padding: 14px 18px;
            font-size: 14px;
        }

        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }

        .collapsed .collapse-icon {
            transform: rotate(180deg);
        }

        /* Popup Body */
        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        /* Points Section */
        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: none;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        /* Automode-specific button styling */
        .primary-cta.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .primary-cta.automode:hover {
            background: #ffff00;
            color: #000;
        }

        .secondary-button.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .cta-subtitle {
            font-size: 12px;
            color: #888;
            margin-bottom: 16px;
            text-align: center;
        }

        /* Queue Section */
        .queue-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .queue-header {
            padding: 8px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .queue-item {
            padding: 6px 12px;
            border-bottom: 1px solid #333;
            font-size: 10px;
        }

        .queue-item:last-child {
            border-bottom: none;
        }

        .queue-item.next {
            background: #1a1000;
            border-left: 3px solid #ffaa00;
        }

        /* Responsive Breakpoints */
        /* ============================================================================
           VERTICAL BREAKPOINT SYSTEM
           ============================================================================ */
        
        /* Baseline (Default) - Standard Desktop/Laptop (768px - 1024px height) */
        /* Current layout serves as the baseline - no changes needed */
        
        /* Very Short Screens - Mobile Landscape (≤ 480px height) */
        @media (max-height: 480px) {
            /* PRIORITY 1: Points section - Always visible */
            .points-section {
                padding: 8px;
                margin-bottom: 8px;
                order: 1;
                flex-shrink: 0;
            }
            
            .points-total {
                font-size: 14px;
                margin-bottom: 4px;
            }
            
            .points-pending {
                font-size: 10px;
            }
            
            /* PRIORITY 2: ASCII art - Compact but visible */
            .ascii-art-container {
                height: 60px !important;
                margin-bottom: 6px;
                order: 2;
                flex-shrink: 0;
            }
            
            /* PRIORITY 3: Other content - Compressed */
            .holistic-panel {
                padding: 6px;
                gap: 6px;
                order: 3;
                flex: 1;
                min-height: 0;
                overflow: hidden;
            }
            
            .holistic-section {
                padding: 4px;
                font-size: 10px;
            }
            
            #animation-panel-content {
                font-size: 7px;
                line-height: 1.0;
                max-height: 40px;
                overflow: hidden;
            }
            
            #channel-frame {
                height: 120px !important;
            }
            
            /* Receipt view adjustments */
            #receipt-content-list {
                max-height: 48px !important; /* 1.5 items visible */
                font-size: 8px;
            }
            
            .leaderboard-section {
                padding: 4px;
                margin-bottom: 6px;
            }
            
            .primary-cta {
                padding: 6px 12px;
                font-size: 11px;
                margin: 6px 0;
            }
            
            /* Force flex layout for priority ordering */
            .holistic-container {
                display: flex;
                flex-direction: column;
                height: 100vh;
                overflow: hidden;
            }
        }
        
        /* Short Screens - Tablet Portrait (481px - 767px height) */
        @media (min-height: 481px) and (max-height: 767px) {
            /* PRIORITY 1: Points section - Prominent */
            .points-section {
                padding: 10px;
                margin-bottom: 10px;
                order: 1;
                flex-shrink: 0;
            }
            
            .points-total {
                font-size: 16px;
                margin-bottom: 6px;
            }
            
            .points-pending {
                font-size: 11px;
            }
            
            /* PRIORITY 2: ASCII art - Moderate size */
            .ascii-art-container {
                height: 80px !important;
                margin-bottom: 8px;
                order: 2;
                flex-shrink: 0;
            }
            
            /* PRIORITY 3: Other content - Balanced */
            .holistic-panel {
                padding: 8px;
                gap: 8px;
                order: 3;
                flex: 1;
                min-height: 0;
            }
            
            .holistic-section {
                padding: 6px;
                font-size: 11px;
            }
            
            #animation-panel-content {
                font-size: 8px;
                line-height: 1.1;
                max-height: 60px;
            }
            
            #channel-frame {
                height: 200px !important;
            }
            
            /* Receipt view adjustments */
            #receipt-content-list {
                max-height: 64px !important; /* 2 items visible */
            }
            
            .leaderboard-section {
                padding: 6px;
                margin-bottom: 8px;
            }
            
            .primary-cta {
                padding: 8px 16px;
                font-size: 12px;
                margin: 8px 0;
            }
            
            /* Force flex layout for priority ordering */
            .holistic-container {
                display: flex;
                flex-direction: column;
                height: 100vh;
            }
        }
        
        /* Standard Screens - Current Baseline (768px - 1023px height) */
        @media (min-height: 768px) and (max-height: 1023px) {
            /* This is our current design - no changes needed */
            /* All existing styles serve as the baseline */
        }
        
        /* Tall Screens - Large Desktop (≥ 1024px height) */
        @media (min-height: 1024px) {
            .holistic-panel {
                padding: 16px;
                gap: 16px;
            }
            
            .holistic-section {
                padding: 12px;
                font-size: 14px;
            }
            
            #animation-panel-content {
                font-size: 11px;
                line-height: 1.4;
            }
            
            .points-section {
                padding: 16px;
                margin-bottom: 16px;
            }
            
            .points-total {
                font-size: 20px;
                margin-bottom: 8px;
            }
            
            .points-pending {
                font-size: 13px;
            }
            
            #channel-frame {
                height: 400px !important;
            }
            
            /* Receipt view adjustments */
            #receipt-content-list {
                max-height: 160px !important; /* 5 items visible */
            }
            
            .leaderboard-section {
                padding: 12px;
                margin-bottom: 16px;
            }
            
            .primary-cta {
                padding: 14px 28px;
                font-size: 15px;
                margin: 16px 0;
            }
            
            /* More generous spacing for tall screens */
            .nokia-section {
                padding: 16px 0;
            }
        }
        
        /* Legacy extension popup breakpoints */
        @media (max-height: 600px) {
            .extension-popup {
                height: 450px;
            }
        }

        @media (max-height: 450px) {
            .extension-popup {
                height: 350px;
            }
        }

        @media (max-height: 350px) {
            .extension-popup {
                height: 250px;
            }
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #00ff41;
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 10000;
            min-width: 200px;
            display: none; /* Hidden by default */
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-trigger {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            color: #666;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 8px;
            cursor: pointer;
            z-index: 9999;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .debug-trigger:hover {
            border-color: #00ff41;
            color: #00ff41;
            opacity: 1;
        }

        .debug-panel-header {
            color: #00ff41;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .debug-panel-toggle {
            background: none;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-panel-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section {
            margin-bottom: 8px;
            border-top: 1px solid #333;
            padding-top: 8px;
        }

        .debug-section:first-child {
            border-top: none;
            padding-top: 0;
        }

        .debug-section-header {
            color: #888;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-section-toggle {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 10px;
            padding: 0;
            transition: transform 0.2s;
        }

        .debug-section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .debug-section-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .debug-section-content.collapsed {
            max-height: 0;
        }

        .debug-button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 2px;
            font-size: 9px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
        }

        .debug-button.error {
            background: #ff4444;
            color: #fff;
        }

        .debug-button.warning {
            background: #ffaa00;
            color: #000;
        }

        .debug-button.info {
            background: #a985ff;
            color: #000;
        }

        .debug-button.blue {
            background: #0088ff;
            color: #fff;
        }

        .debug-button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .debug-button.cooldown {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Progress Bars */
        .progress-bars {
            display: flex;
            gap: 2px;
            height: 28px;
            margin: 8px 0;
            position: relative;
        }

        .progress-bar {
            border-radius: 2px;
        }

        /* Stop Button Styles */
        .primary-cta.stop {
            background: #000000;
            color: #00ff41;
            border: 2px solid #00ff41;
        }

        .primary-cta.stop:hover {
            background: #00ff41;
            color: #000000;
        }

        .primary-cta.stop.automode {
            color: #ffff00;
            border-color: #ffff00;
        }

        .primary-cta.stop.automode:hover {
            background: #ffff00;
            color: #000000;
        }

        /* Leaderboard Section */
        .leaderboard-section {
            background: #111;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .leaderboard-section:hover {
            border-color: #555;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 9px;
        }

        .leaderboard-header .title {
            color: #00ff41;
            font-weight: 600;
            text-transform: uppercase;
        }

        .leaderboard-header .user-rank {
            color: #00ff41;
        }

        /* Automode-specific leaderboard styling */
        .automode .leaderboard-header .title {
            color: #ffff00;
        }

        .automode .leaderboard-header .user-rank {
            color: #ffff00;
        }

        .leaderboard-expand-icon {
            transition: transform 0.3s ease;
            font-size: 12px;
            color: #666;
        }

        .leaderboard-section.is-expanded .leaderboard-expand-icon {
            transform: rotate(180deg);
        }

        .leaderboard-full-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            margin-top: 0;
            border-top: none;
            font-size: 9px;
        }

        .leaderboard-section.is-expanded .leaderboard-full-list {
            max-height: 200px; /* Adjust as needed */
            padding-top: 8px;
            margin-top: 8px;
            border-top: 1px solid #333;
        }

        /* Error States */
        .error-state {
            display: none;
        }

        .error-content {
            padding: 12px;
        }

        .status-indicator-terminal {
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 12px;
            margin: 15px 0;
            border: 2px solid;
            background: #111111;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
        }

        .status-indicator-terminal.warning {
            border-color: #ffaa00;
            color: #ffaa00;
            background: #1a1000;
        }

        .status-indicator-terminal.error {
            border-color: #ff4444;
            color: #ff4444;
            background: #1a0000;
        }

        /* Pulse animation for loading */
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .pulse { 
            animation: pulse 1.5s infinite; 
        }

        /* Indexing Details Section */
        .indexing-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 15px;
            padding: 0 5px;
        }

        .indexing-progress-bar-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 80px;
            margin-bottom: 15px;
            gap: 2px;
        }

        .progress-bar-segment {
            background-color: #00ff41;
            width: 12px;
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .automode .progress-bar-segment {
            background-color: #ffff00;
        }
        
        .progress-bar-segment.grey {
            background-color: #444;
        }

        .progress-bar-divider {
            width: 1px;
            height: 60%;
            background: #555;
            margin: 0 5px;
        }

        .progress-bar-annotation {
            color: #fff;
            font-size: 8px;
            text-align: center;
            line-height: 1.1;
        }
        
        .progress-bar-segment.special-segment {
            width: 30px;
            height: 90%;
            background-color: #333;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px 0;
        }

        .progress-bar-annotation.top-annotation {
            color: #fff;
        }

        .progress-bar-annotation.bottom-annotation {
            color: #888;
        }

        .indexing-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .now-playing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .now-playing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .stats-info {
            text-align: right;
        }

        .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }
        
        /* Remove old separated layout styles */
        .now-next-container, .now-playing-card, .next-up-card, .reward-info, .progress-time {
            all: unset; /* Reset properties from old layout */
        }
        
        .card-header span:nth-child(2) {
            margin: 0 4px;
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        /* New Indexing UI */
        .indexing-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
        }

        .indexing-content .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        .indexing-content .indexing-info {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
            margin-bottom: 10px;
        }

        .indexing-content .indexing-info .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .indexing-content .indexing-info .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .indexing-content .stats-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-top: 10px;
        }

        .indexing-content .stats-info .reward-info {
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
        }

        .indexing-content .stats-info .progress-time {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #888;
        }

        /* New Horizontal Progress Bar */
        .horizontal-progress-bar {
            width: 100%;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .horizontal-progress-bar-fill {
            height: 100%;
            background: #00ff41;
            transition: width 0.5s ease;
        }

        /* New Flippable Card */
        .card-flipper {
            perspective: 1000px;
            width: 100%;
            height: 100px;
            position: relative;
        }

        .card-flipper .card {
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            position: absolute;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .card-flipper .card.front {
            transform: rotateY(0deg);
        }

        .card-flipper .card.back {
            transform: rotateY(180deg);
        }

        .card-flipper.is-flipped .card.front {
            transform: rotateY(-180deg);
        }

        .card-flipper.is-flipped .card.back {
            transform: rotateY(0deg);
        }

        .card-flipper .card-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
        }

        .card-flipper .card-content .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-flipper .card-content .card-title {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
        }

        .card-flipper .card-content .flip-button {
            background: transparent;
            border: none;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        /* Indexing Details Section */
        .nokia-section {
            background: #080808;
            border-radius: 8px;
            padding: 15px;
        }

        .indexing-window, .session-stats-panel {
            background: #111;
            border: 1px solid #333;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-shadow: 0 0 2px #00ff41;
        }
        
        .indexing-window pre, .session-stats-panel pre {
            margin: 0;
            line-height: 1.4;
            white-space: pre-wrap;
            text-align: center;
            color: #00ff41;
            font-weight: bold;
        }
        
        .bonus-glint {
            color: #a985ff;
            font-weight: 700;
        }
        
        .now-playing-section {
            background: #1c1c1c;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
        }

        .now-playing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-header {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .card-title {
            font-size: 15px;
            font-weight: 600;
        }

        .show-queue-button {
            width: 100%;
            background: #2a2a2a;
            color: #a985ff;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
            text-align: center;
        }
        
        .queue-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding-top 0.4s ease-out;
            padding-top: 0;
            border-top: 1px solid #333;
        }

        .queue-details.is-expanded {
            max-height: 200px;
            padding-top: 10px;
            margin-top: 10px;
        }

        .queue-item {
            font-size: 12px;
            color: #ccc;
            padding: 4px 0;
        }

        /* Settings View */
        .settings-section {
            background: #1c1c1c;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .settings-section-header {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .settings-item:last-child {
            margin-bottom: 0;
        }

        .settings-label {
            color: #ccc;
        }

        .settings-value {
            color: #00ff41;
            font-weight: 600;
        }

        .settings-logout-button {
            width: 100%;
            background: #4d0000;
            color: #ff4444;
            border: 1px solid #ff4444;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            cursor: pointer;
            font-family: 'SF Mono', monospace;
            text-transform: uppercase;
            margin-top: 12px;
        }

        /* Toggle Switch CSS */
        .switch {
          position: relative;
          display: inline-block;
          width: 34px;
          height: 20px;
        }

        .switch input { 
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #333;
          transition: .4s;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 14px;
          width: 14px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          transition: .4s;
        }

        input:checked + .slider {
          background-color: #00ff41;
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #00ff41;
        }

        input:checked + .slider:before {
          transform: translateX(14px);
        }

        .slider.round {
          border-radius: 20px;
        }

        .slider.round:before {
          border-radius: 50%;
        }

        /* Remove ALL old layout styles */
        .points-and-progress, .nokia-visualizer, .horizontal-progress-bar-container, .horizontal-progress-bar,
        .indexing-info, .now-playing-info, .stats-info, .card-flipper, .card-front, .card-back, .card-footer, .now-next-container,
        .now-playing-card, .next-up-card, .reward-info, .progress-time, .top-stats, .bottom-stats {
            all: unset;
        }

        /* Bonus Glint Animation */
        .bonus-glint {
            color: #ffaa00;
            animation: glint 2s ease-in-out infinite;
        }

        @keyframes glint {
            0%, 100% { 
                opacity: 0.3; 
                color: #ffaa00;
            }
            50% { 
                opacity: 1; 
                color: #ffdd00;
                text-shadow: 0 0 4px #ffaa00;
            }
        }

        /* Smooth animation transitions */
        .indexing-window pre {
            transition: all 0.1s ease-out;
        }

        .session-stats-panel pre {
            transition: all 0.2s ease-out;
        }

        /* NEW: Styles for channel view to be flexible */
        #channels-view .popup-body {
            height: 100%;
        }

        .extension-popup {
            width: 700px;
            margin: 0 auto;
            background-color: #0d0d0d;
            border: none;
            border-radius: 12px;
            overflow: hidden;
            display: none;
            flex-direction: column;
            align-items: stretch;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            position: relative;
        }

        .popup-header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1100;
        }

        .popup-body {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            width: 100%;
            box-sizing: border-box;
        }

        .points-section {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 20px;
            /* border: 2px solid #00ff41; */
            width: 100%;
            box-sizing: border-box;
        }

        .points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .points-total {
            font-size: 20px;
            font-weight: 700;
            color: #00ff41;
        }

        .points-pending {
            font-size: 11px;
            color: #ffaa00;
        }

        /* Nokia Visual */
        .nokia-visual {
            width: 100%;
            height: 45px;
            background: linear-gradient(45deg, #001100, #003300);
            border: 1px solid #00ff41;
            border-radius: 4px;
            margin: 0 auto 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 6px;
            color: #00ff41;
            overflow: hidden;
        }

        /* Buttons */
        .primary-cta {
            width: 100%;
            padding: 12px 20px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
            transition: all 0.3s ease;
        }

        .primary-cta:hover {
            background: #00ff41;
            color: #000;
        }

        .primary-cta:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .primary-cta:disabled:hover {
            background: #333;
            color: #666;
        }

        .secondary-button {
            width: 100%;
            padding: 12px 16px;
            background: #222;
            color: #00ff41;
            border: 2px solid #00ff41;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'SF Mono', monospace;
        }

        /* Expandable Sections */
        .expandable-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            background: #111111;
            border: 1px solid #333333;
            margin: 8px 0;
        }

        .expandable-section.expanded {
            max-height: 800px; /* Increased to accommodate comprehensive settings content */
        }

        .expandable-content {
            padding: 12px;
            font-size: 10px;
            line-height: 1.4;
        }

        .expandable-title {
            font-size: 11px;
            font-weight: 600;
            color: #00ff41;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Paused State Styles */
        .paused .points-total,
        .paused .points-pending,
        .paused .animation-panel-content,
        .paused .nokia-visual,
        .paused .progress-bar-segment,
        .paused .horizontal-progress-bar-fill,
        .paused .holistic-show-info,
        .paused .holistic-section,
        .paused .holistic-panel,
        .paused #animation-panel-content,
        .paused #holistic-show-info,
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .primary-cta,
        .paused .secondary-button,
        .paused .channel-switcher,
        .paused .expandable-section,
        .paused .expandable-content,
        .paused .leaderboard-section,
        .paused .leaderboard-header,
        .paused .queue-item,
        .paused .settings-section,
        .paused .settings-item,
        .paused .settings-label,
        .paused .settings-value,
        .paused .popup-header,
        .paused .popup-body,
        .paused .points-section,
        .paused .points-header,
        .paused .nokia-section,
        .paused .holistic-panel,
        .paused .holistic-section,
        .paused .holistic-show-info,
        .paused .holistic-animation,
        .paused .detected-show-ui-indexing,
        .paused .expandable-channel-section-indexing,
        .paused .expand-channel-header-indexing,
        .paused .channel-iframe-container-indexing {
            color: #888 !important;
            opacity: 0.6;
        }

        /* Keep progress bar visible even when paused */
        .paused .holistic-progress,
        .paused #holistic-progress {
            color: #ccc !important;
            opacity: 0.8 !important;
        }

        /* Paused state for buttons - change border colors too */
        .paused .primary-cta,
        .paused .secondary-button {
            border-color: #666 !important;
            color: #888 !important;
            opacity: 0.6;
        }

        /* Stronger specificity for points display */
        .paused #points-primary-display,
        .paused #points-secondary-display,
        .paused .points-total,
        .paused .points-pending {
            color: #888 !important;
            opacity: 0.6 !important;
        }

        .paused .progress-bar-segment {
            background-color: #666 !important;
        }

        .paused .horizontal-progress-bar-fill {
            background: #666 !important;
        }

        .paused .nokia-visual {
            border-color: #666 !important;
            color: #666 !important;
        }

        .paused .animation-panel-content {
            animation-play-state: paused !important;
        }

        /* Pause indicator */
        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffaa00;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 10;
            display: none;
        }

        .paused .pause-indicator {
            display: block;
        }

        /* Activation step styles */
        .extension-popup.deactivated {
            opacity: 1.0;
            filter: none;
            pointer-events: all;
        }

        .extension-popup.clicked {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        .activation-container {
            position: fixed;
            top: calc(50% - 350px); /* higher above the popup */
            left: 50%;
            transform: translate(-50%, 0);
            display: none; /* Initially hidden, shown when needed */
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0066ff;
            border-radius: 24px;
            padding: 12px 20px;
            cursor: pointer;
            z-index: 99999;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 0 0 4px rgba(0,102,255,0.08);
            transition: all 0.3s ease;
            gap: 12px;
        }

        .activation-container.show {
            display: flex;
        }

        .activation-container:hover {
            border-color: #0099ff;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.5);
            background: rgba(0, 0, 0, 0.9);
        }

        .activation-container.activated {
            border-color: #0066ff;
            box-shadow: 0 0 20px rgba(0, 102, 255, 0.8);
            background: rgba(0, 102, 255, 0.1);
        }

        .activation-circle {
            width: 32px;
            height: 32px;
            border: 3px solid #0066ff;
            border-radius: 50%;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #0066ff;
            transition: all 0.3s ease;
        }

        .activation-circle::after {
            content: 'r';
        }

        .activation-container.activated .activation-circle {
            background: #0066ff;
            border-color: #0066ff;
            color: white;
        }

        .activation-container.activated .activation-circle::after {
            content: 'r';
        }

        .activation-text {
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Learning Insights and Dashboard Styles */
        .insights-banner {
            background-color: #333300;
            border: 1px solid #666600;
            padding: 16px;
            border-radius: 4px;
            text-align: center;
            margin: 16px 0;
            color: #ffff00;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .insights-banner:hover {
            background-color: #444400;
            border-color: #888800;
        }

        .insights-banner.collapsed {
            margin: 12px 0;
            padding: 12px;
            font-size: 12px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .stats-grid.expanded {
            max-height: 400px;
        }

        .stat-box {
            background-color: #2a2a2a;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .stat-title {
            color: #ffaa00;
            font-size: 11px;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 10px;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #fff;
            font-weight: 500;
        }

        .percentage {
            color: #00ff00;
            font-weight: 600;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .dashboard-grid.expanded {
            max-height: 400px;
        }

        .dashboard-item {
            background-color: #2a2a2a;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #333;
            position: relative;
            transition: all 0.2s ease;
        }

        .dashboard-item.active {
            border-color: #ffaa00;
            background-color: #332200;
        }

        .dashboard-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        .dashboard-title {
            font-size: 10px;
            margin-bottom: 4px;
            font-weight: 600;
            color: #fff;
        }

        .dashboard-subtitle {
            color: #666;
            font-size: 9px;
            line-height: 1.3;
        }

        .dashboard-item.active .dashboard-subtitle {
            color: #ffaa00;
        }

        .dashboard-status {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #666;
        }

        .dashboard-status.status-active {
            background: #00ff00;
            box-shadow: 0 0 4px rgba(0, 255, 0, 0.5);
        }

        .dashboard-status.status-inactive {
            background: #666;
        }

        .dashboard-status.status-paused {
            background: #ffaa00;
            box-shadow: 0 0 4px rgba(255, 170, 0, 0.5);
        }
    </style>
</head>
<body>
    <!-- Activation Container (completely outside the popup) -->
    <div class="activation-container" id="activation-circle" onclick="activateExtension()">
        <div class="activation-circle"></div>
        <div class="activation-text">Activate Extension</div>
    </div>

    <!-- Debug Trigger -->
    <div class="debug-trigger" onclick="toggleDebugPanel()" title="Debug Panel (Ctrl+Shift+D)">
        Debug
    </div>

    <!-- Debug Panel -->
    <div class="debug-panel" id="debug-panel">
        <div class="debug-panel-header" onclick="toggleDebugPanel()">
            <span>Rumi Debug</span>
            <button class="debug-panel-toggle" id="debug-panel-toggle">▼</button>
        </div>
        
        <div class="debug-panel-content" id="debug-panel-content">
            <!-- Basic Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('basic-testing')">
                    <span>Basic Testing</span>
                    <button class="debug-section-toggle" id="basic-testing-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="basic-testing-content">
        <button class="debug-button" onclick="Tracker.showDebugOverlay()">Show Tracker</button>
        <!-- <button class="debug-button" onclick="testHomeScreen()">Test Home</button> -->
        <!-- <button class="debug-button" onclick="testChannels()">Test Channels</button> -->
        <!-- <button class="debug-button" onclick="testReceipt()">Test Receipt</button> -->
        <button class="debug-button" onclick="showState()">Show State</button>
        <!-- <button class="debug-button info" onclick="testShowDetection()">Test Show Detection</button> -->
        <!-- <button class="debug-button info" onclick="debugChannelState()">Debug Channel State</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelContent()">Check Genre Channel</button> -->
        <!-- <button class="debug-button info" onclick="testPlanetEarthDetection()">Test Planet Earth II</button> -->
        <!-- <button class="debug-button info" onclick="testMessagePassing()">Test Message Passing</button> -->
        <!-- <button class="debug-button info" onclick="checkGenreChannelLoaded()">Check Channel Loaded</button> -->
                </div>
            </div>

            <!-- Error Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('error-testing')">
                    <span>Error Testing</span>
                    <button class="debug-section-toggle" id="error-testing-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="error-testing-content">
                    <button class="debug-button warning" onclick="testVolumeError()">Volume Error</button>
                    <button class="debug-button warning" onclick="testSpeedError()">Speed Error</button>
                    <button class="debug-button warning" onclick="testLanguageError()">Language Error</button>
                    <button class="debug-button error" onclick="testSystemError()">System Error</button>
                    <button class="debug-button error" onclick="testNetworkError()">Network Error</button>
                    <button class="debug-button error" onclick="testBrowserError()">Browser Error</button>
                    <button class="debug-button blue" onclick="testShowInterrupt()">Show Interrupt</button>
                </div>
            </div>

            <!-- Session Management Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('session-management')">
                    <span>Session Management</span>
                    <button class="debug-section-toggle" id="session-management-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="session-management-content">
                    <!-- Time Skip Buttons -->
                    <button class="debug-button warning" onclick="debugSkipTime(30)">Skip 30 min</button>
                    <button class="debug-button warning" onclick="debugSkipTime(15)">Skip 15 min</button>
                    <button class="debug-button warning" onclick="debugSkipTime(10)">Skip 10 min</button>
                    <button class="debug-button warning" onclick="debugSkipTime(5)">Skip 5 min</button>
                    <button class="debug-button warning" onclick="debugSkipTime(1)">Skip 1 min</button>
                    
                    <!-- Other Debug Functions -->
                    <button class="debug-button info" id="debug-content-tracking-btn" onclick="debugContentTracking()">Debug Content Tracking</button>
                    <button class="debug-button info" id="debug-skip-tomorrow-btn" onclick="debugSkipToTomorrow()">Skip to Tomorrow</button>
                    <button class="debug-button warning" onclick="testEndOfContentReceipt()">Test End-of-Content Receipt</button>
                    <button class="debug-button warning" onclick="debugShowDetectionState()">Debug Show Detection</button>
                    <button class="debug-button warning" onclick="debugChannelContent()">Debug Channel Content</button>
                    <button class="debug-button danger" onclick="debugResetShowDetection()">Reset Show Detection</button>
                </div>
            </div>

            <!-- Vertical Breakpoint Testing Section -->
            <div class="debug-section">
                <div class="debug-section-header" onclick="toggleDebugSection('vertical-breakpoints')">
                    <span>Vertical Breakpoints</span>
                    <button class="debug-section-toggle" id="vertical-breakpoints-toggle">▼</button>
                </div>
                <div class="debug-section-content" id="vertical-breakpoints-content">
                    <div style="font-size: 8px; color: #666; margin-bottom: 6px; text-align: center;">
                        Current: <span id="current-viewport-height">--</span>px | 
                        Breakpoint: <span id="current-breakpoint">--</span>
                    </div>
                    <button class="debug-button info" onclick="setViewportHeight(400)">📱 Very Short (400px)</button>
                    <button class="debug-button info" onclick="setViewportHeight(600)">📱 Short (600px)</button>
                    <button class="debug-button" onclick="setViewportHeight(800)">💻 Standard (800px)</button>
                    <button class="debug-button info" onclick="setViewportHeight(1100)">🖥️ Tall (1100px)</button>
                    <button class="debug-button warning" onclick="resetViewportHeight()">🔄 Reset to Natural</button>
                    <button class="debug-button blue" onclick="testAllBreakpoints()">🧪 Test All Breakpoints</button>
                </div>
            </div>
        </div>
    </div>

    <div class="simulation-container">
        <div class="entry-point-panel">
            <div class="entry-point-header">SIMULATED ENTRY POINTS</div>

            <!-- Integrated Detection Mode Section -->
            <div style="background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">🎯 STREAM DETECTED</div>
                <select id="detection-mode-dropdown" style="width: 100%; margin-bottom: 10px; padding: 6px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.2); background: rgba(0,0,0,0.1); color: #000; font-size: 11px;">
                    <option value="">Select Show/Movie...</option>
                </select>
                <button id="stream-detected-button" class="primary-cta disabled" onclick="launchWithDetection()" style="width: 100%; background: rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.2); color: #666; padding: 8px; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: not-allowed;" disabled>
                    Select Show to Launch
                </button>
            </div>
            <!-- Integrated Automode Section -->
            <div style="background: linear-gradient(135deg, #6b46c1, #553c9a); color: #fff; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">🤖 AUTOMODE CAMPAIGN</div>
                <select id="automode-dropdown" style="width: 100%; margin-bottom: 10px; padding: 6px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: #fff; font-size: 11px;">
                    <option value="">Select Intelligence Bucket...</option>
                </select>
                <button id="automode-button" class="automode-button disabled" onclick="launchWithAutomode()" style="width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #666; padding: 8px; border-radius: 4px; font-size: 11px; font-weight: 600; cursor: not-allowed;" disabled>
                    Select Intelligence Bucket to Launch
                </button>
                <button id="start-learning-button" class="primary-cta automode" onclick="startAutomodeIndexing()" style="width: 100%; margin-top: 8px; background: #ffff00; color: #000; border: 2px solid #ffff00; padding: 10px; border-radius: 4px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; display: none;">
                    START LEARNING CONTENT INTELLIGENCE
                </button>
                <div id="automode-description" style="display: none; margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; font-size: 10px; color: #ccc; line-height: 1.3;">
                    <div style="font-weight: 600; color: #ffff00; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">LEARNING FOCUS</div>
                    <div id="automode-description-text">Select a bucket to see what you'll be learning...</div>
                </div>
            </div>
            <button id="user-changes-content-btn" class="secondary-button" onclick="simulateShowChange()" style="display: none; margin-top: 10px;">
                User Changes Content
            </button>

    </div>

        <!-- Extension Popup (centered, always one header at top) -->
    <div class="extension-popup" style="display: none;">
        <div class="popup-header">
            <div class="popup-logo">RUMI</div>
            <div class="header-controls">
                <button class="settings-button" onclick="testSettings()">⚙ SETTINGS</button>
            </div>
        </div>
        <!-- Receipt View (Initially Hidden) -->
        <div id="receipt-view" style="display: none;">
            <div class="popup-body">
                <div style="background: #0d0d0d; border: 1px solid #333; border-radius: 12px; padding: 20px; max-width: 520px; margin: 0 auto; box-sizing: border-box; width: 100%;">
                    <div style="text-align: center; margin-bottom: 12px;">
                        <div style="font-size: 14px; color: #888; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span>SESSION COMPLETED for</span>
                            <span style="font-size: 24px; font-weight: 700; color: #ffff00;" id="receipt-total-points">+0.00</span>
                            <span>POINTS</span>
                        </div>
                        <div style="font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; gap: 8px;">
                            <span id="receipt-total-pending" style="font-size: 13px; color: #ffaa00; font-weight: 600;"></span>
                            <span>PENDING FROM TODAY</span>
            </div>
        </div>

                        <!-- Session Details -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">SESSION DETAILS</div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Duration:</span>
                                <span style="color: #fff;" id="receipt-duration">0:00</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Multiplier:</span>
                                <span style="color: #fff;" id="receipt-multiplier">1.0x</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px;">
                                <span style="color: #888;">Base Rate:</span>
                                <span style="color: #fff;">0.5 pts/5s</span>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; font-size: 11px;">
                                <span style="color: #888;">Bonus Applied:</span>
                                <span style="color: #ffaa00;" id="receipt-bonus">None</span>
                            </div>
                        </div>

                        <!-- Indexed Content Summary -->
                        <div style="background: #111; border: 1px solid #333; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">INDEXED CONTENT</div>
                            
                            <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Content detected and processed during this session:</div>
                            
                            <div id="receipt-content-list" style="font-size: 10px; max-height: 120px; overflow-y: auto;">
                                <!-- --- Indexed Content View: Show actual indexed content with 3 visible lines and auto-scroll (ping-pong) ---
                                if (appState.indexedContent && appState.indexedContent.length > 0) {
                                    const indexed = appState.indexedContent;
                                    // Generate HTML for all items
                                    const contentHTML = indexed.map(item => `
                                        <div class="indexed-content-item" style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: #1a1a1a; border-radius: 3px; height: 24px; align-items: center;">
                                            <span style="color: #fff;">${item.title}</span>
                                            <span style="color: #888;">${item.duration}m</span>
                                </div>
                                    `).join('');
                                    contentList.innerHTML = `<div id="indexed-content-scroll" style="overflow: hidden; height: 76px; position: relative;">${contentHTML}</div>`;
                                    // Animate auto-scroll if more than 3 items
                                    if (indexed.length > 3) {
                                        setTimeout(() => {
                                            const scrollDiv = document.getElementById('indexed-content-scroll');
                                            let scrollPos = 0;
                                            let direction = 1;
                                            const itemHeight = 28; // px (24px + 4px margin)
                                            const maxScroll = (indexed.length * itemHeight) - (3 * itemHeight);
                                            function scrollStep() {
                                                scrollPos += direction;
                                                if (scrollPos >= maxScroll) {
                                                    scrollPos = maxScroll;
                                                    direction = -1;
                                                } else if (scrollPos <= 0) {
                                                    scrollPos = 0;
                                                    direction = 1;
                                                }
                                                scrollDiv.scrollTop = scrollPos;
                                                requestAnimationFrame(scrollStep);
                                            }
                                            scrollStep();
                                        }, 500);
                                    }
                                    // Return early so the rest of the function doesn't overwrite this view
                                    return;
                                } -->
                            </div>
                        </div>

                        <!-- Next Steps -->
                        <div style="background: #1a1000; border: 1px solid #ffaa00; border-radius: 6px; padding: 12px; margin-bottom: 20px;">
                            <div style="font-size: 12px; color: #ffaa00; font-weight: 600; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px;">NEXT STEPS</div>
                            <div style="font-size: 11px; color: #ccc; line-height: 1.4;">
                                Your points are now pending validation. They will be added to your total balance within 24 hours. Continue indexing to earn more points!
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 8px; margin-top: 16px;">
                            <button class="primary-cta" onclick="returnToEntryPoint()" style="flex: 1; background: #222; color: #ffff00; border: 2px solid #ffff00;">
                                DONE
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main View -->
        <div id="main-view">
            <!-- Message Area -->
            <div class="message-area collapsed">
                    <span id="message-summary-text">System operational - Daily bonus in 2h 34m</span>
                    <div id="error-details"></div>
                    <!-- Expandable Error Details Section -->
                    <div class="expandable-section" id="error-details-section">
                        <div class="expandable-content">
                            <div class="expandable-title">ERROR DETAILS</div>
                            <div id="error-details-content">
                                <!-- Error details will be populated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Expandable Warning Details Section -->
                    <div class="expandable-section" id="warning-details-section">
                        <div class="expandable-content" id="warning-details-content">
                            <!-- Warning details will be populated here -->
                        </div>
                    </div>
                    <!-- Expandable Settings Panel Section -->
                    <div class="expandable-section" id="settings-panel-section">
                        <div class="expandable-content">
                            <div class="expandable-title">SETTINGS CONFIGURATION</div>
                            <div id="settings-panel-content">
                                <!-- Settings content will be populated here -->
                            </div>
                        </div>
                    </div>
            </div>

            <!-- Points Section -->
            <div class="points-section">
                <div style="text-align: center; margin-bottom: 12px;">
                        <div id="points-primary-display" class="points-total">4349 LIFETIME POINTS</div>
                        <div id="points-secondary-display" class="points-pending">+200 pending from today</div>
                </div>
                
                <!-- Dynamic Content: Changes based on indexing state -->
                <div id="dynamic-content">
                        <!-- NEW HOME CONTENT (replaces channel iframe) -->
                        <div id="home-content">
                            <!-- Compact, Expandable Leaderboard -->
                            <div id="leaderboard-section" class="leaderboard-section" onclick="toggleLeaderboard()">
                                <div class="leaderboard-header">
                                    <div>
                                        <span class="title">WEEKLY LEADERS</span>
                                        <span class="user-rank">🔥 YOU: #23</span>
                        </div>
                                    <span class="leaderboard-expand-icon">▼</span>
                                </div>
                                <div class="leaderboard-full-list">
                                    <!-- Full leaderboard content from before -->
                                <div style="font-size: 9px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: #ffaa00;">🥇 CRYPTO_MAVEN</span>
                                        <span style="color: #ffaa00;">12,847</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: #888;">🥈 BINGE_LORD</span>
                                        <span style="color: #888;">11,203 (proj.)</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                        <span style="color: #888;">🥉 STORY_HUNTER</span>
                                        <span style="color: #888;">9,876</span>
                                    </div>
                                    <div style="border-top: 1px solid #333; padding-top: 3px;">
                                        <div style="display: flex; justify-content: space-between; background: rgba(0,255,65,0.1); padding: 2px 4px; border: 1px solid #00ff41;">
                                            <span style="color: #00ff41; font-weight: 600;">🔥 YOU (#23)</span>
                                            <span style="color: #00ff41;">4,349 (4,549 proj.)</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                            <!-- Detected Show UI -->
                            <div id="detected-show-ui" style="display: none; margin-top: 12px; background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; border: 1px solid #00ff41;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">🎯 SHOW DETECTED</div>
                                        <div id="detected-show-title" style="font-size: 11px; font-weight: 600;">Loading...</div>
                                        <div id="detected-show-meta" style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">Processing...</div>
                                </div>
                                    <button onclick="dismissDetectedShow()" style="background: none; border: none; color: #000; font-size: 16px; cursor: pointer; padding: 4px; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">×</button>
                                        </div>
                                        </div>

                            <!-- CTA Button positioned above channel -->
                            <div style="margin-top: 12px;">
                                <button id="cta-button" class="primary-cta" onclick="toggleIndexing()">
                                    START WATCHING
                                </button>
                                    
                                    <!-- Expandable Channel Section -->
                                    <div id="expandable-channel-section" style="margin-top: 12px; display: none;">
                                        <div id="expand-channel-header" onclick="toggleChannelExpansion()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                            <span id="expand-channel-text" style="flex: none;">WATCH YOUR NEXT SHOW WITH US</span>
                                            <span id="expand-channel-icon" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                        </div>
                                        <!-- Channel Container (initially hidden) -->
                                        <div id="channel-expanded-container" style="display: none; margin-top: 4px;">
                                            <div id="channel-iframe-container" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                                <div id="channel-loading" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Channel...</div>
                                <iframe id="channel-frame" src="genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onload="console.log('Home channel frame loaded:', this.src); resizeIframe(this); initializeChannelTitle();" onerror="showChannelError()"></iframe>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            
                            <!-- Real-time Learning Insights Section (Section 2b) -->
                            <div id="realtime-learning-insights" style="margin-top: 12px; display: none;">
                                <div class="insights-banner collapsed" onclick="toggleLearningInsights()">
                                    <span>📊</span>
                                    <span>Real-time Learning Insights</span>
                                    <span id="insights-expand-icon">▼</span>
                                </div>
                                
                                <div class="stats-grid" id="insights-stats-grid">
                                    <div class="stat-box">
                                        <div class="stat-title">Content Analysis</div>
                                        <div class="stat-item">
                                            <span class="stat-label">Patterns detected:</span>
                                            <span class="stat-value" id="patterns-detected">127</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Genres identified:</span>
                                            <span class="stat-value" id="genres-identified">8</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Accuracy improving:</span>
                                            <span class="percentage" id="accuracy-improving">+12%</span>
                                        </div>
                                    </div>
                                    
                                    <div class="stat-box">
                                        <div class="stat-title">Learning Progress</div>
                                        <div class="stat-item">
                                            <span class="stat-label">Neural connections:</span>
                                            <span class="stat-value" id="neural-connections">2,847</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Training samples:</span>
                                            <span class="stat-value" id="training-samples">1,203</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Model confidence:</span>
                                            <span class="percentage" id="model-confidence">87.3%</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            </div>
                    </div>

                    <!-- Top Section: Points and Progress (shown when indexing) -->
                    <div id="nokia-content" class="nokia-section" style="display: none; position: relative;">
                        <!-- Pause indicator -->
                        <div class="pause-indicator">⏸️ INDEXING PAUSED</div>
                        
                        <!-- NEW: Holistic Indexing Panel -->
                        <div id="holistic-indexing-panel" class="holistic-panel">
                            <div id="holistic-show-info" class="holistic-section"></div>
                            <div id="holistic-animation" class="holistic-section">
                            <pre id="animation-panel-content"></pre>
                        </div>
                            <div id="holistic-progress" class="holistic-section"></div>
                        </div>

                        <!-- STOP INDEXING Button positioned between holistic panel and channel -->
                        <div style="margin-top: 16px;">
                            <button id="stop-indexing-button" class="primary-cta" onclick="toggleIndexing()">
                                START INDEXING
                            </button>
                            <!-- Subtitle removed -->
                        </div>

                        <!-- Channel Section (replaces now-playing) -->
                        <div style="margin-top: 16px;">
                            <!-- Detected Show UI for Indexing View -->
                            <div id="detected-show-ui-indexing" style="display: none; margin-bottom: 12px; background: linear-gradient(135deg, #00ff41, #00cc33); color: #000; padding: 12px; border-radius: 6px; border: 1px solid #00ff41;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px;">🎯 SHOW DETECTED</div>
                                        <div id="detected-show-title-indexing" style="font-size: 11px; font-weight: 600;">Loading...</div>
                                        <div id="detected-show-meta-indexing" style="font-size: 9px; opacity: 0.8; text-transform: uppercase; letter-spacing: 0.5px;">Processing...</div>
                                    </div>
                                    <button onclick="dismissDetectedShowIndexing()" style="background: none; border: none; color: #000; font-size: 16px; cursor: pointer; padding: 4px; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'">×</button>
                                </div>
                            </div>
                                
                                <!-- Expandable Channel Section for Indexing View -->
                                <div id="expandable-channel-section-indexing" style="margin-top: 12px; display: none;">
                                    <div id="expand-channel-header-indexing" onclick="toggleChannelExpansionIndexing()" style="display: flex; align-items: center; justify-content: center; background: #222; color: #bbb; border-radius: 6px; padding: 12px 16px; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 8px; user-select: none; transition: background 0.2s; text-align: center;">
                                        <span id="expand-channel-text-indexing" style="flex: none;">WATCH YOUR NEXT SHOW WITH US</span>
                                        <span id="expand-channel-icon-indexing" style="font-size: 16px; margin-left: 10px; flex: none;">▼</span>
                                    </div>
                                    <!-- Channel Container (initially hidden) -->
                                    <div id="channel-expanded-container-indexing" style="display: none; margin-top: 4px;">
                                        <div id="channel-iframe-container-indexing" style="background: transparent; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative;">
                                            <div id="channel-loading-indexing" style="padding: 20px; text-align: center; color: #00ff41; font-size: 12px; z-index: 1; display: none;">Loading Channel...</div>
                                            <iframe id="channel-frame-indexing" src="genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected" style="width: 100%; border: none; background: transparent; display: block; visibility: hidden; height: 320px;" onload="console.log('Indexing channel frame loaded:', this.src); resizeIframeIndexing(this); initializeChannelTitleIndexing();" onerror="showChannelErrorIndexing()"></iframe>
                                        </div>
                                    </div>
                        </div>
                        
                        <!-- Learning Progress Dashboard Section (Section 3b) -->
                        <div id="learning-progress-dashboard" style="margin-top: 12px; display: none;">
                            <div class="insights-banner collapsed" onclick="toggleProgressDashboard()">
                                <span>📊</span>
                                <span>Learning Progress Dashboard</span>
                                <span id="dashboard-expand-icon">▼</span>
                    </div>
                            
                            <div class="dashboard-grid" id="progress-dashboard-grid">
                                <div class="dashboard-item" id="pattern-recognition-item">
                                    <div class="dashboard-status status-inactive" id="pattern-recognition-status"></div>
                                    <div class="dashboard-title">
                                        <span class="dashboard-icon">↙</span>
                                        Pattern Recognition
                </div>
                                    <div class="dashboard-subtitle">Learning content patterns</div>
                                    <div class="dashboard-subtitle" id="pattern-recognition-state">Queued</div>
            </div>
                                
                                <div class="dashboard-item" id="classification-item">
                                    <div class="dashboard-status status-inactive" id="classification-status"></div>
                                    <div class="dashboard-title">
                                        <span class="dashboard-icon">🧩</span>
                                        Classification
                                    </div>
                                    <div class="dashboard-subtitle">Genre & content analysis</div>
                                    <div class="dashboard-subtitle" id="classification-state">Queued</div>
                                </div>
                                
                                <div class="dashboard-item" id="behavior-analysis-item">
                                    <div class="dashboard-status status-inactive" id="behavior-analysis-status"></div>
                                    <div class="dashboard-title">
                                        <span class="dashboard-icon">📊</span>
                                        Behavior Analysis
                                    </div>
                                    <div class="dashboard-subtitle">User preference learning</div>
                                    <div class="dashboard-subtitle" id="behavior-analysis-state">Queued</div>
                                </div>
                                
                                <div class="dashboard-item" id="optimization-item">
                                    <div class="dashboard-status status-inactive" id="optimization-status"></div>
                                    <div class="dashboard-title">
                                        <span class="dashboard-icon">🔍</span>
                                        Optimization
                                    </div>
                                    <div class="dashboard-subtitle">Algorithm refinement</div>
                                    <div class="dashboard-subtitle" id="optimization-state">Queued</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>

        <!-- Settings View (Initially Hidden) -->
        <div id="settings-view" style="display: none;">
            <div class="popup-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="font-size: 16px;">SETTINGS</h2>
                </div>
                
                <!-- Account Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Account</h3>
                    <div class="settings-item">
                        <span class="settings-label">Username</span>
                        <span class="settings-value">CRYPTO_MAVEN</span>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Member Since</span>
                        <span class="settings-value">Dec 2023</span>
                    </div>
                    <button class="settings-logout-button">LOGOUT</button>
                </div>

                <!-- Preferences Section -->
                <div class="settings-section">
                    <h3 class="settings-section-header">Preferences</h3>
                    <div class="settings-item">
                        <span class="settings-label">Desktop Notifications</span>
                        <label class="switch">
                            <input type="checkbox" checked>
                            <span class="slider round"></span>
                        </label>
                    </div>
                    <div class="settings-item">
                        <span class="settings-label">Auto-start Indexing</span>
                        <label class="switch">
                            <input type="checkbox">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Error State Views -->
        <!-- (Removed: error-state panels are now handled in the message area) -->
    </div>


    <!-- Scripts -->
    <script src="tracker.js"></script>
    <!-- Optional: Transition System Enhancement (can be disabled) -->
    <script src="transition-system.js"></script>
    <script>
        // Debug: Check if tracker loaded
        console.log('Tracker loaded:', typeof Tracker !== 'undefined');
        console.log('RUMI_PROJECT loaded:', typeof RUMI_PROJECT !== 'undefined');

        // App State
        const appState = {
            pendingShowForGenreChannel: null, // Corrected syntax
            pendingEntryPoint: null, // NEW: Store pending entry point for activation
            pendingDetectedShow: null, // NEW: Store pending detected show for activation
            view: 'home',
            pointsEarned: 4349,
            totalPendingPoints: 200,
            sessionEarnings: 0,
            currentMultiplier: 1.0,
            currentContent: null,
            isIndexing: false,
            indexingStartTime: null,
            sortMode: 'points', // 'points' or 'channel'
            currentBucket: 'Rumi Internal Audiences', // NEW: To store the selected bucket
            // Error States
            errorState: null, // null, 'volume', 'connection', 'loading', 'offline'
            volumeLevel: 100,
            connectionStatus: 'connected', // 'connected', 'lost', 'offline'
            isLoading: false,
            // NEW: Automode content tracking
            automodeContentItems: [], // Array of content items for current session
            currentContentIndex: 0, // Index of current content item
            contentItemStartTime: 0, // When current content item started
            contentItemDuration: 0, // Duration of current content item in seconds
            contentTransitionProgress: 0, // Smooth transition between content items
            channelExpanded: false, // Add to appState
            userInitiatedChannelChange: false, // Track if channel change was user-initiated
            simResolved: false, // Prevents error re-trigger after SIM RESOLVE
            // NEW: Pause state tracking
            isPaused: false, // Whether indexing is currently paused
            pauseStartTime: null, // When the pause started
            pauseDuration: 0, // Total time paused in this session
            sessionEndReason: null, // 'normal', 'fatal_error', 'user_stop'
            // NEW: Debug button cooldowns
            debugSkipCooldown: 0, // Cooldown timer for skip to end button
            debugTomorrowCooldown: 0, // Cooldown timer for skip to tomorrow button
            // NEW: Session management
            userChoice: null, // 'rumi' or 'streamer' - user's choice for content control
            showChoicePrompt: false, // Whether to show the choice prompt
            sessionCompleted: false, // Whether the current session has been completed
            indexedContent: [], // Array to track actual content indexed during this session
            // NEW: Content tracking to prevent duplicates
            playedContent: new Set(), // Set of content IDs that have been played
            channelContent: new Map(), // Map of channel name -> Set of content IDs in that channel
            globalContentQueue: [], // Global queue across all channels
            contentHistory: [], // Array of recently played content for recommendations
            cachedSessionDuration: null, // Cache for session duration
            cachedSessionDurationTimestamp: null, // Timestamp for cache expiration
            showInterruptTimestamp: null, // Timestamp when show interrupt occurred
            // NEW: Block progression tracking
            currentBlockIndex: 0, // Current block being processed (0-based)
            totalBlocks: 0, // Total blocks in current content
            firstBlockCompleted: false, // Track if first block has completed
            watchWithUsPromptShown: false, // Track if watch with us prompt has been shown
            pausedForWatchWithUs: false, // Track if paused for watch with us decision
            watchWithUsModalTimeout: null, // Timeout ID for auto-dismissing watch with us modal
        };

        // NEW: Unified Time Synchronization System
        const UnifiedTimeSync = {
            // Master timing state
            masterElapsedTime: 0,
            lastSyncTimestamp: 0,
            syncInterval: null,
            
            // Initialize unified timing
            initialize() {
                this.masterElapsedTime = 0;
                this.lastSyncTimestamp = Date.now();
                this.startSyncLoop();
                console.log('🎯 UnifiedTimeSync: Initialized master timing system');
            },
            
            // Start the synchronization loop
            startSyncLoop() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                }
                
                this.syncInterval = setInterval(() => {
                    this.updateMasterTime();
                    this.synchronizeAllSystems();
                }, 100); // Update every 100ms for smooth synchronization
            },
            
            // Update master elapsed time
            updateMasterTime() {
                if (!appState.indexingStartTime) return;
                
                const now = Date.now();
                const rawElapsedTime = (now - appState.indexingStartTime) / 1000;
                
                // Apply fast mode acceleration if active
                if (appState.fastMode && appState.fastMode.active) {
                    if (appState.fastMode.mode === 'automode') {
                        // Auto mode: use raw elapsed time (acceleration handled by indexingStartTime adjustment)
                        this.masterElapsedTime = rawElapsedTime;
                    } else if (appState.fastMode.mode === 'detection') {
                        // Detection mode: calculate accelerated time
                        if (appState.fastMode.isInFinalSeconds) {
                            this.masterElapsedTime = rawElapsedTime;
                        } else {
                            const contentIndex = appState.fastMode.currentContentIndex || 0;
                            const averageContentDuration = 45 * 60; // 45 minutes in seconds
                            const timeFromFastSkipping = contentIndex * averageContentDuration;
                            this.masterElapsedTime = rawElapsedTime + timeFromFastSkipping;
                        }
                    }
                } else {
                    this.masterElapsedTime = rawElapsedTime;
                }
                
                this.lastSyncTimestamp = now;
            },
            
            // Synchronize all timing systems
            synchronizeAllSystems() {
                if (!appState.isIndexing) return;
                
                const elapsedTime = this.masterElapsedTime;
                
                // 1. Synchronize content progression
                this.synchronizeContentProgression(elapsedTime);
                
                // 2. Synchronize block progression
                this.synchronizeBlockProgression(elapsedTime);
                
                // 3. Synchronize multiplier
                this.synchronizeMultiplier(elapsedTime);
                
                // 4. Check for session completion
                this.checkSessionCompletion(elapsedTime);
            },
            
            // Synchronize content progression
            synchronizeContentProgression(elapsedTime) {
                if (appState.entryPoint === 'automode' && appState.automodeContentItems) {
                    let cumulativeTime = 0;
                    let expectedContentIndex = 0;
                    
                    // Calculate which content item we should be on
                    for (let i = 0; i < appState.automodeContentItems.length; i++) {
                        const item = appState.automodeContentItems[i];
                        const duration = this.parseContentDuration(item);
                        
                        if (elapsedTime >= cumulativeTime + duration) {
                            cumulativeTime += duration;
                            expectedContentIndex = i + 1;
                        } else {
                            break;
                        }
                    }
                    
                    // Update content index if changed
                    if (expectedContentIndex !== appState.currentContentIndex && expectedContentIndex < appState.automodeContentItems.length) {
                        console.log(`🎯 UnifiedTimeSync: Content progression ${appState.currentContentIndex} → ${expectedContentIndex}`);
                        appState.currentContentIndex = expectedContentIndex;
                        appState.contentItemStartTime = cumulativeTime;
                        
                        const currentItem = appState.automodeContentItems[expectedContentIndex];
                        if (currentItem) {
                            appState.contentItemDuration = this.parseContentDuration(currentItem);
                        }
                    }
                }
            },
            
            // Synchronize block progression
            synchronizeBlockProgression(elapsedTime) {
                if (appState.totalBlocks > 0) {
                    const expectedBlockIndex = this.calculateExpectedBlockIndex(elapsedTime);
                    
                    if (expectedBlockIndex !== appState.currentBlockIndex && expectedBlockIndex < appState.totalBlocks) {
                        console.log(`🎯 UnifiedTimeSync: Block progression ${appState.currentBlockIndex} → ${expectedBlockIndex}`);
                        
                        // Check if we're advancing from first block (index 0) to second block (index 1)
                        const wasFirstBlock = appState.currentBlockIndex === 0;
                        
                        appState.currentBlockIndex = expectedBlockIndex;
                        updateBlockProgressionDisplay();
                        
                        // If we just completed the first block, trigger watch with us prompt
                        if (wasFirstBlock && expectedBlockIndex > 0 && !appState.firstBlockCompleted) {
                            appState.firstBlockCompleted = true;
                            console.log('🎯 UnifiedTimeSync: First block completed - triggering watch with us prompt');
                            
                            // Trigger watch with us prompt after a short delay
                            setTimeout(() => {
                                showWatchWithUsPrompt();
                            }, 1000); // 1 second delay to show completion
                        }
                    }
                }
            },
            
            // Synchronize multiplier
            synchronizeMultiplier(elapsedTime) {
                const sessionDuration = TimeSystem.getSessionDuration();
                const newMultiplier = this.calculateCurrentMultiplier(elapsedTime, sessionDuration);
                
                if (Math.abs(newMultiplier - appState.currentMultiplier) >= 0.01) {
                    console.log(`🎯 UnifiedTimeSync: Multiplier ${appState.currentMultiplier.toFixed(2)}x → ${newMultiplier.toFixed(2)}x`);
                    appState.currentMultiplier = newMultiplier;
                }
            },
            
            // Check session completion
            checkSessionCompletion(elapsedTime) {
                const sessionDuration = TimeSystem.getSessionDuration();
                
                if (elapsedTime >= sessionDuration && !appState.sessionCompleted) {
                    console.log('🎯 UnifiedTimeSync: Session duration reached - completing session');
                    appState.sessionCompleted = true;
                    handleSessionComplete();
                }
            },
            
            // Parse content duration from various formats
            parseContentDuration(item) {
                if (item.duration_seconds) {
                    return item.duration_seconds;
                } else if (typeof item.duration === 'string' && item.duration.includes(':')) {
                    const parts = item.duration.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                } else if (typeof item.duration === 'number') {
                    return item.duration;
                } else {
                    return 45 * 60; // Default 45 minutes
                }
            },
            
            // Calculate expected block index based on elapsed time
            calculateExpectedBlockIndex(elapsedTime) {
                if (appState.entryPoint === 'automode' && appState.automodeContentItems) {
                    let cumulativeTime = 0;
                    
                    for (let i = 0; i < appState.automodeContentItems.length; i++) {
                        const item = appState.automodeContentItems[i];
                        const duration = this.parseContentDuration(item);
                        
                        if (elapsedTime < cumulativeTime + duration) {
                            return i;
                        }
                        cumulativeTime += duration;
                    }
                    
                    return appState.automodeContentItems.length - 1;
                } else if (appState.entryPoint === 'detection') {
                    // For detection mode, use synchronized timeline if available
                    if (SynchronizedTimeline.isInitialized && SynchronizedTimeline.contentItems) {
                        let cumulativeTime = 0;
                        
                        for (let i = 0; i < SynchronizedTimeline.contentItems.length; i++) {
                            const item = SynchronizedTimeline.contentItems[i];
                            const duration = SynchronizedTimeline.parseContentDuration(item.duration);
                            
                            if (elapsedTime < cumulativeTime + duration) {
                                return i;
                            }
                            cumulativeTime += duration;
                        }
                        
                        return SynchronizedTimeline.contentItems.length - 1;
                    } else {
                        // Fallback: use session duration divided by total blocks
                        const sessionDuration = TimeSystem.getSessionDuration();
                        const progress = Math.min(elapsedTime / sessionDuration, 1.0);
                        return Math.floor(progress * appState.totalBlocks);
                    }
                } else {
                    // For other modes, use session duration estimation
                    const sessionDuration = TimeSystem.getSessionDuration();
                    const progress = Math.min(elapsedTime / sessionDuration, 1.0);
                    return Math.floor(progress * appState.totalBlocks);
                }
            },
            
            // Calculate current multiplier based on elapsed time
            calculateCurrentMultiplier(elapsedTime, sessionDuration) {
                const milestones = calculateDynamicMultiplierMilestones(sessionDuration);
                
                for (let i = milestones.length - 1; i >= 0; i--) {
                    const milestone = milestones[i];
                    const milestoneTimeSeconds = milestone.time * sessionDuration;
                    
                    if (elapsedTime >= milestoneTimeSeconds) {
                        return milestone.multiplier;
                    }
                }
                
                return 1.0; // Default multiplier
            },
            
            // Get current master elapsed time
            getMasterElapsedTime() {
                return this.masterElapsedTime;
            },
            
            // Stop synchronization
            stop() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
                console.log('🎯 UnifiedTimeSync: Stopped master timing system');
            }
        };

        // NEW: Synchronized Timeline System for accurate progress tracking
        const SynchronizedTimeline = {
            // Content timeline tracking
            contentItems: [],
            totalContentDuration: 0,
            currentContentIndex: 0,
            contentStartTimes: [],
            isInitialized: false,
            
            // Initialize timeline with content items
            initializeTimeline(contentItems) {
                console.log('🎯 SynchronizedTimeline: Initializing with', contentItems.length, 'items');
                
                this.contentItems = [...contentItems]; // Create copy
                this.currentContentIndex = 0;
                this.contentStartTimes = [];
                
                // Calculate cumulative start times and total duration
                let cumulativeTime = 0;
                this.contentStartTimes.push(0);
                
                for (let i = 0; i < contentItems.length; i++) {
                    const item = contentItems[i];
                    const duration = this.parseContentDuration(item.duration);
                    
                    cumulativeTime += duration;
                    if (i < contentItems.length - 1) {
                        this.contentStartTimes.push(cumulativeTime);
                    }
                }
                
                this.totalContentDuration = cumulativeTime;
                this.isInitialized = true;
                
                console.log('🎯 SynchronizedTimeline: Total duration:', this.totalContentDuration / 60, 'minutes');
                console.log('🎯 SynchronizedTimeline: Content start times:', this.contentStartTimes.map(t => (t/60).toFixed(1) + 'min'));
                
                // Update TimeSystem cache
                appState.cachedSessionDuration = this.totalContentDuration;
                appState.cachedSessionDurationTimestamp = Date.now();
                
                return this.totalContentDuration;
            },
            
            // Parse content duration from various formats
            parseContentDuration(duration) {
                if (typeof duration === 'string' && duration.includes(':')) {
                    const parts = duration.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                } else if (typeof duration === 'number') {
                    return duration;
                } else {
                    return 45 * 60; // Default 45 minutes
                }
            },
            
            // Get current content item based on elapsed time
            getCurrentContentItem(elapsedTime) {
                if (!this.isInitialized || this.contentItems.length === 0) {
                    return null;
                }
                
                // Find which content item we should be on based on elapsed time
                for (let i = this.contentStartTimes.length - 1; i >= 0; i--) {
                    if (elapsedTime >= this.contentStartTimes[i]) {
                        return {
                            index: i,
                            item: this.contentItems[i],
                            startTime: this.contentStartTimes[i],
                            duration: this.parseContentDuration(this.contentItems[i]?.duration),
                            timeInItem: elapsedTime - this.contentStartTimes[i]
                        };
                    }
                }
                
                // Default to first item
                return {
                    index: 0,
                    item: this.contentItems[0],
                    startTime: 0,
                    duration: this.parseContentDuration(this.contentItems[0]?.duration),
                    timeInItem: elapsedTime
                };
            },
            
            // Check if session should end based on content completion
            shouldSessionEnd(elapsedTime) {
                return this.isInitialized && elapsedTime >= this.totalContentDuration;
            },
            
            // Get progress based on actual content timeline
            getProgress(elapsedTime) {
                if (!this.isInitialized || this.totalContentDuration === 0) return 0;
                return Math.min(elapsedTime / this.totalContentDuration, 1);
            },
            
            // Synchronize current content index with elapsed time
            synchronizeContentIndex(elapsedTime) {
                if (!this.isInitialized) return false;
                
                const currentContent = this.getCurrentContentItem(elapsedTime);
                if (!currentContent) return false;
                
                if (currentContent.index !== this.currentContentIndex) {
                    console.log(`🎯 SynchronizedTimeline: Content transition ${this.currentContentIndex} → ${currentContent.index}`);
                    console.log(`🎯 SynchronizedTimeline: Now playing: ${currentContent.item?.title}`);
                    
                    this.currentContentIndex = currentContent.index;
                    
                    // Update app state to match
                    appState.currentContentIndex = currentContent.index;
                    appState.contentItemStartTime = currentContent.startTime;
                    appState.contentItemDuration = currentContent.duration;
                    
                    return true; // Content changed
                }
                
                return false; // No change
            },
            
            // Add content item (for show transitions)
            addContentItem(newItem) {
                console.log('🎯 SynchronizedTimeline: Adding content item:', newItem.title);
                
                const duration = this.parseContentDuration(newItem.duration);
                
                // Add to content items
                this.contentItems.push(newItem);
                
                // Update start times
                this.contentStartTimes.push(this.totalContentDuration);
                
                // Update total duration
                this.totalContentDuration += duration;
                
                console.log('🎯 SynchronizedTimeline: New total duration:', this.totalContentDuration / 60, 'minutes');
                
                // Update cached session duration
                appState.cachedSessionDuration = this.totalContentDuration;
                appState.cachedSessionDurationTimestamp = Date.now();
                
                return this.totalContentDuration;
            },
            
            // Reset timeline
            reset() {
                this.contentItems = [];
                this.totalContentDuration = 0;
                this.currentContentIndex = 0;
                this.contentStartTimes = [];
                this.isInitialized = false;
                console.log('🎯 SynchronizedTimeline: Reset');
            }
        };

        // UPDATED: CENTRALIZED TIME SYSTEM with SynchronizedTimeline integration
        const TimeSystem = {
            // Central time source - now uses UnifiedTimeSync
            getElapsedTime() {
                if (!appState.indexingStartTime) return 0;
                
                // Use unified time sync if available
                if (UnifiedTimeSync.syncInterval) {
                    return UnifiedTimeSync.getMasterElapsedTime();
                }
                
                // Fallback to original calculation
                let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Handle fast mode time calculation
                if (appState.fastMode && appState.fastMode.active) {
                    if (appState.fastMode.mode === 'automode') {
                        // Auto mode: time is already accelerated via indexingStartTime adjustment
                        elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    } else if (appState.fastMode.mode === 'detection') {
                        // Detection mode: calculate accelerated time based on content navigation
                        const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        
                        if (appState.fastMode.isInFinalSeconds) {
                            elapsedTime = baseElapsedTime;
                        } else {
                            // When skipping through content, show accelerated time
                            const contentIndex = appState.fastMode.currentContentIndex || 0;
                            const averageContentDuration = 45 * 60; // 45 minutes in seconds
                            const timeFromFastSkipping = contentIndex * averageContentDuration;
                            elapsedTime = baseElapsedTime + timeFromFastSkipping;
                        }
                    }
                }
                
                return elapsedTime;
            },
            
            // Central session duration calculation - now uses SynchronizedTimeline
            getSessionDuration() {
                // If synchronized timeline is initialized, use its duration
                if (SynchronizedTimeline.isInitialized && SynchronizedTimeline.totalContentDuration > 0) {
                    return SynchronizedTimeline.totalContentDuration;
                }
                
                // Use cached value if recent (within 5 seconds)
                if (appState.cachedSessionDuration && 
                    appState.cachedSessionDurationTimestamp && 
                    (Date.now() - appState.cachedSessionDurationTimestamp) < 5000) {
                    return appState.cachedSessionDuration;
                }
                
                let sessionDuration;
                
                if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    // Calculate total duration from automode content
                    sessionDuration = appState.automodeContentItems.reduce((total, item) => {
                        if (typeof item.duration === 'string' && item.duration.includes(':')) {
                            const durationParts = item.duration.split(':');
                            return total + (parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]));
                        }
                        // Use actual duration from CSV (should be in seconds)
                        return total + (item.duration_seconds || item.duration || 45 * 60);
                    }, 0);
                    
                    console.log(`🎯 TimeSystem: Calculated automode session duration: ${sessionDuration / 60} minutes from ${appState.automodeContentItems.length} items`);
                } else if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Calculate duration from detected show content
                    sessionDuration = getShowDetectionContent(appState.detectedShow, null).reduce((total, item) => {
                        return total + (item.duration || 45 * 60);
                    }, 0);
                } else {
                    sessionDuration = 30 * 60; // Fallback to 30 minutes
                }
                
                // Cache the result
                appState.cachedSessionDuration = sessionDuration;
                appState.cachedSessionDurationTimestamp = Date.now();
                
                return sessionDuration;
            },
            
            // Central progress calculation - now uses SynchronizedTimeline
            getProgress() {
                const elapsedTime = this.getElapsedTime();
                
                // Use synchronized timeline if available
                if (SynchronizedTimeline.isInitialized) {
                    return SynchronizedTimeline.getProgress(elapsedTime);
                }
                
                // Fallback to original calculation
                const sessionDuration = this.getSessionDuration();
                return Math.min(elapsedTime / sessionDuration, 1);
            },
            
            // Check if session should end - now uses SynchronizedTimeline
            shouldSessionEnd() {
                const elapsedTime = this.getElapsedTime();
                
                // Use synchronized timeline if available
                if (SynchronizedTimeline.isInitialized) {
                    return SynchronizedTimeline.shouldSessionEnd(elapsedTime);
                }
                
                // Fallback to original calculation
                const sessionDuration = this.getSessionDuration();
                return elapsedTime >= sessionDuration;
            },
            
            // Central formatted time display
            formatTime(elapsedTime) {
                const sessionDuration = this.getSessionDuration();
                const elapsedMinutes = Math.floor(elapsedTime / 60);
                const elapsedSeconds = Math.floor(elapsedTime % 60);
                const totalMinutes = Math.floor(sessionDuration / 60);
                const totalSeconds = Math.floor(sessionDuration % 60);
                return `${elapsedMinutes}:${elapsedSeconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            },
            
            // Central block timing calculation
            getBlockProcessingTime(blockDuration) {
                let processingTime = blockDuration * 60 * 1000; // Convert minutes to milliseconds
                
                // Apply ludicrous mode acceleration if active
                if (window.LudicrousSpeedManager && window.LudicrousSpeedManager.isActive) {
                    const speedMultiplier = window.LudicrousSpeedManager.speedMultiplier || 300;
                    processingTime = processingTime / speedMultiplier;
                    console.log(`🚀 TimeSystem: Ludicrous mode acceleration ${speedMultiplier}x applied`);
                }
                
                // Ensure minimum processing time for visual feedback
                return Math.max(1000, processingTime);
            },
            
            // Central multiplier calculation
            getCurrentMultiplier() {
                const elapsedTime = this.getElapsedTime();
                const sessionDuration = this.getSessionDuration();
                const milestones = calculateDynamicMultiplierMilestones(sessionDuration);
                
                let currentMultiplier = 1.0;
                const progress = elapsedTime / sessionDuration;
                
                for (let i = 0; i < milestones.length; i++) {
                    if (progress >= milestones[i].time) {
                        currentMultiplier = milestones[i].multiplier;
                    } else {
                        break;
                    }
                }
                
                return currentMultiplier;
            }
        };

        // NEW: Content tracking utility functions
        function generateContentId(content) {
            // Generate a unique ID for content based on title, type, and episode info
            let id = content.title || content.name || '';
            
            // Add episode information if available
            if (content.season && content.episode) {
                id += `-S${content.season}E${content.episode}`;
            } else if (content.episode) {
                id += `-E${content.episode}`;
            }
            
            // Add type if available
            if (content.type) {
                id += `-${content.type}`;
            }
            
            // Add service if available
            if (content.service) {
                id += `-${content.service}`;
            }
            
            return id.toLowerCase().replace(/[^a-z0-9-]/g, '-');
        }

        function isContentPlayed(contentId) {
            return appState.playedContent.has(contentId);
        }

        function markContentAsPlayed(content) {
            const contentId = generateContentId(content);
            appState.playedContent.add(contentId);
            
            // Add to content history (keep last 50 items)
            appState.contentHistory.unshift({
                id: contentId,
                content: content,
                playedAt: Date.now()
            });
            if (appState.contentHistory.length > 50) {
                appState.contentHistory.pop();
            }
            
            Tracker.logRumiAction('Content marked as played', { contentId, title: content.title });
        }

        function isContentInChannel(contentId, channelName) {
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            return appState.channelContent.get(channelName).has(contentId);
        }

        function addContentToChannel(content, channelName) {
            const contentId = generateContentId(content);
            
            if (!appState.channelContent.has(channelName)) {
                appState.channelContent.set(channelName, new Set());
            }
            
            appState.channelContent.get(channelName).add(contentId);
            Tracker.logRumiAction('Content added to channel', { contentId, channelName, title: content.title });
        }

        function removeContentFromChannel(contentId, channelName) {
            if (appState.channelContent.has(channelName)) {
                appState.channelContent.get(channelName).delete(contentId);
                Tracker.logRumiAction('Content removed from channel', { contentId, channelName });
            }
        }

        function addToGlobalQueue(content, channelName) {
            const contentId = generateContentId(content);
            
            // Check if content is already in global queue
            const existingIndex = appState.globalContentQueue.findIndex(item => generateContentId(item.content) === contentId);
            if (existingIndex !== -1) {
                return false; // Already in queue
            }
            
            appState.globalContentQueue.push({
                content: content,
                channelName: channelName,
                addedAt: Date.now(),
                contentId: contentId
            });
            
            Tracker.logRumiAction('Content added to global queue', { contentId, channelName, title: content.title });
            return true;
        }

        function removeFromGlobalQueue(contentId) {
            const index = appState.globalContentQueue.findIndex(item => item.contentId === contentId);
            if (index !== -1) {
                const removed = appState.globalContentQueue.splice(index, 1)[0];
                Tracker.logRumiAction('Content removed from global queue', { contentId, channelName: removed.channelName });
                return removed;
            }
            return null;
        }

        function getFilteredContentForChannel(contentList, channelName, excludeContentIds = new Set()) {
            // Filter out content that's already been played, is in the channel, or is in excludeContentIds
            return contentList.filter(content => {
                const contentId = generateContentId(content);
                return !isContentPlayed(contentId) && !isContentInChannel(contentId, channelName) && !excludeContentIds.has(contentId);
            });
        }

        function getContentRecommendations(excludePlayed = true, limit = 10) {
            // Get content recommendations based on history
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && (!excludePlayed || !isContentPlayed(contentId))) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        function clearContentTracking() {
            // Clear all content tracking (useful for testing or reset)
            appState.playedContent.clear();
            appState.channelContent.clear();
            appState.globalContentQueue = [];
            appState.contentHistory = [];
            Tracker.logRumiAction('Content tracking cleared');
        }

        // NEW: Debug function to test content tracking
        function debugContentTracking() {
            console.log('=== CONTENT TRACKING DEBUG ===');
            console.log('Played Content Count:', appState.playedContent.size);
            console.log('Played Content IDs:', Array.from(appState.playedContent));
            
            console.log('Channel Content:');
            appState.channelContent.forEach((contentSet, channelName) => {
                console.log(`  ${channelName}: ${contentSet.size} items`);
                console.log(`    IDs:`, Array.from(contentSet));
            });
            
            console.log('Global Queue Count:', appState.globalContentQueue.length);
            console.log('Global Queue Items:', appState.globalContentQueue.map(item => ({
                title: item.content.title,
                channelName: item.channelName,
                contentId: item.contentId
            })));
            
            console.log('Content History Count:', appState.contentHistory.length);
            console.log('Recent History:', appState.contentHistory.slice(0, 5).map(item => ({
                title: item.content.title,
                playedAt: new Date(item.playedAt).toLocaleTimeString()
            })));
            
            // Test content ID generation
            const testContent = {
                title: 'Test Show',
                season: 'S1',
                episode: 'E1',
                type: 'show',
                service: 'netflix'
            };
            console.log('Test Content ID:', generateContentId(testContent));
            
            // Test filtering
            const testContentList = [
                { title: 'Show 1', type: 'show' },
                { title: 'Show 2', type: 'movie' },
                { title: 'Show 3', type: 'show' }
            ];
            const filtered = getFilteredContentForChannel(testContentList, 'test-channel');
            console.log('Filtered Content for test-channel:', filtered.length, 'items');
            
            console.log('=== END CONTENT TRACKING DEBUG ===');
        }

        // NEW: Debug function to inspect show detection state
        function debugShowDetectionState() {
            console.log('=== SHOW DETECTION DEBUG STATE ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Is Indexing:', appState.isIndexing);
            console.log('Indexing Start Time:', appState.indexingStartTime);
            console.log('Detected Show:', appState.detectedShow);
            
            if (appState.isIndexing && appState.indexingStartTime) {
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                console.log('Elapsed Time:', elapsedTime.toFixed(2) + 's');
            }
            
            console.log('Content Items Count:', appState.automodeContentItems ? appState.automodeContentItems.length : 0);
            console.log('Current Content Index:', appState.currentContentIndex);
            console.log('Content Item Start Time:', appState.contentItemStartTime);
            console.log('Content Item Duration:', appState.contentItemDuration);
            
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                console.log('Current Content Item:', appState.automodeContentItems[appState.currentContentIndex]);
                if (appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                    console.log('Next Content Item:', appState.automodeContentItems[appState.currentContentIndex + 1]);
                }
            }
            
            // Show session duration info without causing overflow
            console.log('Cached Session Duration:', appState.cachedSessionDuration);
            console.log('Cache Timestamp:', appState.cachedSessionDurationTimestamp);
            if (appState.cachedSessionDurationTimestamp) {
                const cacheAge = Date.now() - appState.cachedSessionDurationTimestamp;
                console.log('Cache Age:', (cacheAge / 1000).toFixed(1) + 's');
            }
            console.log('Chained Session Duration:', appState.chainedSessionDuration);
            if (appState.detectedShow && appState.detectedShow.duration) {
                console.log('Detected Show Duration:', appState.detectedShow.duration + ' minutes');
            }
            console.log('Base Rate:', appState.baseRate);
            console.log('Current Multiplier:', appState.currentMultiplier);
            console.log('=== END SHOW DETECTION DEBUG ===');
        }

        // NEW: Debug function to inspect channel content
        function debugChannelContent() {
            console.log('=== CHANNEL CONTENT DEBUG ===');
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (channelFrame && channelFrame.contentWindow) {
                console.log('Channel frame found, requesting content...');
                try {
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                } catch (e) {
                    console.log('Error requesting channel content:', e.message);
                }
        } else {
                console.log('Channel frame not found or not accessible');
            }
            console.log('=== END CHANNEL CONTENT DEBUG ===');
        }

        // NEW: Debug function to reset show detection state
        function debugResetShowDetection() {
            console.log('=== RESETTING SHOW DETECTION STATE ===');
            appState.automodeContentItems = [];
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = 0;
            appState.contentTransitionProgress = 0;
            console.log('Show detection state reset');
            console.log('=== END RESET ===');
        }

        // NEW: Function to clear session duration cache
        function clearSessionDurationCache() {
            appState.cachedSessionDuration = null;
            appState.cachedSessionDurationTimestamp = null;
            console.log('Session duration cache cleared');
        }

        // NEW: Channel integration functions
        function integrateContentTrackingWithChannels() {
            // Send content tracking data to all loaded channels
            const channelFrames = [
                document.getElementById('channel-frame'),
                document.getElementById('channel-frame-indexing')
            ];
            
            channelFrames.forEach(frame => {
                if (frame && frame.contentWindow) {
                    try {
                        // Send played content data to channel
                        frame.contentWindow.postMessage({
                            type: 'contentTracking',
                            playedContent: Array.from(appState.playedContent),
                            channelContent: Object.fromEntries(appState.channelContent),
                            globalQueue: appState.globalContentQueue
                        }, '*');
                    } catch (e) {
                        console.log('Could not send content tracking to channel:', e.message);
                    }
                }
            });
        }

        function handleChannelContentAdded(content, channelName) {
            // Called when content is added to a channel
            addContentToChannel(content, channelName);
            
            // Also add to global queue if not already there
            addToGlobalQueue(content, channelName);
            
            Tracker.logRumiAction('Content added to channel from tracking', { 
                contentId: generateContentId(content), 
                channelName, 
                title: content.title 
            });
        }

        function handleChannelContentPlayed(content, channelName) {
            // Called when content is played from a channel
            markContentAsPlayed(content);
            
            // Remove from channel content (since it's now played)
            const contentId = generateContentId(content);
            removeContentFromChannel(contentId, channelName);
            
            // Remove from global queue
            removeFromGlobalQueue(contentId);
            
            Tracker.logRumiAction('Content played from channel', { 
                contentId, 
                channelName, 
                title: content.title 
            });
        }

        // NEW: Function to get filtered content for channels
        function getChannelContentRecommendations(channelName, limit = 10) {
            // Get content recommendations that haven't been played and aren't in this channel
            const recommendations = [];
            const seenIds = new Set();
            
            // Add recent content from history as recommendations
            appState.contentHistory.forEach(historyItem => {
                if (recommendations.length >= limit) return;
                
                const contentId = historyItem.id;
                if (!seenIds.has(contentId) && 
                    !isContentPlayed(contentId) && 
                    !isContentInChannel(contentId, channelName)) {
                    recommendations.push(historyItem.content);
                    seenIds.add(contentId);
                }
            });
            
            return recommendations;
        }

        // NEW: Function to export content tracking data
        function exportContentTrackingData() {
            return {
                playedContent: Array.from(appState.playedContent),
                channelContent: Object.fromEntries(appState.channelContent),
                globalQueue: appState.globalContentQueue,
                contentHistory: appState.contentHistory.map(item => ({
                    id: item.id,
                    title: item.content.title,
                    playedAt: item.playedAt
                }))
            };
        }

        // NEW: Function to import content tracking data
        function importContentTrackingData(data) {
            if (data.playedContent) {
                appState.playedContent = new Set(data.playedContent);
            }
            if (data.channelContent) {
                appState.channelContent = new Map(Object.entries(data.channelContent).map(([key, value]) => [key, new Set(value)]));
            }
            if (data.globalQueue) {
                appState.globalQueue = data.globalQueue;
            }
            if (data.contentHistory) {
                appState.contentHistory = data.contentHistory;
            }
            
            Tracker.logRumiAction('Content tracking data imported', { 
                playedCount: appState.playedContent.size,
                channelCount: appState.channelContent.size,
                queueCount: appState.globalContentQueue.length
            });
        }

        // Initialize app
        function initApp() {
            // If we have already launched from an entry point, don't re-initialize.
            if (appState.entryPoint) {
                return;
            }

            console.log('Initializing app...');
            
            if (typeof Tracker === 'undefined') {
                console.error('Tracker not loaded!');
                return;
            }

            Tracker.startFlow(RUMI_PROJECT.flows.HOME_SCREEN);
            Tracker.logRumiAction('App initialized');
            Tracker.logRumiState(appState);
            
            // Initialize UI based on current state
            updateUI();
            updatePointsDisplay();
            
            // Test home screen checkpoints
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.HOME_LOADED, true, 'Home screen loaded');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.POINTS_DISPLAYED, true, 'Points displayed correctly');
            Tracker.assertRumi(RUMI_PROJECT.checkpoints.CTA_POSITIONED, true, 'CTA positioned correctly');
            
            Tracker.endFlow();
            console.log('App initialized successfully');

            // Start error monitoring
            monitorVolume();
            // monitorConnection(); // Disabled - was causing false connection errors during indexing
        }

        // Toggle indexing state
        function toggleIndexing() {
            if (appState.isIndexing) {
                stopIndexing();
            } else {
                // Always use enhanced transition system version for detection mode
                if (appState.entryPoint === 'detection') {
                    startIndexingWithTransitionSystem();
                } else {
                    // Use regular start for other modes
                startIndexing();
                }
            }
        }

        // Start indexing
       function startIndexing() {
            // If session is already running, do nothing.
            if (appState.indexingStartTime) return;

            // Ensure state and view are correct, even if called directly.
            if (!appState.isIndexing) {
                appState.isIndexing = true;
                updateUI();
            }
            
            // Check if holistic panel is visible
            const holisticPanel = document.getElementById('holistic-indexing-panel');
            const nokiaContent = document.getElementById('nokia-content');
            console.log('🔍 Indexing started - UI elements ready:', {
                holisticPanel: !!holisticPanel,
                nokiaContent: !!nokiaContent
            });

            // Reset session state
            appState.sessionEndReason = null;
            appState.isPaused = false;
            appState.pauseStartTime = null;
            appState.pauseDuration = 0;
            appState.sessionCompleted = false; // Reset session completion flag
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for new session
            appState.firstBlockCompleted = false; // Reset first block completion flag
            appState.watchWithUsPromptShown = false; // Reset watch with us prompt flag
            appState.pausedForWatchWithUs = false; // Reset watch with us pause flag
            
            // Clean up any existing modal timeout
            if (appState.watchWithUsModalTimeout) {
                clearTimeout(appState.watchWithUsModalTimeout);
                appState.watchWithUsModalTimeout = null;
            }

            // Set base rate for this session
            appState.baseRate = (appState.entryPoint === 'automode') ? 0.12 : 0.1; // Automode gets 20% MORE points per second and 4x longer sessions
            appState.indexingStartTime = Date.now();
            appState.sessionEarnings = 0;
            
            // Initialize unified time synchronization
            UnifiedTimeSync.initialize();

            // Initialize automode content tracking
            if (appState.entryPoint === 'automode') {
                console.log('🔍 [DEBUG] Starting automode content initialization');
                console.log('🔍 [DEBUG] Current bucket:', appState.currentBucket);
                console.log('🔍 [DEBUG] Base rate:', appState.baseRate);
                console.log('🔍 [DEBUG] Current multiplier:', appState.currentMultiplier);
                
                // Generate content items for the session (240 minutes = 14400 seconds)
                getAutomodeContent(appState.currentBucket, 14400, appState.baseRate, appState.currentMultiplier)
                    .then(contentItems => {
                        console.log('🔍 [DEBUG] Automode content loaded successfully:', contentItems);
                        appState.automodeContentItems = contentItems;
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // Calculate duration for first content item
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                            console.log(`Initial setup - First item: ${firstItem.title}, duration_seconds: ${firstItem.duration_seconds}, duration string: "${firstItem.duration}"`);
                            
                            // Use duration_seconds if available, otherwise parse duration string
                            if (firstItem.duration_seconds) {
                                appState.contentItemDuration = firstItem.duration_seconds;
                                console.log(`Initial setup - Using duration_seconds: ${appState.contentItemDuration} seconds`);
                            } else {
                    // Parse duration string (e.g., "1:23") to seconds
                    const durationParts = firstItem.duration.split(':');
                    console.log(`Initial setup - Duration parts:`, durationParts);
                    appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    console.log(`Initial setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                }
                            
                            // Initialize synchronized timeline with automode content
                            SynchronizedTimeline.initializeTimeline(appState.automodeContentItems);
                            console.log('🎯 SynchronizedTimeline: Initialized with automode content');
                            
                            // Initialize block progression with actual content
                            appState.totalBlocks = appState.automodeContentItems.length;
                            updateBlockProgressionDisplay();
                            
                            // Force animation panel refresh now that content is loaded
                            if (appState.isIndexing) {
                                const elapsedTime = TimeSystem.getElapsedTime();
                                updateAnimationPanel(elapsedTime);
                                console.log('🎯 Animation panel refreshed with loaded content');
                            }
                        }
                    })
                    .catch(error => {
                        console.error('❌ [DEBUG] Error loading automode content:', error);
                        // Use CSV content
                        console.log('🔍 [DEBUG] Using CSV content for bucket:', appState.currentBucket);
                        generateRobustFallbackContent(appState.currentBucket, 14400, appState.baseRate, appState.currentMultiplier)
                            .then(csvItems => {
                                appState.automodeContentItems = csvItems;
                                console.log('🔍 [DEBUG] CSV content generated:', appState.automodeContentItems);
                                appState.totalBlocks = appState.automodeContentItems.length;
                                
                                // Initialize synchronized timeline with CSV content
                                if (appState.automodeContentItems.length > 0) {
                                    SynchronizedTimeline.initializeTimeline(appState.automodeContentItems);
                                    console.log('🎯 SynchronizedTimeline: Initialized with CSV content');
                                }
                                
                                // Force animation panel refresh now that CSV content is loaded
                                if (appState.isIndexing) {
                                    const elapsedTime = TimeSystem.getElapsedTime();
                                    updateAnimationPanel(elapsedTime);
                                    console.log('🎯 Animation panel refreshed with CSV content');
                                }
                            });
                        appState.totalBlocks = appState.automodeContentItems.length;
                        
                        // Initialize synchronized timeline with fallback content
                        if (appState.automodeContentItems.length > 0) {
                            SynchronizedTimeline.initializeTimeline(appState.automodeContentItems);
                            console.log('🎯 SynchronizedTimeline: Initialized with fallback content');
                        }
                        
                        // Force animation panel refresh now that fallback content is loaded
                        if (appState.isIndexing) {
                            const elapsedTime = TimeSystem.getElapsedTime();
                            updateAnimationPanel(elapsedTime);
                            console.log('🎯 Animation panel refreshed with fallback content');
                        }
                    });
            } else if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // Initialize content items for show detection mode
                const sessionDuration = calculateSessionDuration();
                appState.automodeContentItems = getShowDetectionContent(appState.detectedShow, sessionDuration);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0; // Start at 0 elapsed time
                appState.contentItemDuration = 0;
                appState.contentTransitionProgress = 0;
                
                // Calculate duration for first content item if we have content
                if (appState.automodeContentItems.length > 0) {
                    const firstItem = appState.automodeContentItems[0];
                    console.log(`Show detection setup - First item: ${firstItem.title}, duration: ${firstItem.duration}`);
                    
                    // Handle both duration strings and numeric durations
                    if (typeof firstItem.duration === 'string' && firstItem.duration.includes(':')) {
                        // Parse duration string (e.g., "0:45") to seconds
                        const durationParts = firstItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        console.log(`Show detection setup - Parsed duration: ${appState.contentItemDuration} seconds`);
                    } else {
                        // Use duration as-is (already in seconds)
                        appState.contentItemDuration = firstItem.duration;
                        console.log(`Show detection setup - Using duration as-is: ${appState.contentItemDuration} seconds`);
                    }
                    
                    // Initialize synchronized timeline with detected show
                    const initialShowItem = {
                        title: `${appState.detectedShow.title} ${appState.detectedShow.season !== 'N/A' ? `S${appState.detectedShow.season} E${appState.detectedShow.episode}` : '(Film)'}`,
                        duration: appState.contentItemDuration,
                        type: appState.detectedShow.type || 'show',
                        service: appState.detectedShow.service || 'UNKNOWN',
                        season: appState.detectedShow.season || 'N/A',
                        episode: appState.detectedShow.episode || 'N/A'
                    };
                    
                    SynchronizedTimeline.initializeTimeline([initialShowItem]);
                    console.log('🎯 SynchronizedTimeline: Initialized with detected show');
                } else {
                    // No content yet - will be populated when channel responds
                    console.log('Show detection setup - No content items yet, waiting for channel response');
                    // Set a default duration until content arrives
                    appState.contentItemDuration = 45 * 60; // 45 minutes default
                }
            }

            // Always initialize transition system for detection mode
            if (appState.entryPoint === 'detection') {
                if (!window.transitionSystem) {
                    console.log('Initializing transition system for detection mode...');
                    initializeTransitionSystem();
                } else {
                    console.log('Transition system already available for detection mode');
                }
                
                // Initialize with current detected show if available
                if (appState.detectedShow) {
                    setTimeout(() => {
                        updateButtonWithCurrentShow(appState.detectedShow);
                        // Don't trigger content display update immediately - let the channel keep its existing content
                        // triggerContentDisplayUpdate('session_start'); // Removed to prevent content clearing
                    }, 100);
                }
            }

            // Initialize block progression system
            initializeBlockProgression();

            // Start animation loop
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animateSessionStats();
            
            // NEW: Send startIndexing message to genre channel for block progression
            if (appState.entryPoint === 'detection') {
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                const startIndexingMessage = {
                    type: 'startIndexing',
                    payload: {
                        sessionId: Date.now(),
                        entryPoint: appState.entryPoint,
                        detectedShow: appState.detectedShow
                    }
                };
                
                if (channelFrame && channelFrame.contentWindow) {
                    channelFrame.contentWindow.postMessage(startIndexingMessage, '*');
                    console.log('📡 [DEBUG] Sent startIndexing message to main genre channel');
                console.log('🔍 [DEBUG] Message payload:', startIndexingMessage);
                }
                if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                    channelFrameIndexing.contentWindow.postMessage(startIndexingMessage, '*');
                    console.log('📡 [DEBUG] Sent startIndexing message to indexing genre channel');
                    console.log('🔍 [DEBUG] Message payload:', startIndexingMessage);
                }
                
                // Debug: Check if channel has content after a delay
                setTimeout(() => {
                    console.log('🔍 [DEBUG] Checking channel readiness after 2 seconds...');
                    if (channelFrame && channelFrame.contentWindow) {
                        try {
                            channelFrame.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
                            console.log('📡 [DEBUG] Requested current content from main channel');
                        } catch (error) {
                            console.error('❌ [DEBUG] Error requesting content from main channel:', error);
                        }
                    }
                    if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                        try {
                            channelFrameIndexing.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
                            console.log('📡 [DEBUG] Requested current content from indexing channel');
                        } catch (error) {
                            console.error('❌ [DEBUG] Error requesting content from indexing channel:', error);
                        }
                    }
                }, 2000);
            }
            
            Tracker.logRumiAction('Indexing session activated');
            updatePointsDisplay(); // Switch to session view in points panel
            appState.simResolved = false;
            updateDebugButtonStates(); // Update debug button states when indexing starts
        }
// Helper to record actual indexed content before showing receipt
function recordActualIndexedContentBeforeReceipt() {
    try {
        // If already populated, do nothing
        if (appState.indexedContent && appState.indexedContent.length > 0) return;

        // Only proceed if in detection mode and a show is detected
        if (appState.entryPoint !== 'detection') return;
        if (!appState.detectedShow || !appState.detectedShow.title) {
            console.warn('No detectedShow available for indexed content recording.');
            return;
        }
        const sessionDuration = calculateSessionDuration();
        const sessionDurationMinutes = Math.floor(sessionDuration / 60);
        const totalElapsedTime = Math.floor((Date.now() - appState.indexingStartTime) / 60000);
        const actualDuration = Math.min(sessionDurationMinutes, totalElapsedTime);

        if (appState.originalShow && appState.interruptNewShow) {
            // If there was a show transition, split time using interrupt timestamp if available
            let originalShowTime, chainedShowTime;
            if (appState.showInterruptTimestamp) {
                const interruptTimeMinutes = Math.floor((appState.showInterruptTimestamp - appState.indexingStartTime) / 60000);
                originalShowTime = Math.min(interruptTimeMinutes, actualDuration);
                chainedShowTime = Math.max(0, actualDuration - originalShowTime);
            } else {
                const interruptTime = Math.floor(actualDuration * 0.75);
                originalShowTime = interruptTime;
                chainedShowTime = actualDuration - interruptTime;
            }
            // Record original show
            const originalShowItem = {
                title: `${appState.originalShow.title} ${appState.originalShow.season !== 'N/A' ? `S${appState.originalShow.season} E${appState.originalShow.episode}` : '(Film)'}`,
                duration: originalShowTime,
                type: 'detected_show',
                points: Math.round((originalShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
            };
            appState.indexedContent.push(originalShowItem);
            // Record chained show
            const chainedShowItem = {
                title: `${appState.interruptNewShow.title} ${appState.interruptNewShow.season !== 'N/A' ? `S${appState.interruptNewShow.season} E${appState.interruptNewShow.episode}` : '(Film)'} (Chained)`,
                duration: chainedShowTime,
                type: 'chained_show',
                points: calculatePointsWithMultipliers(chainedShowTime * 60, appState.baseRate || 0.1, TimeSystem.getSessionDuration())
            };
            appState.indexedContent.push(chainedShowItem);
            markContentAsPlayed(originalShowItem);
            markContentAsPlayed(chainedShowItem);
            console.log('Indexed content recorded (transition):', appState.indexedContent);
        } else {
            // No show transition - get content from genre channel for accurate receipt
            const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
            
            if (channelFrame && channelFrame.contentWindow) {
                // Request current content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                
                // Set up one-time listener for channel content
                const messageHandler = (event) => {
                    if (event.data.type === 'currentContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const channelContent = event.data.content || [];
                        const baseRate = appState.baseRate || 0.1;
                        const finalMultiplier = appState.currentMultiplier || 1.0;
                        
                        // Convert channel content to indexed content format
                        channelContent.forEach(item => {
                            const itemDurationMinutes = Math.min(item.duration || 45, actualDuration);
                            const itemPoints = calculatePointsWithMultipliers(itemDurationMinutes * 60, baseRate, TimeSystem.getSessionDuration());
                            
                            const indexedItem = {
                                title: item.title, // Use actual title from channel
                                duration: itemDurationMinutes,
                                points: itemPoints,
                                type: item.type || 'detected_show',
                                service: item.service || 'DETECTED',
                                season: item.season,
                                episode: item.episode
                            };
                            
                            appState.indexedContent.push(indexedItem);
                            markContentAsPlayed(indexedItem);
                        });
                        
                        console.log('Indexed content recorded from channel:', appState.indexedContent);
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Timeout fallback after 500ms
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    
                    // Fallback if no channel response
                    if (appState.indexedContent.length === 0) {
                        const displayTitle = appState.detectedShow.episode_title ? 
                            `${appState.detectedShow.title} - ${appState.detectedShow.episode_title}` :
                            `${appState.detectedShow.title} ${appState.detectedShow.season !== 'N/A' ? `S${appState.detectedShow.season}E${appState.detectedShow.episode}` : '(Film)'}`;
                        
            const indexedContentItem = {
                            title: displayTitle,
                duration: actualDuration,
                type: 'detected_show',
                points: calculatePointsWithMultipliers(actualDuration * 60, appState.baseRate || 0.1, TimeSystem.getSessionDuration())
            };
            appState.indexedContent.push(indexedContentItem);
            markContentAsPlayed(indexedContentItem);
                        console.log('Indexed content recorded (fallback):', appState.indexedContent);
                    }
                }, 500);
            } else {
                // Direct fallback if no channel available
                const displayTitle = appState.detectedShow.episode_title ? 
                    `${appState.detectedShow.title} - ${appState.detectedShow.episode_title}` :
                    `${appState.detectedShow.title} ${appState.detectedShow.season !== 'N/A' ? `S${appState.detectedShow.season}E${appState.detectedShow.episode}` : '(Film)'}`;
                
                const indexedContentItem = {
                    title: displayTitle,
                    duration: actualDuration,
                    type: 'detected_show',
                    points: calculatePointsWithMultipliers(actualDuration * 60, appState.baseRate || 0.1, TimeSystem.getSessionDuration())
                };
                appState.indexedContent.push(indexedContentItem);
                markContentAsPlayed(indexedContentItem);
                console.log('Indexed content recorded (direct fallback):', appState.indexedContent);
            }
        }
    } catch (e) {
        console.error('Error in recordActualIndexedContentBeforeReceipt:', e);
    }
}

        // NEW: Update holistic indexing panel with real-time block progression
        function updateHolisticIndexingPanel(currentTitle, currentState) {
            console.log('🔍 [DEBUG] updateHolisticIndexingPanel called with:', { currentTitle, currentState });
            
            const holisticPanel = document.getElementById('holistic-indexing-panel');
            const showInfo = document.getElementById('holistic-show-info');
            
            console.log('🔍 [DEBUG] Panel elements:', {
                holisticPanel: holisticPanel ? 'Found' : 'Not found',
                showInfo: showInfo ? 'Found' : 'Not found'
            });
            
            if (!holisticPanel || !showInfo) {
                console.warn('⚠️ [DEBUG] Missing panel elements, exiting updateHolisticIndexingPanel');
                return;
            }
            
            // Update show info
            if (appState.detectedShow) {
                const show = appState.detectedShow;
                const showText = show.season && show.episode && show.season !== 'N/A' && show.episode !== 'N/A' ? 
                    `${show.title} S${show.season}E${show.episode}` : 
                    show.title;
                showInfo.textContent = `📺 ${showText}`;
            }
            
            // Don't update progressInfo here - let updateAnimationPanel handle it
            // The rich progress bar with time and diamonds is managed there
            
            // Update visual styling based on indexing state
            if (currentState === 'indexing') {
                holisticPanel.style.borderColor = '#00ff41';
                holisticPanel.style.boxShadow = '0 0 12px rgba(0, 255, 65, 0.3)';
            } else {
                holisticPanel.style.borderColor = '#333333';
                holisticPanel.style.boxShadow = 'none';
            }
        }

        function stopIndexing() {
            if (!appState.isIndexing) {
                return;
            }
            
            // Only record indexed content for detection mode
            if (appState.entryPoint === 'detection') {
                recordActualIndexedContentBeforeReceipt();
                
                // Wait for indexed content to be populated before showing receipt
                const waitForIndexedContent = () => {
                    if (appState.indexedContent && appState.indexedContent.length > 0) {
                        // Content is ready, proceed with normal stopIndexing flow
                        finishStopIndexing();
                    } else {
                        // Wait a bit more, but don't wait forever
                        setTimeout(waitForIndexedContent, 100);
                    }
                };
                
                // Start checking after a brief delay to allow message processing
                setTimeout(waitForIndexedContent, 200);
                return; // Don't continue with stopIndexing until content is ready
            } else {
            // Record automode indexed content
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                    // If indexed content is already populated (from moveToNextContentItem), don't overwrite it
                    if (!appState.indexedContent || appState.indexedContent.length === 0) {
                    appState.indexedContent = appState.automodeContentItems
                        .slice(0, appState.currentContentIndex + 1)
                            .map(item => {
                                // Calculate actual duration
                                let itemDurationSeconds;
                                if (typeof item.duration === 'string' && item.duration.includes(':')) {
                                    const durationParts = item.duration.split(':');
                                    itemDurationSeconds = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                                } else {
                                    itemDurationSeconds = item.duration || (45 * 60);
                                }
                                
                                return {
                            title: item.title,
                                    duration: Math.floor(itemDurationSeconds / 60), // Convert to minutes
                                    points: calculatePointsWithMultipliers(itemDurationSeconds, appState.baseRate || 0.08, TimeSystem.getSessionDuration()),
                                    type: 'automode_content'
                                };
                            });
                    }
                    
                    console.log(`📊 StopIndexing: Recorded ${appState.indexedContent.length} automode content items`);
                }
                
                // Proceed immediately for automode
                finishStopIndexing();
            }
        }
        
        function finishStopIndexing() {
            appState.isIndexing = false;
            appState.totalPendingPoints += appState.sessionEarnings;
            
            // Set session end reason
            appState.sessionEndReason = 'user_stop';
            
            console.log(`📊 Finishing stop indexing with ${appState.indexedContent.length} indexed items`);
            
            // NEW: Send stopIndexing message to genre channel
            if (appState.entryPoint === 'detection') {
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                const stopIndexingMessage = {
                    type: 'stopIndexing',
                    payload: {
                        sessionId: Date.now(),
                        entryPoint: appState.entryPoint,
                        sessionDuration: appState.indexingStartTime ? 
                            Math.floor((Date.now() - appState.indexingStartTime) / 1000) : 0
                    }
                };
                
                if (channelFrame && channelFrame.contentWindow) {
                    channelFrame.contentWindow.postMessage(stopIndexingMessage, '*');
                    console.log('📡 Sent stopIndexing message to main genre channel');
                }
                if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                    channelFrameIndexing.contentWindow.postMessage(stopIndexingMessage, '*');
                    console.log('📡 Sent stopIndexing message to indexing genre channel');
                }
            }
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Stop ASCII animation system
            if (window.ASCIIAnimationState) {
                ASCIIAnimationState.stop();
                ASCIIAnimationState.currentPattern = null;
                ASCIIAnimationState.animationFrame = 0;
                ASCIIAnimationState.lastContentTitle = null;
                
                // Clear the animation panel
                const panel = document.getElementById('animation-panel-content');
                if (panel) {
                    panel.innerHTML = '';
                }
            }
            
            // Calculate any remaining real-time points before showing the receipt
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.sessionEarnings = calculatePointsWithMultipliers(elapsedTime, appState.baseRate || 0.1, TimeSystem.getSessionDuration());
            // Calculate session data and show receipt
            const sessionDuration = Math.floor(elapsedTime);
            const finalMultiplier = appState.currentMultiplier;
            showReceiptView(appState.sessionEarnings, sessionDuration, finalMultiplier);

            // Reset session state
            appState.indexingStartTime = null;
            appState.showInterruptTimestamp = null; // Reset interrupt timestamp for next session
            
            // Stop unified time synchronization
            UnifiedTimeSync.stop();
            
            // Reset synchronized timeline
            SynchronizedTimeline.reset();
            
            Tracker.logRumiAction('Indexing stopped');
            updatePointsDisplay();
            updateDebugButtonStates(); // Update debug button states when indexing stops
        }

        // Show receipt view with session results
        function showReceiptView(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt view shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint,
                sessionEndReason: appState.sessionEndReason
            });
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Check if transition system has data and use it
            let receiptData = {
                totalPoints: sessionEarnings,
                totalPending: appState.totalPendingPoints + sessionEarnings,
                duration: sessionDuration,
                multiplier: finalMultiplier,
                numberOfShows: 1,
                playedContent: []
            };
            
            // Use transition system data if available
            if (window.transitionSystem && window.transitionSystem.getSessionData) {
                const transitionData = window.transitionSystem.getSessionData();
                if (transitionData.totalPoints > 0) {
                    receiptData = {
                        totalPoints: transitionData.totalPoints,
                        totalPending: appState.totalPendingPoints + transitionData.totalPoints,
                        duration: transitionData.totalTimeIndexed * 60, // Convert to seconds
                        multiplier: finalMultiplier,
                        numberOfShows: transitionData.numberOfShows,
                        playedContent: window.transitionSystem.state.playedContent || []
                    };
                }
            }
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${receiptData.totalPoints.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${receiptData.totalPending.toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(receiptData.duration);
            document.getElementById('receipt-multiplier').textContent = `${receiptData.multiplier.toFixed(1)}x`;
            
            // Enhanced bonus text based on transition system data
            const bonusElement = document.getElementById('receipt-bonus');
            if (receiptData.numberOfShows > 2) {
                bonusElement.textContent = `Multi-Show Bonus (${receiptData.numberOfShows} shows)`;
                bonusElement.style.color = '#ffaa00';
            } else if (appState.interruptNewShow && finalMultiplier >= 1.1) {
                bonusElement.textContent = 'Chained Content Bonus';
                bonusElement.style.color = '#ffaa00';
            } else if (finalMultiplier >= 1.2) {
                bonusElement.textContent = 'Time Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Set the correct base rate in the receipt
            const baseRateValue = appState.entryPoint === 'automode' ? '0.12 pts/s' : '0.1 pts/s';
            const baseRateSpans = document.querySelectorAll('#receipt-view span[style*="color: #fff"]');
            baseRateSpans.forEach(span => {
                if (span.textContent.includes('pts/')) {
                    span.textContent = baseRateValue;
                }
            });
            
            // Generate enhanced content list
            generateEnhancedReceiptContentList(receiptData);
            
            appState.view = 'receipt';
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // NEW: Enhanced receipt content list with transition system data
        function generateEnhancedReceiptContentList(receiptData) {
            const contentList = document.getElementById('receipt-content-list');
            const contentItems = [];
            
            // PRIORITY 1: Use appState.indexedContent if available (most accurate)
            if (appState.indexedContent && appState.indexedContent.length > 0) {
                console.log(`📊 Receipt: Using ${appState.indexedContent.length} indexed content items from appState`);
                appState.indexedContent.forEach((content, index) => {
                    // Use the stored points from indexed content (already calculated correctly)
                    const pointsEarned = content.points || 0;
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration}min`,
                        points: pointsEarned.toFixed(1),
                        isTransition: content.type === 'chained_show' || content.title.includes('(Chained)'),
                        isError: content.type === 'error',
                        service: content.service || 'Unknown'
                    });
                });
            }
            // PRIORITY 2: Use transition system content if no indexed content available
            else if (receiptData.playedContent && receiptData.playedContent.length > 0) {
                console.log(`📊 Receipt: Using ${receiptData.playedContent.length} transition system content items`);
                receiptData.playedContent.forEach((content, index) => {
                    // Use the stored points from transition system (already calculated correctly)
                    const pointsEarned = content.points || 0;
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration}min`,
                        points: pointsEarned.toFixed(1),
                        isTransition: index > 0,
                        service: content.service || 'Unknown'
                    });
                });
            }
            // PRIORITY 3: Fallback to standard receipt generation
            else {
                console.log('📊 Receipt: No indexed content available, using fallback generation');
                generateReceiptContentList(receiptData.duration, appState.entryPoint, appState.sessionEndReason);
                return;
            }
            
            // Generate HTML for enhanced content items
            const contentHTML = contentItems.map((item, index) => `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 6px; background: ${item.isError ? '#1a0000' : item.isTransition ? '#1a1a00' : '#1a1a1a'}; border-radius: 4px; border: ${item.isError ? '1px solid #ff4444' : item.isTransition ? '1px solid #ffaa00' : 'none'};">
                    <div style="flex: 1;">
                        <div style="color: ${item.isError ? '#ff4444' : item.isTransition ? '#ffaa00' : '#fff'}; font-size: 11px; font-weight: 600;">${item.title}</div>
                        <div style="color: #888; font-size: 9px; margin-top: 2px;">${item.service}${item.isTransition ? ' • Transition Bonus' : ''}${item.isError ? ' • Error' : ''}</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                        <span style="color: #888; font-size: 10px;">${item.duration}</span>
                        <span style="color: ${item.isError ? '#ff4444' : item.isTransition ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points}</span>
                    </div>
                </div>
            `).join('');
            
            // Add session summary at the top
            const summaryHTML = `
                <div style="background: #0a0a0a; border: 1px solid #333; border-radius: 6px; padding: 8px; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="color: #fff; font-size: 12px; font-weight: 600;">Session Summary</div>
                        <div style="color: #ffaa00; font-size: 11px;">${contentItems.length} item${contentItems.length > 1 ? 's' : ''}</div>
                    </div>
                    <div style="color: #888; font-size: 10px; margin-top: 4px;">
                        ${Math.floor(receiptData.duration / 60)} minutes • ${receiptData.multiplier.toFixed(1)}x multiplier • +${receiptData.totalPoints.toFixed(2)} points
                    </div>
                </div>
            `;
            
            contentList.innerHTML = summaryHTML + contentHTML;
            
            // Handle scrolling for many items - implement movie credits style scrolling
            if (contentItems.length > 3) {
                const itemHeight = 40; // Height per item including padding
                const visibleItems = 3;
                const visibleHeight = itemHeight * visibleItems;
                
                contentList.style.height = `${visibleHeight}px`;
                contentList.style.maxHeight = `${visibleHeight}px`;
                contentList.style.overflowY = 'hidden'; // Hide scrollbar for smooth effect
                contentList.style.position = 'relative';
                
                // Create movie credits auto-scroll effect
                setTimeout(() => {
                    let scrollPosition = 0;
                    const maxScroll = Math.max(0, (contentItems.length - visibleItems) * itemHeight);
                    const scrollSpeed = 0.5; // Smooth scrolling speed
                    const pauseAtTop = 1500; // Pause at top
                    const pauseAtBottom = 2500; // Longer pause at bottom
                    
                    let isPaused = false;
                    let pauseTimer = 0;
                    let direction = 1; // 1 for down, -1 for up
                    
                    function movieCreditsScroll() {
                        if (isPaused) {
                            pauseTimer -= 16; // ~60fps
                            if (pauseTimer <= 0) {
                                isPaused = false;
                            }
                        } else {
                            scrollPosition += (scrollSpeed * direction);
                            
                            // Check boundaries and handle pauses
                            if (scrollPosition >= maxScroll && direction === 1) {
                                // Reached bottom - pause and reverse
                                scrollPosition = maxScroll;
                                direction = -1;
                                isPaused = true;
                                pauseTimer = pauseAtBottom;
                            } else if (scrollPosition <= 0 && direction === -1) {
                                // Reached top - pause and reverse
                                scrollPosition = 0;
                                direction = 1;
                                isPaused = true;
                                pauseTimer = pauseAtTop;
                            }
                            
                            contentList.scrollTop = scrollPosition;
                        }
                        
                        requestAnimationFrame(movieCreditsScroll);
                    }
                    
                    movieCreditsScroll();
                }, 1000); // Start scrolling after 1 second
            } else {
                contentList.style.maxHeight = 'none';
                contentList.style.overflowY = 'visible';
            }
        }

        // Handle scrolling behavior for receipt content
        function handleReceiptScrolling(contentList, contentItems) {
            // Handle display based on number of items and viewport height
            const viewportHeight = window.innerHeight;
            let visibleItems = 3; // Default
            
            // Adjust visible items based on viewport height breakpoints
            if (viewportHeight <= 480) {
                visibleItems = 2; // Very short screens
            } else if (viewportHeight <= 767) {
                visibleItems = 2.5; // Short screens (partial item visible)
            } else if (viewportHeight >= 1024) {
                visibleItems = 5; // Tall screens
            }
            
            if (contentItems.length <= Math.floor(visibleItems)) {
                // For few items: show all items without scrolling
                contentList.style.maxHeight = 'none';
                contentList.style.overflowY = 'visible';
                contentList.style.height = 'auto';
            } else {
                // For more items: create movie credits style auto-scroll
                const itemHeight = 32; // Height per item (28px + 4px margin)
                const visibleHeight = itemHeight * visibleItems;
                
                contentList.style.height = `${visibleHeight}px`;
                contentList.style.maxHeight = `${visibleHeight}px`;
                contentList.style.overflowY = 'hidden'; // Hide scrollbar for smooth effect
                contentList.style.position = 'relative';
                
                // Create movie credits auto-scroll effect
                setTimeout(() => {
                    let scrollPosition = 0;
                    const maxScroll = Math.max(0, (contentItems.length - Math.floor(visibleItems)) * itemHeight);
                    const scrollSpeed = viewportHeight <= 480 ? 1.0 : 0.6; // Smooth scrolling speed
                    const pauseAtTop = viewportHeight <= 480 ? 1200 : 1500; // Pause at top
                    const pauseAtBottom = viewportHeight <= 480 ? 2000 : 2500; // Longer pause at bottom
                    
                    let isPaused = false;
                    let pauseTimer = 0;
                    let direction = 1; // 1 for down, -1 for up
                    let animationId = null;
                    
                    function movieCreditsScroll() {
                        if (isPaused) {
                            pauseTimer -= 16; // ~60fps
                            if (pauseTimer <= 0) {
                                isPaused = false;
                            }
                        } else {
                            scrollPosition += (scrollSpeed * direction);
                            
                            // Check boundaries and handle pauses
                            if (scrollPosition >= maxScroll && direction === 1) {
                                scrollPosition = maxScroll;
                                direction = -1;
                                isPaused = true;
                                pauseTimer = pauseAtBottom;
                            } else if (scrollPosition <= 0 && direction === -1) {
                                scrollPosition = 0;
                                direction = 1;
                                isPaused = true;
                                pauseTimer = pauseAtTop;
                            }
                            
                            contentList.scrollTop = scrollPosition;
                        }
                        
                        // Continue animation
                        animationId = requestAnimationFrame(movieCreditsScroll);
                    }
                    
                    // Start with a pause at the top
                    isPaused = true;
                    pauseTimer = pauseAtTop;
                    
                    // Only start scrolling if there's content to scroll
                    if (maxScroll > 0) {
                        console.log(`📊 Receipt: Starting movie credits scroll for ${contentItems.length} items (max scroll: ${maxScroll}px)`);
                        movieCreditsScroll();
                    }
                    
                    // Clean up animation when receipt view is hidden
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                                const receiptView = document.getElementById('receipt-view');
                                if (receiptView && receiptView.style.display === 'none' && animationId) {
                                    cancelAnimationFrame(animationId);
                                    animationId = null;
                                }
                            }
                        });
                    });
                    
                    const receiptView = document.getElementById('receipt-view');
                    if (receiptView) {
                        observer.observe(receiptView, { attributes: true });
                    }
                }, 1000); // Start after 1 second delay
                
                // Add subtle indicator that there's more content
                const moreContentIndicator = document.createElement('div');
                moreContentIndicator.style.cssText = `
                    font-size: 8px; 
                    color: #444; 
                    text-align: center; 
                    padding: 2px; 
                    font-style: italic;
                    position: absolute;
                    bottom: -16px;
                    left: 0;
                    right: 0;
                `;
                moreContentIndicator.textContent = `${contentItems.length} items • Auto-scrolling`;
                contentList.style.position = 'relative';
                contentList.parentNode.style.position = 'relative';
                contentList.parentNode.appendChild(moreContentIndicator);
            }
        }

        // Generate content list for receipt based on session duration and mode
        function generateReceiptContentList(sessionDuration, mode, sessionEndReason) {
            const contentList = document.getElementById('receipt-content-list');
            const contentItems = [];
            
            // Calculate base rate and multiplier for points calculation
            const baseRate = appState.entryPoint === 'automode' ? 0.12 : 0.1; // points per second (automode worth more)
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Add session end reason if it was a fatal error
            if (sessionEndReason === 'fatal_error') {
                contentItems.push({
                    title: 'Session ended by terminal error',
                    duration: '--',
                    points: '--',
                    isError: true
                });
            }
            
            // Use actual indexed content if available
            if (appState.indexedContent && appState.indexedContent.length > 0) {
                console.log(`📊 Receipt: Using ${appState.indexedContent.length} indexed content items`);
                appState.indexedContent.forEach(content => {
                    contentItems.push({
                        title: content.title,
                        duration: `${content.duration}m`,
                        points: content.points ? content.points.toFixed(1) : '0.0',
                        isChained: content.type === 'chained_show' || content.title.includes('(Chained)'),
                        isError: content.type === 'error'
                    });
                });
            } else if (mode === 'detection' || mode === 'showDetection') {
                // Fallback: Show detection mode: show the detected show and related content
                if (appState.detectedShow) {
                    // Use original show if available (for chained content), otherwise use current detected show
                    const show = appState.originalShow || appState.detectedShow;
                    
                    // Use dynamic session duration instead of hardcoded 45 minutes
                    const sessionDurationMinutes = Math.floor(calculateSessionDuration() / 60);
                    const showTime = Math.min(sessionDuration, sessionDurationMinutes); // Use calculated duration
                    const showTimeSeconds = showTime * 60; // Convert to seconds
                    const showPoints = Math.round((showTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                    
                    contentItems.push({
                        title: `${show.title} ${show.season !== 'N/A' ? `S${show.season} E${show.episode}` : '(Film)'}`,
                        duration: formatTime(showTime),
                        points: showPoints.toFixed(1)
                    });
                    
                    // Add related content based on genre
                    const remainingTime = sessionDuration - showTime;
                    if (remainingTime > 0) {
                        // Check if there was a show interrupt and add the chained content
                        if (appState.interruptNewShow) {
                            const chainedShow = appState.interruptNewShow;
                            const chainedTime = Math.min(remainingTime, 30); // Assume 30 min for chained content
                            if (chainedTime > 0) {
                                const chainedTimeSeconds = chainedTime * 60;
                                const chainedPoints = Math.round((chainedTimeSeconds * baseRate * finalMultiplier) * 100) / 100;
                                
                                contentItems.push({
                                    title: `${chainedShow.title} ${chainedShow.season !== 'N/A' ? `S${chainedShow.season} E${chainedShow.episode}` : '(Film)'} (Chained)`,
                                    duration: formatTime(chainedTime),
                                    points: chainedPoints.toFixed(1),
                                    isChained: true
                                });
                                
                                // Add related content for the chained show if there's remaining time
                                const finalRemainingTime = remainingTime - chainedTime;
                                if (finalRemainingTime > 0) {
                                    const relatedContent = getRelatedContentWithPoints(chainedShow.genre, finalRemainingTime, baseRate, finalMultiplier);
                                    contentItems.push(...relatedContent);
                                }
                            }
                        } else {
                            const relatedContent = getRelatedContentWithPoints(show.genre, remainingTime, baseRate, finalMultiplier);
                            contentItems.push(...relatedContent);
                        }
                    }
                }
            } else if (mode === 'automode') {
                // Automode: show content from the current bucket
                getAutomodeContentWithPoints(appState.currentBucket, sessionDuration, baseRate, finalMultiplier)
                    .then(bucketContent => {
                        contentItems.push(...bucketContent);
                        
                        // Generate HTML for content items with points
                        const contentHTML = contentItems.map(item => `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: ${item.isError ? '#1a0000' : item.isChained ? '#1a1a00' : '#1a1a1a'}; border-radius: 3px; border: ${item.isError ? '1px solid #ff4444' : item.isChained ? '1px solid #ffaa00' : 'none'};">
                                <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'};">${item.title}</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: #888;">${item.duration}</span>
                                    <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points} pts</span>
                                </div>
                            </div>
                        `).join('');
                        
                        contentList.innerHTML = contentHTML;
                        
                        // Complete the receipt generation with scrolling logic
                        handleReceiptScrolling(contentList, contentItems);
                    });
                return; // Exit early since we're handling this asynchronously
            } else {
                // Fallback: generic content using CSV content system
                generateRobustFallbackContent('Content Intelligence', sessionDuration, baseRate, finalMultiplier)
                    .then(genericContent => {
                        contentItems.push(...genericContent);
                        
                        // Generate HTML for content items with points
                        const contentHTML = contentItems.map(item => `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: ${item.isError ? '#1a0000' : item.isChained ? '#1a1a00' : '#1a1a1a'}; border-radius: 3px; border: ${item.isError ? '1px solid #ff4444' : item.isChained ? '1px solid #ffaa00' : 'none'};">
                                <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'};">${item.title}</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: #888;">${item.duration}</span>
                                    <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points} pts</span>
                                </div>
                            </div>
                        `).join('');
                        
                        contentList.innerHTML = contentHTML;
                        
                        // Complete the receipt generation with scrolling logic
                        handleReceiptScrolling(contentList, contentItems);
                    });
                return; // Exit early since we're handling this asynchronously
            }
            
            // Generate HTML for content items with points
            const contentHTML = contentItems.map(item => `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px; padding: 4px; background: ${item.isError ? '#1a0000' : item.isChained ? '#1a1a00' : '#1a1a1a'}; border-radius: 3px; border: ${item.isError ? '1px solid #ff4444' : item.isChained ? '1px solid #ffaa00' : 'none'};">
                    <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'};">${item.title}</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #888;">${item.duration}</span>
                        <span style="color: ${item.isError ? '#ff4444' : item.isChained ? '#ffaa00' : '#fff'}; font-weight: 600; font-size: 11px;">+${item.points} pts</span>
                    </div>
                </div>
            `).join('');
            
            contentList.innerHTML = contentHTML;
            
            // Handle scrolling behavior for the synchronous content case
            handleReceiptScrolling(contentList, contentItems);
        }

        // Show main view (from settings only now)
        function showMainView() {
            Tracker.logRumiAction('Main view shown');
            
            // Hide settings view and show settings view
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'none';
            
            // Reset entry point state to return to home screen
            appState.entryPoint = null;
            appState.detectedShow = null;
            
            // Update UI based on current state
            updateUI();
            updatePointsDisplay();
        }

        // Update UI based on current state
        function updateUI() {
            const ctaButton = document.getElementById('cta-button');
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            const stopIndexingButton = document.getElementById('stop-indexing-button');
            const stopIndexingSubtitle = stopIndexingButton ? stopIndexingButton.nextElementSibling : null;
            const mainView = document.getElementById('main-view');
            
            // Add/remove automode class based on entry point
            if (mainView) {
                if (appState.entryPoint === 'automode') {
                    mainView.classList.add('automode');
                } else {
                    mainView.classList.remove('automode');
                }
            }

            if (appState.isIndexing) {
                // Show stop button and indexing content
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `STOP LEARNING ABOUT "${bucketName}"`;
                } else {
                ctaButton.textContent = 'STOP INDEXING';
                }
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'none';
                if(nokiaContent) nokiaContent.style.display = 'block';
                
                // Update indexing screen button
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `STOP WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `STOP LEARNING ABOUT "${bucketName}"`;
                    } else {
                    stopIndexingButton.textContent = 'STOP INDEXING';
                }
                    stopIndexingButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                }
            } else if (appState.entryPoint) {
                // Show indexing screen but with START INDEXING button (idle state)
                if (appState.entryPoint === 'detection' && appState.detectedShow) {
                    // Show detection mode: include show name, season, episode
                    const show = appState.detectedShow;
                    if (show.season !== 'N/A' && show.episode !== 'N/A') {
                        ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                    } else {
                        // For films, include the year if available
                        const year = show.year || '';
                        const yearText = year ? ` (${year})` : '';
                        ctaButton.textContent = `START WATCHING ${show.title}${yearText}`;
                    }
                } else if (appState.entryPoint === 'automode') {
                    // Automode: include the current bucket name
                    const bucketName = appState.currentBucket || 'Content Intelligence';
                    ctaButton.textContent = `HELP RUMI LEARN ABOUT "${bucketName}"`;
                } else {
                ctaButton.textContent = 'START INDEXING';
                }
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                // Show home content (leaderboard) when not indexing yet
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
                
                // Update indexing screen button (this will be shown when indexing starts)
                if(stopIndexingButton) {
                    if (appState.entryPoint === 'detection' && appState.detectedShow) {
                        // Show detection mode: include show name, season, episode
                        const show = appState.detectedShow;
                        if (show.season !== 'N/A' && show.episode !== 'N/A') {
                            stopIndexingButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                        } else {
                            // For films, include the year if available
                            const year = show.year || '';
                            const yearText = year ? ` (${year})` : '';
                            stopIndexingButton.textContent = `START WATCHING ${show.title}${yearText}`;
                        }
                    } else if (appState.entryPoint === 'automode') {
                        // Automode: include the current bucket name
                        const bucketName = appState.currentBucket || 'Content Intelligence';
                        stopIndexingButton.textContent = `HELP RUMI LEARN ABOUT "${bucketName}"`;
                    } else {
                    stopIndexingButton.textContent = 'START INDEXING';
                    }
                    stopIndexingButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                }
            } else {
                // Show start button and home content (leaderboard/queue)
                ctaButton.textContent = 'START WATCHING';
                ctaButton.className = appState.entryPoint === 'automode' ? 'primary-cta automode' : 'primary-cta';
                
                if(homeContent) homeContent.style.display = 'block';
                if(nokiaContent) nokiaContent.style.display = 'none';
            }
            
            // Update learning sections visibility and content
            updateLearningUIVisibility();
            
            updateDebugButtonStates(); // Update debug button states when UI changes
        }

        // Indexing timer for status panel
        let pointAccrualInterval;
        let indexingTimerInterval;
        let animationFrameId;
        
        // Point accrual and timer logic
        function startPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            appState.sessionStartTime = Date.now();
            appState.sessionEarnings = 0;
            appState.currentMultiplier = 1.0;
            
            // Start the animation loop
            animateSessionStats();

            // Set different base rates based on entry point
            let baseRate;
            let interval;
            
            if (appState.entryPoint === 'automode') {
                baseRate = 0.12; // 0.12 points per second for automode (20% MORE than detection mode)
                interval = 1000; // Update every second
            } else {
                baseRate = 0.1; // 0.1 points per second for show detection
                interval = 1000; // Update every second
            }

            pointAccrualInterval = setInterval(() => {
                const pointsThisInterval = baseRate * appState.currentMultiplier; // Keep for interval display
                appState.sessionEarnings += pointsThisInterval;
                Tracker.logRumiAction('Points accrued in session', {
                    amount: pointsThisInterval,
                    sessionTotal: appState.sessionEarnings,
                    baseRate: baseRate,
                    mode: appState.entryPoint
                });
                
                // Update the points display in real-time
                updatePointsDisplay();
                // Also update the holistic-progress counter in real-time
                updateAnimationPanel((Date.now() - appState.indexingStartTime) / 1000);
            }, interval);
        }

        function stopPointsEarning() {
            if (pointAccrualInterval) clearInterval(pointAccrualInterval);
            if (indexingTimerInterval) clearInterval(indexingTimerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
        }

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Enhanced Nokia animation with show indexing integration
        let currentIndexingShow = null;
        let animationUpdateInterval = null;
        let lastShowUpdate = 0;
        let lastUpdateTime = 0;

        const getTonalCharacter = (originalChar, revealProgress) => {
            if (originalChar === '#') {
                if (revealProgress > 0.85) return '#';
                if (revealProgress > 0.7) return 'X';
                if (revealProgress > 0.55) return 'O';
                if (revealProgress > 0.4) return 'o';
                return '.';
            }
            if (originalChar === '=' || originalChar === '|' || originalChar === '+' || originalChar === '/' || originalChar === '~' || originalChar === '<' || originalChar === '>' || originalChar === ':' || originalChar === '{' || originalChar === '}' || originalChar === '[' || originalChar === ']' || originalChar === '^' || originalChar === 'v' || originalChar === 'W' || originalChar === '8' || originalChar === '@' || originalChar === '0' || originalChar === '%' || originalChar === '&' || originalChar === '$') {
                 if (revealProgress > 0.8) return 'X';
                if (revealProgress > 0.65) return 'O';
                if (revealProgress > 0.5) return 'o';
                if (revealProgress > 0.35) return '.';
                return '.';
            }
            return originalChar;
        };

        function renderReveal(template, progress, width, height) {
            let display = Array(height).fill('.'.repeat(width));
            if (!template) return display;

            const allTemplateChars = [];
            for (let y = 0; y < height; y++) {
                const row = template[y] || '';
                for (let x = 0; x < width; x++) {
                    if (row[x] && row[x] !== ' ') {
                        allTemplateChars.push({ char: row[x], x, y });
                    }
                }
            }
            allTemplateChars.sort((a, b) => a.y - b.y || a.x - b.x);

            const totalPixels = allTemplateChars.length;
            const pixelsToShow = Math.floor(totalPixels * progress);
            
            for (let i = 0; i < pixelsToShow; i++) {
                const { char, x, y } = allTemplateChars[i];
                const pixelProgress = pixelsToShow > 1 ? (i / (pixelsToShow - 1)) : 1;
                let rowArray = display[y].split('');
                rowArray[x] = getTonalCharacter(char, pixelProgress);
                display[y] = rowArray.join('');
            }
            return display;
        }

        function renderCrossfade(oldTemplate, newTemplate, progress, width, height) {
            // Add null checks to prevent TypeError
            if (!oldTemplate || !newTemplate || !Array.isArray(oldTemplate) || !Array.isArray(newTemplate)) {
                return Array(height).fill('.'.repeat(width));
            }
            
            let display = Array(height).fill('.'.repeat(width));
            for (let y = 0; y < height; y++) {
                let rowArray = display[y].split('');
                for (let x = 0; x < width; x++) {
                    const oldChar = oldTemplate[y]?.[x] || ' ';
                    const newChar = newTemplate[y]?.[x] || ' ';
                    
                    const oldCharRender = (oldChar !== ' ' && oldChar !== '.') ? getTonalCharacter(oldChar, 1 - progress) : '.';
                    const newCharRender = (newChar !== ' ' && newChar !== '.') ? getTonalCharacter(newChar, progress) : '.';
                    
                    rowArray[x] = (newCharRender !== '.') ? newCharRender : oldCharRender;
                }
                display[y] = rowArray.join('');
            }
            return display;
        }

        function updateAnimationPanel(elapsedTime) {
            const holisticInfo = document.getElementById('holistic-show-info');
            const panel = document.getElementById('animation-panel-content');
            const holisticProgress = document.getElementById('holistic-progress');

            if (!panel || !holisticInfo || !holisticProgress) {
                console.warn('⚠️ Animation panel elements not ready:', {
                    panel: !!panel,
                    holisticInfo: !!holisticInfo,
                    holisticProgress: !!holisticProgress
                });
                return;
            }
            
            // Apply automode styling if no show is detected
            if (detectedShow) {
                panel.classList.remove('automode');
            } else {
                panel.classList.add('automode');
            }
            
            const width = 28;
            const height = 6;
            
            const detectedShowUI = document.getElementById('detected-show-ui-indexing');
            let showTitle = 'INDEXING';
            let showType = 'data';
            let showDetails = `Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;

            // Get current content for automode
            if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    showTitle = currentItem.title.toUpperCase();
                    showType = currentItem.intelligence_bucket ? currentItem.intelligence_bucket.toLowerCase() : 'content';
                    
                    // Create rich metadata string
                    const service = currentItem.service || 'Rumi Learning';
                    const duration = currentItem.duration || '2:30';
                    const genre = currentItem.genre || 'Learning';
                    const season = currentItem.season && currentItem.season !== 'N/A' ? `S${currentItem.season}` : '';
                    const episode = currentItem.episode && currentItem.episode !== 'N/A' ? `E${currentItem.episode}` : '';
                    const year = currentItem.year || '';
                    const type = currentItem.type || 'CLIP';
                    const bucket = currentItem.intelligence_bucket || 'CONTENT';
                    const itemPosition = `${appState.currentContentIndex + 1}/${appState.automodeContentItems.length}`;
                    
                    // Build rich metadata display
                    let richMetadata = `${service} • ${duration} • ${genre.toUpperCase()}`;
                    if (season && episode) {
                        richMetadata += ` ${season}${episode}`;
                    }
                    if (year) {
                        richMetadata += ` (${year})`;
                    }
                    richMetadata += ` [${type.toUpperCase()}] • Item ${itemPosition}`;
                    
                    showDetails = richMetadata;
                }
            } else if (detectedShowUI && detectedShowUI.style.display !== 'none' && detectedShow && detectedShow.title) {
                showTitle = detectedShow.title.toUpperCase();
                showType = detectedShow.genre ? detectedShow.genre.toLowerCase() : 'data';
                
                if (detectedShow.season !== 'N/A') {
                    showDetails = `S${detectedShow.season} E${detectedShow.episode} | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                } else {
                    showDetails = `FILM | Multiplier: ${appState.currentMultiplier.toFixed(1)}x`;
                }
            }
            
            // Update holistic info with current content
            if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    const bucket = currentItem.intelligence_bucket || 'CONTENT';
                    holisticInfo.innerHTML = `<strong>INDEXING</strong> • ${bucket.toUpperCase()}`;
                } else {
            holisticInfo.innerHTML = `<strong>INDEXING</strong>`;
                }
            } else {
                holisticInfo.innerHTML = `<strong>INDEXING</strong>`;
            }

            // Initialize ASCII Animation System
            if (!window.ASCIIAnimationState) {
                window.ASCIIAnimationState = {
                    currentPattern: null,
                    animationFrame: 0,
                    lastUpdateTime: 0,
                    refreshRate: 100, // 100ms to match standalone
                    animationInterval: null,
                    lastContentTitle: null,
                    
                    // Initialize the ASCII animation system
                    initialize() {
                        this.lastUpdateTime = Date.now();
                        this.startAnimationLoop();
                    },
                    
                    // Start the independent animation loop
                    startAnimationLoop() {
                        if (this.animationInterval) {
                            clearInterval(this.animationInterval);
                        }
                        
                        this.animationInterval = setInterval(() => {
                            this.animationFrame++;
                            this.updateDisplay();
                        }, this.refreshRate);
                    },
                    
                    // Stop the animation
                    stop() {
                        if (this.animationInterval) {
                            clearInterval(this.animationInterval);
                            this.animationInterval = null;
                        }
                    },
                    
                    // Update the display
                    updateDisplay() {
                        const panel = document.getElementById('animation-panel-content');
                        if (!panel || !appState.isIndexing) return;
                        
                        // Generate the current pattern
                        const pattern = this.generateCurrentPattern();
                        if (pattern) {
                            // Add rich metadata to the bottom line
                            const patternLines = pattern.split('\n');
                            const metadataText = this.generateMetadataText();
                            
                            // Replace the last line with scrolling metadata
                            if (patternLines.length > 0 && metadataText) {
                                patternLines[patternLines.length - 1] = metadataText;
                            }
                            
                            panel.innerHTML = patternLines.join('\n');
                        }
                    },
                    
                    // Generate rich metadata text for the bottom line
                    generateMetadataText() {
                        const content = this.getCurrentContent();
                        const width = 26; // Width for scrolling text
                        
                        if (appState.entryPoint === 'detection' && content) {
                            // Show rich metadata from CSV for detected content
                            const currentBlock = appState.currentBlockIndex + 1;
                            const totalBlocks = appState.totalBlocks || 1;
                            
                            const service = content.service || 'DETECTED';
                            const year = content.year ? ` (${content.year})` : '';
                            const seasonEpisode = (content.season && content.episode && content.season !== 'N/A') ? 
                                ` S${content.season}E${content.episode}` : '';
                            const genre = content.genre ? ` • ${content.genre}` : '';
                            const duration = content.duration ? ` • ${content.duration}min` : '';
                            const blockInfo = ` • Block ${currentBlock}/${totalBlocks}`;
                            
                            const richMetadata = `${service} • ${content.title}${seasonEpisode}${genre}${duration}${blockInfo}`;
                            return this.scrollText(richMetadata, this.animationFrame, width);
                            
                        } else if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                            // For automode, show rich CSV data from current content item
                            const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                            
                            if (currentItem && currentItem.title) {
                                let richMetadata = currentItem.title;
                                
                                // Add intelligence bucket
                                if (currentItem.intelligence_bucket && currentItem.intelligence_bucket !== 'Unknown') {
                                    richMetadata += ` • ${currentItem.intelligence_bucket.toUpperCase()}`;
                                }
                                
                                // Add service and type
                                const service = currentItem.service || 'RUMI LEARNING';
                                const type = currentItem.type || 'CLIP';
                                richMetadata += ` • ${service.toUpperCase()}`;
                                
                                // Add duration
                                if (currentItem.duration) {
                                    richMetadata += ` • ${currentItem.duration}`;
                                }
                                
                                // Add genre
                                if (currentItem.genre && currentItem.genre !== 'Unknown') {
                                    richMetadata += ` • ${currentItem.genre.toUpperCase()}`;
                                }
                                
                                // Add season/episode
                                if (currentItem.season && currentItem.episode && currentItem.season !== 'N/A' && currentItem.episode !== 'N/A') {
                                    richMetadata += ` S${currentItem.season}E${currentItem.episode}`;
                                }
                                
                                // Add year
                                if (currentItem.year && currentItem.year !== 'Unknown') {
                                    richMetadata += ` (${currentItem.year})`;
                                }
                                
                                // Add type classification
                                richMetadata += ` [${type.toUpperCase()}]`;
                                
                                // Add progress tracking
                                const currentIndex = appState.currentContentIndex + 1;
                                const totalItems = appState.automodeContentItems.length;
                                richMetadata += ` • Item ${currentIndex}/${totalItems}`;
                                
                                return this.scrollText(richMetadata, this.animationFrame, width);
            } else {
                                return this.scrollText(`LOADING CONTENT... • ${appState.currentBucket || 'RUMI LEARNING'}`, this.animationFrame, width);
                            }
                        } else {
                            return this.scrollText(`LOADING CONTENT... • ${appState.currentBucket || 'RUMI LEARNING'} • PLEASE WAIT`, this.animationFrame, width);
                        }
                    },
                    
                    // Scroll text helper function - always scrolls right to left
                    scrollText(text, frame, width) {
                        if (!text || text.length <= width) return text.padEnd(width);
                        
                        const scrollSpeed = 0.4; // Slightly faster for better visibility
                        const totalCycle = text.length + width; // Total cycle length
                        const position = Math.floor(frame * scrollSpeed) % totalCycle;
                        
                        // Right to left scrolling: text moves from right edge to left edge
                        if (position < text.length) {
                            // Text is moving across the display
                            const startPos = position;
                            const endPos = Math.min(startPos + width, text.length);
                            let displayText = text.substring(startPos, endPos);
                            
                            // Pad with spaces if needed
                            if (displayText.length < width) {
                                displayText = displayText.padEnd(width);
                            }
                            
                            return displayText;
                        } else {
                            // Gap phase - showing spaces before text loops
                            const gapPosition = position - text.length;
                            const spacesToShow = Math.min(gapPosition, width);
                            const textToShow = Math.max(0, width - spacesToShow);
                            
                            let displayText = ' '.repeat(spacesToShow);
                            if (textToShow > 0) {
                                displayText += text.substring(0, textToShow);
                            }
                            
                            return displayText.substring(0, width);
                        }
                    },
                    
                    // Generate the current pattern based on content
                    generateCurrentPattern() {
                        if (!this.currentPattern) {
                            this.currentPattern = this.determinePattern();
                        }
                        
                        // Get the pattern function
                        const patternFunction = this.getPatternFunction(this.currentPattern);
                        if (!patternFunction) return null;
                        
                        // Generate the pattern with current frame
                        return patternFunction(this.animationFrame);
                    },
                    
                    // Determine which pattern to use based on content
                    determinePattern() {
                        const content = this.getCurrentContent();
                        
                        // Apply mapping logic from the graph
                        
                        // 1. Check Intelligence Bucket first
                        if (appState.entryPoint === 'automode') {
                            const bucket = appState.currentBucket;
                            if (bucket && bucket.includes('Scene')) return 'wave';
                            if (bucket && bucket.includes('Intelligence')) return 'matrix';
                            if (bucket && bucket.includes('Story')) return 'spiral';
                            if (bucket && bucket.includes('Character')) return 'fractal';
                        }
                        
                        // 2. Check Genre
                        if (content && content.genre) {
                            const genre = content.genre.toLowerCase();
                            if (genre.includes('comedy')) return 'pulse';
                            if (genre.includes('drama')) return 'tunnel';
                            if (genre.includes('mystery') || genre.includes('thriller')) return 'vortex';
                            if (genre.includes('horror')) return 'lightning';
                            if (genre.includes('sci-fi') || genre.includes('scifi')) return 'matrix';
                            if (genre.includes('fantasy')) return 'mandala';
                            if (genre.includes('documentary')) return 'crystal';
                            if (genre.includes('action') || genre.includes('superhero')) return 'fireworks';
                        }
                        
                        // 3. Check Duration for animation speed
                        if (content && content.duration) {
                            const duration = parseInt(content.duration);
                            if (duration >= 2 && duration <= 4) return 'pulse'; // Fast
                            if (duration >= 5 && duration <= 8) return 'wave'; // Medium
                            if (duration >= 9) return 'spiral'; // Slow
                        }
                        
                        // 4. Default patterns for automode vs detected
                        if (appState.entryPoint === 'automode') {
                            return 'matrix'; // Default for automode
                            } else {
                            return 'wave'; // Default for detected shows
                        }
                    },
                    
                    // Get current content information
                    getCurrentContent() {
                        if (detectedShow) {
                            return {
                            title: detectedShow.title,
                                genre: detectedShow.genre,
                                duration: detectedShow.duration,
                                service: detectedShow.service
                            };
                        }
                        
                        if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                            const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                            return {
                                title: currentItem.title,
                                genre: currentItem.genre,
                                duration: currentItem.duration,
                                service: currentItem.service
                            };
                        }
                        
                        return null;
                    },
                    
                    // Get the pattern generation function
                    getPatternFunction(patternName) {
                        const patterns = {
                            'wave': (frame) => this.generateWave(40, 6, frame),
                            'matrix': (frame) => this.generateMatrix(40, 6, frame),
                            'spiral': (frame) => this.generateSpiral(30, frame),
                            'fractal': (frame) => this.generateFractal(27, frame),
                            'pulse': (frame) => this.generatePulse(27, frame),
                            'tunnel': (frame) => this.generateTunnel(25, frame),
                            'vortex': (frame) => this.generateVortex(25, frame),
                            'lightning': (frame) => this.generateLightning(40, 6, frame),
                            'mandala': (frame) => this.generateMandala(25, frame),
                            'crystal': (frame) => this.generateCrystal(23, frame),
                            'fireworks': (frame) => this.generateFireworks(40, 6, frame),
                            'galaxy': (frame) => this.generateGalaxy(30, frame),
                            'plasma': (frame) => this.generatePlasma(40, 6, frame),
                            'diamond': (frame) => this.generateDiamond(23, frame),
                            'circle': (frame) => this.generateCircle(30, frame),
                            'hexagon': (frame) => this.generateHexagon(25, frame),
                            'star': (frame) => this.generateStar(25, frame),
                            'maze': (frame) => this.generateMaze(28, 6, frame),
                            'dna': (frame) => this.generateDNA(40, 6, frame),
                            'atom': (frame) => this.generateAtom(25, frame),
                            'infinity': (frame) => this.generateInfinity(40, 6, frame)
                        };
                        
                        return patterns[patternName];
                    },
                    
                    // Reset pattern selection (called when content changes)
                    resetPattern() {
                        this.currentPattern = null;
                        this.animationFrame = 0;
                    },
                    
                    // Generate Wave pattern (resized for panel)
                    generateWave(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const wave1 = Math.sin((x + frame) * 0.2) * 1.5;
                                const wave2 = Math.sin((x + frame) * 0.3) * 1;
                                const waveY = Math.floor(height / 2 + wave1 + wave2);
                                
                                if (Math.abs(y - waveY) <= 0.5) {
                                    const chars = ['~', '≈', '∼', '⌇'];
                                    const charIndex = (Math.floor(frame / 3) + x) % chars.length;
                                    line += chars[charIndex];
                                } else if (y > waveY) {
                                    const fillChars = ['▒', '░', '▓', '█'];
                                    const fillIndex = (Math.floor(frame / 5) + x + y) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Matrix pattern (resized for panel)
                    generateMatrix(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        const chars = ['0', '1', '█', '▓', '▒', '░', '●', '○', '◉', '◎'];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const seed = x * 7 + y * 13 + Math.floor(frame / 3);
                                const charIndex = (seed * 31) % chars.length;
                                const intensity = Math.sin(seed * 0.1 + frame * 0.05) * 0.5 + 0.5;
                                
                                if (intensity > 0.7) {
                                    line += chars[charIndex];
                                } else if (intensity > 0.4) {
                                    line += chars[charIndex % 4];
                            } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Spiral pattern (resized for panel)
                    generateSpiral(size = 30, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                const spiralValue = (angle + distance * 0.3 + frame * 0.1) % (Math.PI * 2);
                                
                                if (Math.abs(spiralValue - Math.PI) < 0.5) {
                                    const chars = ['◉', '◎', '●', '○'];
                                    const charIndex = Math.floor(distance + frame / 4) % chars.length;
                                    line += chars[charIndex];
                                } else if (spiralValue < Math.PI) {
                                    const fillChars = ['▓', '▒', '░', ' '];
                                    const fillIndex = Math.floor(spiralValue * 2 + frame / 6) % fillChars.length;
                                    line += fillChars[fillIndex];
                        } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Fractal pattern (resized for panel)
                    generateFractal(size = 27, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = (x - 20) / 20;
                                const dy = (y - center) / 10;
                                
                                let zx = dx;
                                let zy = dy;
                                let iterations = 0;
                                const maxIterations = 10;
                                
                                while (zx * zx + zy * zy < 4 && iterations < maxIterations) {
                                    const temp = zx * zx - zy * zy + dx + Math.sin(frame * 0.01);
                                    zy = 2 * zx * zy + dy + Math.cos(frame * 0.01);
                                    zx = temp;
                                    iterations++;
                                }
                                
                                const chars = ['█', '▓', '▒', '░', '▫', '▪', '·', ' '];
                                const charIndex = Math.floor(iterations / maxIterations * chars.length);
                                line += chars[Math.min(charIndex, chars.length - 1)];
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Pulse pattern (resized for panel)
                    generatePulse(size = 27, frame = 0) {
                        const lines = [];
                        const center = 3;
                        const pulseRadius = Math.abs(Math.sin(frame * 0.1)) * 15;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (Math.abs(distance - pulseRadius) < 2) {
                                    const chars = ['◉', '◎', '●', '○'];
                                    const charIndex = Math.floor(frame / 5) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < pulseRadius) {
                                    const fillChars = ['▓', '▒', '░', ' '];
                                    const fillIndex = Math.floor(distance + frame / 4) % fillChars.length;
                                    line += fillChars[fillIndex];
                    } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Tunnel pattern (resized for panel)
                    generateTunnel(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                const tunnelDepth = Math.floor(distance + frame * 0.5) % 8;
                                const tunnelChars = ['█', '▓', '▒', '░', '▫', '▪', '·', ' '];
                                
                                if (distance < 15) {
                                    line += tunnelChars[tunnelDepth];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Vortex pattern (resized for panel)
                    generateVortex(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                const vortexAngle = angle + distance * 0.3 + frame * 0.1;
                                
                                if (distance < 15) {
                                    const chars = ['◐', '◑', '◒', '◓', '●', '○'];
                                    const charIndex = Math.floor(vortexAngle * 2 + frame / 3) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Lightning pattern (resized for panel)
                    generateLightning(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const lightning = Math.sin(x * 0.3 + frame * 0.2) * Math.sin(y * 0.2 + frame * 0.1);
                                const bolt = Math.random() < 0.1 && Math.abs(lightning) > 0.7;
                                
                                if (bolt) {
                                    const chars = ['⚡', '✦', '✧', '✩', '※', '⋆'];
                                    const charIndex = Math.floor(Math.random() * chars.length);
                                    line += chars[charIndex];
                                } else if (Math.abs(lightning) > 0.5) {
                                    const chars = ['▓', '▒', '░', '·'];
                                    const charIndex = Math.floor(Math.abs(lightning) * 4) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Mandala pattern (resized for panel)
                    generateMandala(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx) + Math.PI;
                                
                                const mandalaAngle = (angle + frame * 0.01) % (Math.PI / 4);
                                const mandalaRadius = Math.sin(mandalaAngle * 8) * 3 + Math.cos(distance * 0.5 + frame * 0.02) * 2;
                                
                                if (distance < 15 && Math.abs(mandalaRadius) > 1) {
                                    const chars = ['◉', '◎', '●', '○', '◐', '◑', '◒', '◓'];
                                    const charIndex = Math.floor(angle * 4 + frame / 3) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < 15) {
                                    const chars = ['▓', '▒', '░', '·'];
                                    const charIndex = Math.floor(distance + frame / 5) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Crystal pattern (resized for panel)
                    generateCrystal(size = 23, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                
                                if ((dx + dy + frame) % 6 === 0 || (dx - dy + frame) % 6 === 0) {
                                    const chars = ['◊', '◈', '◇', '♦', '♢', '⬟'];
                                    const charIndex = Math.floor(Math.sqrt(dx*dx + dy*dy) + frame / 4) % chars.length;
                                    line += chars[charIndex];
                                } else if (Math.abs(dx % 3) + Math.abs(dy % 3) < 2) {
                                    const fillChars = ['▓', '▒', '░', '·'];
                                    const fillIndex = Math.floor(frame / 6) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Fireworks pattern (resized for panel)
                    generateFireworks(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const explosion1 = Math.sin((x - 10) * 0.3 + frame * 0.2) * Math.sin((y - 2) * 0.3 + frame * 0.15);
                                const explosion2 = Math.sin((x - 30) * 0.25 + frame * 0.18) * Math.sin((y - 4) * 0.25 + frame * 0.12);
                                
                                const combined = explosion1 + explosion2;
                                
                                if (Math.abs(combined) > 1.5) {
                                    const chars = ['✦', '✧', '✩', '✪', '⋆', '★', '※', '⚡'];
                                    const charIndex = Math.floor(Math.abs(combined) * 3 + frame / 2) % chars.length;
                                    line += chars[charIndex];
                                } else if (Math.abs(combined) > 0.8) {
                                    const chars = ['▓', '▒', '░', '·'];
                                    const charIndex = Math.floor(Math.abs(combined) * 4) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Galaxy pattern (resized for panel)
                    generateGalaxy(size = 30, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                const armAngle = angle + distance * 0.2 + frame * 0.02;
                                const armRadius = Math.sin(armAngle * 2) * 3 + distance;
                                
                                if (distance < 15) {
                                    if (Math.abs(armRadius - distance) < 2) {
                                        const chars = ['✦', '✧', '✩', '✪', '⋆', '★'];
                                        const charIndex = Math.floor(armAngle + frame / 4) % chars.length;
                                        line += chars[charIndex];
                                    } else {
                                        const chars = ['·', '▪', '▫', ' '];
                                        const charIndex = Math.floor(distance / 3) % chars.length;
                                        line += chars[charIndex];
                                    }
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Plasma pattern (resized for panel)
                    generatePlasma(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const plasma = Math.sin(x * 0.1 + frame * 0.05) +
                                              Math.sin(y * 0.1 + frame * 0.03) +
                                              Math.sin((x + y) * 0.05 + frame * 0.02) +
                                              Math.sin(Math.sqrt(x * x + y * y) * 0.1 + frame * 0.04);
                                
                                const intensity = (plasma + 4) / 8;
                                const chars = [' ', '·', '▪', '▫', '░', '▒', '▓', '█'];
                                const charIndex = Math.floor(intensity * chars.length);
                                line += chars[Math.min(charIndex, chars.length - 1)];
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Diamond pattern (resized for panel)
                    generateDiamond(size = 23, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = Math.abs(x - 20);
                                const dy = Math.abs(y - center);
                                const distance = dx + dy;
                                
                                if (distance === 15) {
                                    const chars = ['◆', '◇', '♦', '♢'];
                                    const charIndex = (Math.floor(frame / 4) + x + y) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < 15) {
                                    const fillChars = ['▲', '▼', '◄', '►'];
                                    const fillIndex = (Math.floor(frame / 6) + distance) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Circle pattern (resized for panel)
                    generateCircle(size = 30, frame = 0) {
                        const lines = [];
                        const center = Math.floor(size / 2);
                        const radius = center - 2;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - 3) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (Math.abs(distance - radius) < 2) {
                                    const chars = ['█', '▓', '▒', '░'];
                                    const charIndex = (Math.floor(frame / 5) + Math.floor(distance)) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < radius - 2) {
                                    const fillChars = ['●', '◉', '◯', '○'];
                                    const fillIndex = (Math.floor(frame / 3) + x + y) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Hexagon pattern (resized for panel)
                    generateHexagon(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                
                                const angle = Math.atan2(dy, dx) + Math.PI;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const hexRadius = 12;
                                
                                const sideAngle = Math.floor(angle / (Math.PI / 3));
                                const hexDistance = Math.abs(Math.cos((angle - sideAngle * Math.PI / 3) * 3)) * hexRadius;
                                
                                if (Math.abs(distance - hexDistance) < 1.5) {
                                    const chars = ['⬡', '⬢', '⬣', '◯'];
                                    const charIndex = (Math.floor(frame / 6) + sideAngle) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < hexDistance) {
                                    const fillChars = ['▲', '▼', '◄', '►', '♦', '◆'];
                                    const fillIndex = (Math.floor(frame / 4) + Math.floor(distance)) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Star pattern (resized for panel)
                    generateStar(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const angle = Math.atan2(dy, dx) + Math.PI;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                const starAngle = (angle + frame * 0.02) % (Math.PI * 2);
                                const starRadius = 12;
                                const innerRadius = starRadius * 0.4;
                                
                                const starPoint = Math.floor(starAngle / (Math.PI * 2 / 10));
                                const isOuter = starPoint % 2 === 0;
                                const targetRadius = isOuter ? starRadius : innerRadius;
                                
                                if (Math.abs(distance - targetRadius) < 2) {
                                    const chars = ['★', '☆', '✦', '✧', '✩', '✪'];
                                    const charIndex = (Math.floor(frame / 5) + starPoint) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < targetRadius) {
                                    const fillChars = ['▓', '▒', '░', '·'];
                                    const fillIndex = (Math.floor(frame / 7) + starPoint) % fillChars.length;
                                    line += fillChars[fillIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Maze pattern (resized for panel)
                    generateMaze(width = 28, height = 6, frame = 0) {
                        const lines = [];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const pattern = (x + y + Math.floor(frame / 10)) % 4;
                                const isWall = (x % 3 === 0 && y % 2 === 0) || 
                                              (x % 2 === 0 && y % 3 === 0) ||
                                              (pattern === 0 && (x + y) % 5 === 0);
                                
                                if (isWall) {
                                    const wallChars = ['█', '▓', '▒', '░'];
                                    const wallIndex = (Math.floor(frame / 8) + x + y) % wallChars.length;
                                    line += wallChars[wallIndex];
                                } else {
                                    const pathChars = ['·', '•', '◦', ' '];
                                    const pathIndex = (Math.floor(frame / 12) + pattern) % pathChars.length;
                                    line += pathChars[pathIndex];
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate DNA pattern (resized for panel)
                    generateDNA(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const helix1 = Math.sin(x * 0.3 + frame * 0.1) * 1.5 + 3;
                                const helix2 = Math.sin(x * 0.3 + Math.PI + frame * 0.1) * 1.5 + 3;
                                
                                if (Math.abs(y - helix1) < 0.5) {
                                    const chars = ['◉', '●', '○', '◎'];
                                    const charIndex = Math.floor(x / 3 + frame / 4) % chars.length;
                                    line += chars[charIndex];
                                } else if (Math.abs(y - helix2) < 0.5) {
                                    const chars = ['◐', '◑', '◒', '◓'];
                                    const charIndex = Math.floor(x / 3 + frame / 4) % chars.length;
                                    line += chars[charIndex];
                                } else if (Math.abs(helix1 - helix2) < 2 && Math.abs(y - (helix1 + helix2) / 2) < 0.5) {
                                    const chars = ['─', '═', '━', '▬'];
                                    const charIndex = Math.floor(x / 2 + frame / 3) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Atom pattern (resized for panel)
                    generateAtom(size = 25, frame = 0) {
                        const lines = [];
                        const center = 3;
                        
                        for (let y = 0; y < 6; y++) {
                            let line = '';
                            for (let x = 0; x < 40; x++) {
                                const dx = x - 20;
                                const dy = (y - center) * 2;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                const angle = Math.atan2(dy, dx);
                                
                                if (distance < 2) {
                                    const chars = ['◉', '◎', '●'];
                                    const charIndex = Math.floor(frame / 5) % chars.length;
                                    line += chars[charIndex];
                                } else if (Math.abs(distance - 5) < 1 || Math.abs(distance - 8) < 1 || Math.abs(distance - 12) < 1) {
                                    const orbitAngle = angle + frame * 0.1;
                                    const electronPos = Math.sin(orbitAngle * 3) * 0.5;
                                    if (Math.abs(electronPos) < 0.3) {
                                        const chars = ['◦', '•', '○', '●'];
                                        const charIndex = Math.floor(distance / 4 + frame / 3) % chars.length;
                                        line += chars[charIndex];
                                    } else {
                                        const chars = ['·', '▪', '▫', ' '];
                                        const charIndex = Math.floor(distance / 6) % chars.length;
                                        line += chars[charIndex];
                                    }
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    },
                    
                    // Generate Infinity pattern (resized for panel)
                    generateInfinity(width = 40, height = 6, frame = 0) {
                        const lines = [];
                        const centerY = 3;
                        
                        for (let y = 0; y < height; y++) {
                            let line = '';
                            for (let x = 0; x < width; x++) {
                                const t = (x - width / 2) * 0.1 + frame * 0.05;
                                const infinityX = Math.sin(t) * 8 + width / 2;
                                const infinityY = Math.sin(t * 2) * 1.5 + centerY;
                                
                                const distance = Math.sqrt((x - infinityX) * (x - infinityX) + (y - infinityY) * (y - infinityY));
                                
                                if (distance < 1.5) {
                                    const chars = ['∞', '◉', '●', '○'];
                                    const charIndex = Math.floor(t * 2 + frame / 4) % chars.length;
                                    line += chars[charIndex];
                                } else if (distance < 2.5) {
                                    const chars = ['▓', '▒', '░', '·'];
                                    const charIndex = Math.floor(distance + frame / 6) % chars.length;
                                    line += chars[charIndex];
                                } else {
                                    line += ' ';
                                }
                            }
                            lines.push(line);
                        }
                        return lines.join('\n');
                    }
                };
                
                // Initialize when first accessed
                ASCIIAnimationState.initialize();
            }
            
            // Initialize ASCII animation system if not already done
            if (!ASCIIAnimationState.animationInterval) {
                ASCIIAnimationState.initialize();
            }
            
            // Check for content changes and reset ASCII pattern
            const currentContent = ASCIIAnimationState.getCurrentContent();
            if (currentContent && currentContent.title !== ASCIIAnimationState.lastContentTitle) {
                ASCIIAnimationState.resetPattern();
                ASCIIAnimationState.lastContentTitle = currentContent.title;
            }
            
            // Skip the legacy fallback system - let ASCIIAnimationState handle the display
            // The sophisticated pattern system should take precedence
            console.log('🎯 ASCII Animation System: Using 21-pattern system for content display');
            
            // The ASCII animation panel is now handled by ASCIIAnimationState.updateDisplay()
            // which runs independently every 100ms with sophisticated pattern mapping
            
            // Legacy template code has been disabled - sophisticated patterns are used instead

            let bottomText = '';
            if (appState.entryPoint === 'detection' && detectedShow) {
                // Show rich metadata from CSV for detected content
                const currentBlock = appState.currentBlockIndex + 1;
                const totalBlocks = appState.totalBlocks || 1;
                
                // Create rich metadata display with all available information
                const service = detectedShow.service || 'DETECTED';
                const year = detectedShow.year ? ` (${detectedShow.year})` : '';
                const seasonEpisode = (detectedShow.season && detectedShow.episode && detectedShow.season !== 'N/A') ? 
                    ` S${detectedShow.season}E${detectedShow.episode}` : '';
                const episodeTitle = detectedShow.episode_title ? ` • ${detectedShow.episode_title}` : '';
                const genre = detectedShow.genre ? ` • ${detectedShow.genre}` : '';
                const duration = detectedShow.duration ? ` • ${detectedShow.duration}min` : '';
                const blockInfo = ` • Block ${currentBlock}/${totalBlocks}`;
                
                // Format: "Netflix • Breaking Bad S1E1 • Pilot • Drama • 47min • Block 1/3"
                const richMetadata = `${service} • ${detectedShow.title}${seasonEpisode}${episodeTitle}${genre}${duration}${blockInfo}`;
                
                // Scroll this rich metadata text
                bottomText = scrollText(richMetadata, elapsedTime, width - 2);
            } else if (appState.entryPoint === 'automode') {
                // For automode, show rich CSV data from current content item
                if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                        const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                        
                        if (currentItem && currentItem.title) {
                        // Create comprehensive metadata string using CSV data
                        let richMetadata = currentItem.title;
                        
                        // Add intelligence bucket (primary learning category)
                        if (currentItem.intelligence_bucket && currentItem.intelligence_bucket !== 'Unknown') {
                            richMetadata += ` • ${currentItem.intelligence_bucket.toUpperCase()}`;
                        }
                        
                        // Add service and type information
                        const service = currentItem.service || 'RUMI LEARNING';
                        const type = currentItem.type || 'CLIP';
                        richMetadata += ` • ${service.toUpperCase()}`;
                        
                        // Add duration information with format
                        if (currentItem.duration) {
                            richMetadata += ` • ${currentItem.duration}`;
                        }
                        
                        // Add genre for content classification
                        if (currentItem.genre && currentItem.genre !== 'Unknown') {
                            richMetadata += ` • ${currentItem.genre.toUpperCase()}`;
                        }
                        
                        // Add season/episode info if available
                        if (currentItem.season && currentItem.episode && currentItem.season !== 'N/A' && currentItem.episode !== 'N/A') {
                            richMetadata += ` S${currentItem.season}E${currentItem.episode}`;
                        }
                        
                        // Add year for temporal context
                        if (currentItem.year && currentItem.year !== 'Unknown') {
                            richMetadata += ` (${currentItem.year})`;
                        }
                        
                        // Add content type classification
                        richMetadata += ` [${type.toUpperCase()}]`;
                        
                        // Calculate current item index for progress tracking
                        const currentIndex = appState.currentContentIndex + 1;
                        const totalItems = appState.automodeContentItems.length;
                        richMetadata += ` • Item ${currentIndex}/${totalItems}`;
                        
                        bottomText = scrollText(richMetadata, elapsedTime, width - 2);
                                } else {
                        // Handle case where current item exists but has no title
                        bottomText = scrollText(`LOADING CONTENT... • ${appState.currentBucket || 'RUMI LEARNING'}`, elapsedTime, width - 2);
                                }
                            } else {
                    // Handle case where automode content is still loading
                    bottomText = scrollText(`LOADING CONTENT... • ${appState.currentBucket || 'RUMI LEARNING'} • PLEASE WAIT`, elapsedTime, width - 2);
                            }
                        } else {
                // Fallback for other entry points
                if (detectedShow && detectedShow.title) {
                    bottomText = scrollText(detectedShow.title, elapsedTime, width - 2);
                } else {
                    bottomText = '';
                }
            }

            // Legacy display code disabled - ASCIIAnimationState handles the animation panel
            // The sophisticated pattern system updates the panel independently
            // bottomText (metadata) is now handled by the ASCII system itself

            // --- Progress Bar Logic (Using Centralized Time System) ---
            const sessionDuration = TimeSystem.getSessionDuration();
            const barWidth = 28;

            // Calculate progress using centralized system
            const progress = TimeSystem.getProgress();
            const filledWidth = Math.floor(progress * barWidth);
            let progressBar = '█'.repeat(filledWidth);
            let placeholder = '░'.repeat(barWidth - filledWidth);
            
            console.log('🔍 Progress bar state:', {
                sessionDuration: sessionDuration,
                progress: progress,
                filledWidth: filledWidth,
                progressBar: progressBar,
                placeholder: placeholder
            });
            
            // Define multiplier milestones dynamically based on session duration
            const multiplierMilestones = calculateDynamicMultiplierMilestones(sessionDuration);
            
            // Add glints for each milestone with unique colors for each diamond
            let glintColors = [];
            
            // Define unique color palettes for each mode
            const automodeColors = [
                '#ffff00', // Bright Yellow
                '#ffaa00', // Orange
                '#ff6600', // Red-Orange
                '#a985ff', // Purple
                '#00ccff', // Cyan
                '#ff00ff', // Magenta
                '#90ee90', // Light Green
                '#ff69b4', // Hot Pink
                '#ffd700', // Gold
                '#00ffff'  // Aqua
            ];
            
            const detectionColors = [
                '#00ff41', // Bright Green
                '#ffaa00', // Orange
                '#ff6600', // Red-Orange
                '#a985ff', // Purple
                '#00ccff', // Cyan
                '#ff00ff', // Magenta
                '#ffff00', // Yellow
                '#ff69b4', // Hot Pink
                '#ffd700', // Gold
                '#00ffff'  // Aqua
            ];
            
            const colorPalette = (appState.entryPoint === 'automode') ? automodeColors : detectionColors;
            
            multiplierMilestones.forEach((milestone, index) => {
                if (index === 0) return; // Skip the starting milestone
                
                const milestonePosition = Math.floor(milestone.time * barWidth);
                
                // Assign unique color to each diamond based on its position
                const colorIndex = (index - 1) % colorPalette.length;
                const glintColor = colorPalette[colorIndex];
                
                if (elapsedTime < (milestone.time * sessionDuration)) {
                    // Milestone not yet reached - show glint in placeholder
                    if (milestonePosition > filledWidth) {
                let placeholderArray = placeholder.split('');
                        const glintIndex = milestonePosition - filledWidth - 1;
                if (glintIndex >= 0 && glintIndex < placeholderArray.length) {
                            placeholderArray[glintIndex] = '◆';
                            glintColors[filledWidth + glintIndex] = glintColor;
                }
                placeholder = placeholderArray.join('');
            }
                } else {
                    // Milestone reached - show glint in filled bar
                    if (milestonePosition <= filledWidth) {
                let barArray = progressBar.split('');
                        if (milestonePosition - 1 < barArray.length) {
                            barArray[milestonePosition - 1] = '◆';
                            glintColors[milestonePosition - 1] = glintColor;
                }
                progressBar = barArray.join('');
            }
                }
            });
            
            progressBar += placeholder;

            const runningTime = TimeSystem.formatTime(elapsedTime);
            
            // Create colored progress bar with individual character spans
            // NEW: Enhanced progress bar color logic with smooth transitions
            let currentProgressColor = (appState.entryPoint === 'automode') ? '#ffff00' : '#00ff41'; // Default colors
            
            // Create array of passed diamond colors for smooth transitions
            let passedDiamondColors = [];
            for (let i = 0; i < filledWidth; i++) {
                if (progressBar[i] === '◆' && glintColors[i]) {
                    passedDiamondColors.push({
                        position: i,
                        color: glintColors[i]
                    });
                }
            }
            
            // If we've passed diamonds, use the most recent one for current progress color
            if (passedDiamondColors.length > 0) {
                currentProgressColor = passedDiamondColors[passedDiamondColors.length - 1].color;
            }
            
            let visualProgressBar = '';
            for (let i = 0; i < progressBar.length; i++) {
                const char = progressBar[i];
                let color;
                
                if (char === '◆') {
                    // Diamond character with specific color and enhanced glow
                    color = glintColors[i] || currentProgressColor;
                    visualProgressBar += `<span style="color: ${color}; text-shadow: 0 0 6px ${color}, 0 0 3px ${color}; font-weight: bold; animation: pulse 2s ease-in-out infinite;">${char}</span>`;
                } else if (char === '█') {
                    // Filled progress character - use color based on passed diamonds
                    let segmentColor = currentProgressColor;
                    
                    // Check if this position is after any passed diamond
                    for (let diamond of passedDiamondColors) {
                        if (i > diamond.position) {
                            segmentColor = diamond.color;
                        }
                    }
                    
                    visualProgressBar += `<span style="color: ${segmentColor}; text-shadow: 0 0 2px ${segmentColor};">${char}</span>`;
                } else {
                    // Placeholder character - enhanced diamond previews
                    if (glintColors[i]) {
                        // Unfilled diamond with preview glow
                        visualProgressBar += `<span style="color: ${glintColors[i]}; text-shadow: 0 0 4px ${glintColors[i]}; opacity: 0.8;">${char}</span>`;
                    } else {
                        // Regular unfilled character
                        visualProgressBar += `<span style="color: #666;">${char}</span>`;
                    }
                }
            }
            
            // Show timeline scaling info for long sessions
            const sessionDurationMinutes = sessionDuration / 60;
            let timelineInfo = '';
            if (sessionDurationMinutes > 180) {
                const scaleFactor = sessionDurationMinutes / 180;
                const maxMultiplier = Math.min(1.0 + (scaleFactor * 0.8), 3.0);
                timelineInfo = `<div style='text-align:center; font-size:10px; color: #ffaa00; margin-top: 2px;'>Extended Timeline: ${sessionDurationMinutes.toFixed(0)}min (Max ${maxMultiplier.toFixed(1)}x)</div>`;
            }
            
            holisticProgress.innerHTML = `
                <div style='text-align:center; font-size:13px; font-weight:bold; margin-bottom: 4px; color: #fff;'>${runningTime}</div>
                <div style='text-align:center; font-family: monospace; font-size: 12px; color: #fff;'>${visualProgressBar}</div>
                ${timelineInfo}
            `;
            
            // Debug logging for progress bar (production-ready)
            console.log('🔍 Progress bar updated:', {
                runningTime: runningTime,
                progress: (progress * 100).toFixed(1) + '%',
                sessionDuration: Math.floor(sessionDuration / 60) + 'min',
                elapsedTime: Math.floor(elapsedTime / 60) + 'min'
            });
        }

        // Update points display
        function updatePointsDisplay() {
            const primaryDisplay = document.getElementById('points-primary-display');
            const secondaryDisplay = document.getElementById('points-secondary-display');
            
            if (!primaryDisplay || !secondaryDisplay) return;

            if (appState.isIndexing) {
                // Calculate real-time session points during indexing with fast mode support
                let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Handle fast mode time calculation (same logic as animation loop)
                if (appState.fastMode && appState.fastMode.active) {
                    if (appState.fastMode.mode === 'automode') {
                        // Auto mode fast mode: time is already accelerated via indexingStartTime adjustment
                        elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    } else if (appState.fastMode.mode === 'detection') {
                        // Detection mode fast mode: calculate accelerated time based on content navigation
                        const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        
                        if (appState.fastMode.isInFinalSeconds) {
                            // During final seconds, show normal time progression
                            elapsedTime = baseElapsedTime;
                        } else {
                            // When skipping through content, show accelerated time
                            const contentIndex = appState.fastMode.currentContentIndex || 0;
                            const averageContentDuration = 45 * 60; // 45 minutes in seconds
                            const timeFromFastSkipping = contentIndex * averageContentDuration;
                            elapsedTime = baseElapsedTime + timeFromFastSkipping;
                        }
                    }
                }
                
                const realTimeSessionPoints = calculatePointsWithMultipliers(elapsedTime, appState.baseRate || (appState.entryPoint === 'automode' ? 0.12 : 0.1), TimeSystem.getSessionDuration());
                
                // NEW FORMAT for sections 3a and 3b during indexing:
                // Line 1: Current session points
                // Line 2: Today's pending points
                primaryDisplay.textContent = `+${realTimeSessionPoints.toFixed(1)} SESSION POINTS @ ${appState.currentMultiplier.toFixed(1)}x`;
                secondaryDisplay.textContent = `+${Math.floor(appState.totalPendingPoints).toLocaleString()} pending from today`;

            } else {
                // Default view: Total earned is primary
                primaryDisplay.textContent = `${Math.floor(appState.pointsEarned).toLocaleString()} LIFETIME POINTS`;
                secondaryDisplay.textContent = `+${Math.floor(appState.totalPendingPoints).toLocaleString()} pending from today`;
            }
        }

        // Legacy function for compatibility
        function startWatching() {
            toggleIndexing();
        }

        // Test functions
        function testHomeScreen() {
            console.log('testHomeScreen called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testHomeScreenFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        function testChannels() {
            console.log('testChannels called');
            if (typeof Tracker !== 'undefined') {
                Tracker.testChannelsFlow();
            } else {
                console.error('Tracker not available');
            }
        }

        // NEW: Test function to verify end-of-content receipt functionality
        function testEndOfContentReceipt() {
            console.log('🧪 Testing end-of-content receipt functionality...');
            
            if (!appState.isIndexing) {
                console.log('❌ Test requires active indexing session');
                return;
            }
            
            // Simulate reaching the end of content by setting current index to last item
            if (appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                const originalIndex = appState.currentContentIndex;
                const lastIndex = appState.automodeContentItems.length - 1;
                
                console.log(`📊 Current content index: ${originalIndex}, Last index: ${lastIndex}`);
                console.log(`📊 Total content items: ${appState.automodeContentItems.length}`);
                
                // Set to last item and trigger completion
                appState.currentContentIndex = lastIndex;
                appState.contentItemStartTime = (Date.now() - appState.indexingStartTime) / 1000;
                
                // Simulate finishing the last item by calling moveToNextContentItem
                console.log('🎬 Simulating completion of last content item...');
                moveToNextContentItem((Date.now() - appState.indexingStartTime) / 1000);
                
                console.log('✅ End-of-content test completed - receipt should appear in 2 seconds');
            } else {
                console.log('❌ No content items available for testing');
            }
        }

        // NEW: Test function to verify dynamic timeline scaling
        function testDynamicTimelineScaling() {
            console.log('🧪 Testing dynamic timeline scaling...');
            
            // Test different session durations
            const testDurations = [
                { minutes: 90, description: "Short session (90 min)" },
                { minutes: 180, description: "Standard session (180 min)" },
                { minutes: 300, description: "Long session (300 min)" },
                { minutes: 480, description: "Very long session (480 min)" }
            ];
            
            testDurations.forEach((test, index) => {
                setTimeout(() => {
                    const sessionDurationSeconds = test.minutes * 60;
                    const milestones = calculateDynamicMultiplierMilestones(sessionDurationSeconds);
                    
                    console.log(`\n🎯 ${test.description}:`);
                    console.log(`   Duration: ${test.minutes} minutes`);
                    console.log(`   Milestones: ${milestones.length}`);
                    console.log(`   Max multiplier: ${Math.max(...milestones.map(m => m.multiplier)).toFixed(1)}x`);
                    
                    milestones.forEach((milestone, i) => {
                        const timeMinutes = (milestone.time * test.minutes).toFixed(0);
                        console.log(`   ${timeMinutes}min: ${milestone.multiplier.toFixed(1)}x`);
                    });
                    
                    if (index === testDurations.length - 1) {
                        console.log('\n✅ Dynamic timeline scaling test completed');
                    }
                }, index * 1000);
            });
        }

        // NEW: Comprehensive test for fast mode progress updates
        function testFastModeProgressUpdates() {
            console.log('🧪 Testing Fast Mode Progress Updates...');
            
            if (!appState.isIndexing) {
                console.log('❌ Test requires active indexing session. Start indexing first.');
                return;
            }
            
            const originalFastMode = appState.fastMode;
            const originalIndexingStartTime = appState.indexingStartTime;
            const testStartTime = Date.now();
            
            console.log('📊 Initial State:');
            console.log(`   Current multiplier: ${appState.currentMultiplier}x`);
            console.log(`   Elapsed time: ${((Date.now() - appState.indexingStartTime) / 1000 / 60).toFixed(1)} min`);
            console.log(`   Fast mode active: ${appState.fastMode?.active || false}`);
            
            // Test 1: Auto Mode Fast Mode
            console.log('\n🚀 Test 1: Auto Mode Fast Mode (500x speed)');
            appState.fastMode = {
                active: true,
                mode: 'automode',
                speedMultiplier: 500
            };
            
            // Simulate 500x acceleration by adjusting indexing start time
            const simulatedElapsedSeconds = 30 * 60; // Simulate 30 minutes elapsed
            const acceleratedTime = simulatedElapsedSeconds / 500; // 500x faster
            appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            
            // Force update animation and points
            let elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            console.log(`   Simulated elapsed time: ${(elapsedTime / 60).toFixed(1)} min`);
            console.log(`   Expected display time: ${(simulatedElapsedSeconds / 60).toFixed(1)} min`);
            
            updateAnimationPanel(elapsedTime);
            updatePointsDisplay();
            updateCurrentMultiplier(elapsedTime);
            
            console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
            console.log(`   Points calculated for: ${(elapsedTime / 60).toFixed(1)} min`);
            
            // Test 2: Detection Mode Fast Mode
            setTimeout(() => {
                console.log('\n🎯 Test 2: Detection Mode Fast Mode (Content Navigation)');
                appState.fastMode = {
                    active: true,
                    mode: 'detection',
                    currentContentIndex: 5, // Simulate being on 5th piece of content
                    isInFinalSeconds: false
                };
                
                // Reset indexing start time for detection mode test
                appState.indexingStartTime = testStartTime - (2 * 60 * 1000); // 2 minutes ago
                
                // Calculate expected accelerated time
                const baseElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                const contentIndex = appState.fastMode.currentContentIndex;
                const averageContentDuration = 45 * 60; // 45 minutes
                const expectedAcceleratedTime = baseElapsedTime + (contentIndex * averageContentDuration);
                
                console.log(`   Base elapsed time: ${(baseElapsedTime / 60).toFixed(1)} min`);
                console.log(`   Content index: ${contentIndex}`);
                console.log(`   Expected accelerated time: ${(expectedAcceleratedTime / 60).toFixed(1)} min`);
                
                // Force update with detection mode logic
                elapsedTime = expectedAcceleratedTime;
                updateAnimationPanel(elapsedTime);
                updatePointsDisplay();
                updateCurrentMultiplier(elapsedTime);
                
                console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
                console.log(`   Points calculated for: ${(elapsedTime / 60).toFixed(1)} min`);
                
                // Test 3: Detection Mode Final Seconds
                setTimeout(() => {
                    console.log('\n⏰ Test 3: Detection Mode Final Seconds (Normal Speed)');
                    appState.fastMode.isInFinalSeconds = true;
                    
                    // In final seconds, should use normal time progression
                    const normalElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                    console.log(`   Normal elapsed time: ${(normalElapsedTime / 60).toFixed(1)} min`);
                    
                    updateAnimationPanel(normalElapsedTime);
                    updatePointsDisplay();
                    updateCurrentMultiplier(normalElapsedTime);
                    
                    console.log(`   Updated multiplier: ${appState.currentMultiplier}x`);
                    console.log(`   Points calculated for: ${(normalElapsedTime / 60).toFixed(1)} min`);
                    
                    // Restore original state
                    setTimeout(() => {
                        console.log('\n🔄 Restoring original state...');
                        appState.fastMode = originalFastMode;
                        appState.indexingStartTime = originalIndexingStartTime;
                        
                        // Final update with restored state
                        const restoredElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        updateAnimationPanel(restoredElapsedTime);
                        updatePointsDisplay();
                        updateCurrentMultiplier(restoredElapsedTime);
                        
                        console.log('✅ Fast Mode Progress Updates Test Complete!');
                        console.log(`   Restored to normal timing: ${(restoredElapsedTime / 60).toFixed(1)} min`);
                        console.log(`   Final multiplier: ${appState.currentMultiplier}x`);
                    }, 1000);
                }, 1000);
            }, 1000);
        }

        // NEW: Test function to manually trigger fast mode scenarios
        function activateFastModeTest(mode = 'automode') {
            console.log(`🚀 Manually activating ${mode} fast mode...`);
            
            if (!appState.isIndexing) {
                console.log('❌ Fast mode requires active indexing session. Start indexing first.');
                return;
            }
            
            if (mode === 'automode') {
                appState.fastMode = {
                    active: true,
                    mode: 'automode',
                    speedMultiplier: 500
                };
                
                // Simulate significant elapsed time
                const simulatedMinutes = 90; // 1.5 hours
                const acceleratedTime = (simulatedMinutes * 60) / 500;
                appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
                
                console.log(`✅ Auto mode fast mode activated (500x speed)`);
                console.log(`   Simulating ${simulatedMinutes} minutes elapsed`);
                
            } else if (mode === 'detection') {
                appState.fastMode = {
                    active: true,
                    mode: 'detection',
                    currentContentIndex: 4,
                    isInFinalSeconds: false
                };
                
                // Set base time for detection mode
                appState.indexingStartTime = Date.now() - (3 * 60 * 1000); // 3 minutes ago
                
                console.log(`✅ Detection mode fast mode activated`);
                console.log(`   Content index: 4 (showing accelerated progress)`);
                
            } else if (mode === 'final') {
                if (!appState.fastMode || appState.fastMode.mode !== 'detection') {
                    console.log('❌ Final seconds mode requires detection mode to be active first');
                    return;
                }
                
                appState.fastMode.isInFinalSeconds = true;
                
                console.log(`✅ Final seconds mode activated`);
                console.log(`   Showing normal time progression for final seconds`);
            }
            
            console.log('📊 Fast mode is now active - progress indicator and timer will update accordingly');
            console.log('   Use deactivateFastModeTest() to return to normal mode');
        }

        // NEW: Test function to deactivate fast mode
        function deactivateFastModeTest() {
            console.log('🔄 Deactivating fast mode...');
            
            if (!appState.fastMode || !appState.fastMode.active) {
                console.log('❌ Fast mode is not currently active');
                return;
            }
            
            // Calculate current elapsed time in fast mode
            const currentElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            
            // Reset to normal timing - adjust indexing start time to maintain continuity
            const normalElapsedTime = currentElapsedTime;
            appState.indexingStartTime = Date.now() - (normalElapsedTime * 1000);
            
            // Deactivate fast mode
            appState.fastMode = {
                active: false,
                mode: null
            };
            
            console.log(`✅ Fast mode deactivated`);
            console.log(`   Restored to normal timing, elapsed: ${(normalElapsedTime / 60).toFixed(1)} min`);
            console.log('📊 Progress indicator and timer now showing normal progression');
        }

        // NEW: Test function for fast mode content indexing
        function testFastModeContentIndexing() {
            console.log('🧪 Testing Fast Mode Content Indexing...');
            
            if (!appState.isIndexing) {
                console.log('❌ Test requires active indexing session. Start indexing first.');
                return;
            }
            
            if (appState.entryPoint !== 'automode') {
                console.log('❌ Test requires auto mode entry point');
                return;
            }
            
            if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) {
                console.log('❌ No auto mode content items available');
                return;
            }
            
            console.log('📊 Initial State:');
            console.log(`   Total content items: ${appState.automodeContentItems.length}`);
            console.log(`   Current content index: ${appState.currentContentIndex}`);
            console.log(`   Indexed content count: ${appState.indexedContent.length}`);
            console.log(`   Fast mode active: ${appState.fastMode?.active || false}`);
            
            // Activate fast mode if not already active
            if (!appState.fastMode || !appState.fastMode.active) {
                console.log('🚀 Activating auto mode fast mode...');
                appState.fastMode = {
                    active: true,
                    mode: 'automode',
                    speedMultiplier: 500
                };
                
                // Simulate significant elapsed time (2 hours)
                const simulatedMinutes = 120;
                const acceleratedTime = (simulatedMinutes * 60) / 500;
                appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            }
            
            // Force content indexing update
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            console.log(`\n⏱️  Current elapsed time: ${(elapsedTime / 60).toFixed(1)} minutes`);
            
            // Run the fast mode content indexing
            handleFastModeContentIndexing(elapsedTime);
            
            console.log('\n📊 After Fast Mode Content Indexing:');
            console.log(`   Current content index: ${appState.currentContentIndex}`);
            console.log(`   Indexed content count: ${appState.indexedContent.length}`);
            console.log(`   Last 5 indexed items:`);
            
            const lastItems = appState.indexedContent.slice(-5);
            lastItems.forEach((item, index) => {
                console.log(`     ${index + 1}. ${item.title} (${item.duration}m, ${item.points} pts)`);
            });
            
            // Calculate expected vs actual
            let totalExpectedDuration = 0;
            for (let i = 0; i <= appState.currentContentIndex && i < appState.automodeContentItems.length; i++) {
                const item = appState.automodeContentItems[i];
                if (item) {
                    let itemDuration;
                    if (typeof item.duration === 'string' && item.duration.includes(':')) {
                        const durationParts = item.duration.split(':');
                        itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        itemDuration = item.duration || (45 * 60);
                    }
                    totalExpectedDuration += itemDuration;
                }
            }
            
            console.log(`\n📈 Content Analysis:`);
            console.log(`   Expected duration for ${appState.currentContentIndex + 1} items: ${(totalExpectedDuration / 60).toFixed(1)} min`);
            console.log(`   Current elapsed time: ${(elapsedTime / 60).toFixed(1)} min`);
            console.log(`   Content catch-up status: ${totalExpectedDuration <= elapsedTime ? '✅ Caught up' : '⏳ Still catching up'}`);
            
            console.log('\n✅ Fast Mode Content Indexing Test Complete!');
        }

        // NEW: Function to manually trigger content indexing update
        function updateContentIndexing() {
            if (!appState.isIndexing) {
                console.log('❌ Not in indexing mode');
                return;
            }
            
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            
            if (appState.fastMode && appState.fastMode.active && appState.fastMode.mode === 'automode') {
                console.log('🔄 Manually updating fast mode content indexing...');
                handleFastModeContentIndexing(elapsedTime);
                console.log(`✅ Content indexing updated. Current index: ${appState.currentContentIndex}, Indexed items: ${appState.indexedContent.length}`);
            } else {
                console.log('ℹ️ Not in auto mode fast mode, using normal content progression');
            }
        }

        // NEW: Debug function to check channel communication
        function debugChannelCommunication() {
            console.log('🔍 [DEBUG] === CHANNEL COMMUNICATION DEBUG ===');
            
            // Check app state
            console.log('🔍 [DEBUG] App State:', {
                entryPoint: appState.entryPoint,
                isIndexing: appState.isIndexing,
                detectedShow: appState.detectedShow,
                pendingShowForGenreChannel: appState.pendingShowForGenreChannel
            });
            
            // Check channel frames
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            console.log('🔍 [DEBUG] Channel Frames:', {
                main: channelFrame ? 'Found' : 'Not found',
                indexing: channelFrameIndexing ? 'Found' : 'Not found',
                mainSrc: channelFrame ? channelFrame.src : 'N/A',
                indexingSrc: channelFrameIndexing ? channelFrameIndexing.src : 'N/A'
            });
            
            // Test message sending
            if (channelFrame && channelFrame.contentWindow) {
                console.log('🔍 [DEBUG] Testing message to main channel...');
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
            }
            
            if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                console.log('🔍 [DEBUG] Testing message to indexing channel...');
                channelFrameIndexing.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
            }
            
            console.log('🔍 [DEBUG] === END DEBUG ===');
        }

        // NEW: Test function for receipt view with fast mode content
        function testReceiptViewWithFastMode() {
            console.log('🧪 Testing Receipt View with Fast Mode Content...');
            
            if (!appState.isIndexing) {
                console.log('❌ Test requires active indexing session. Starting auto mode...');
                
                // Auto-start an automode session for testing
                appState.entryPoint = 'automode';
                appState.currentBucket = 'Comedy Classics';
                appState.automodeContentItems = [
                    { title: 'The Office S1 E1', duration: '0:22' },
                    { title: 'The Office S1 E2', duration: '0:22' },
                    { title: 'The Office S1 E3', duration: '0:22' },
                    { title: 'Friends S1 E1', duration: '0:24' },
                    { title: 'Friends S1 E2', duration: '0:24' },
                    { title: 'Seinfeld S1 E1', duration: '0:23' },
                    { title: 'Seinfeld S1 E2', duration: '0:23' },
                    { title: 'Parks and Rec S1 E1', duration: '0:22' },
                    { title: 'Parks and Rec S1 E2', duration: '0:22' },
                    { title: 'Brooklyn Nine-Nine S1 E1', duration: '0:22' }
                ];
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = 0;
                appState.contentItemDuration = 22 * 60; // 22 minutes
                
                toggleIndexing();
                
                setTimeout(() => {
                    testReceiptViewWithFastMode();
                }, 1000);
                return;
            }
            
            // Activate fast mode and let it index content
            console.log('🚀 Activating fast mode to populate indexed content...');
            appState.fastMode = {
                active: true,
                mode: 'automode',
                speedMultiplier: 500
            };
            
            // Simulate 2 hours of content consumption
            const simulatedMinutes = 120;
            const acceleratedTime = (simulatedMinutes * 60) / 500;
            appState.indexingStartTime = Date.now() - (acceleratedTime * 1000);
            
            // Force content indexing
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            handleFastModeContentIndexing(elapsedTime);
            
            console.log(`📊 Indexed ${appState.indexedContent.length} content items from fast mode`);
            
            // End the session and show receipt
            setTimeout(() => {
                console.log('🎬 Ending session and showing receipt view...');
                stopIndexing();
                
                setTimeout(() => {
                    console.log('✅ Receipt view should now be displayed with movie credits scrolling!');
                    console.log(`   Total indexed items: ${appState.indexedContent.length}`);
                    console.log('   Check the "Content Indexed" section - it should:');
                    console.log('   • Show exactly 3 items visible at once');
                    console.log('   • Auto-scroll like movie credits (smooth vertical movement)');
                    console.log('   • Pause at top and bottom');
                    console.log('   • Continuously loop through all content');
                }, 500);
            }, 2000);
        }

        // ============================================================================
        // VERTICAL BREAKPOINT TESTING SYSTEM
        // ============================================================================
        
        let originalBodyHeight = null;
        let currentTestHeight = null;
        
        // Initialize viewport height tracking
        function initializeViewportTracking() {
            updateViewportDisplay();
            
            // Update display when window is resized
            window.addEventListener('resize', updateViewportDisplay);
            
            // Initial update after page load
            setTimeout(updateViewportDisplay, 100);
        }
        
        // Update the viewport height display in debug panel
        function updateViewportDisplay() {
            const heightSpan = document.getElementById('current-viewport-height');
            const breakpointSpan = document.getElementById('current-breakpoint');
            
            if (heightSpan && breakpointSpan) {
                const currentHeight = window.innerHeight;
                heightSpan.textContent = currentHeight;
                
                // Determine current breakpoint
                let breakpoint = 'Unknown';
                if (currentHeight <= 480) {
                    breakpoint = 'Very Short (≤480px)';
                } else if (currentHeight <= 767) {
                    breakpoint = 'Short (481-767px)';
                } else if (currentHeight <= 1023) {
                    breakpoint = 'Standard (768-1023px)';
                } else {
                    breakpoint = 'Tall (≥1024px)';
                }
                
                breakpointSpan.textContent = breakpoint;
                
                // Add visual indicator if we're in test mode
                if (currentTestHeight) {
                    breakpointSpan.style.color = '#ffaa00';
                    breakpointSpan.style.fontWeight = 'bold';
                } else {
                    breakpointSpan.style.color = '#666';
                    breakpointSpan.style.fontWeight = 'normal';
                }
            }
        }
        
        // Set a specific viewport height for testing
        function setViewportHeight(height) {
            console.log(`🧪 Setting viewport height to ${height}px for breakpoint testing`);
            
            // Store original height if this is the first test
            if (!originalBodyHeight) {
                originalBodyHeight = document.body.style.height;
            }
            
            currentTestHeight = height;
            
            // Force the body to have a specific height
            document.body.style.height = `${height}px`;
            document.body.style.maxHeight = `${height}px`;
            document.body.style.overflow = 'hidden';
            
            // Add a test mode indicator class
            document.body.classList.add('viewport-test-mode');
            
            // Force a window resize event to trigger media queries
            window.dispatchEvent(new Event('resize'));
            
            // Update the display
            setTimeout(updateViewportDisplay, 100);
            
            console.log(`✅ Viewport height set to ${height}px`);
            console.log('📊 Check how the UI components adapt:');
            console.log('   • Holistic panel spacing and font sizes');
            console.log('   • Points section dimensions');
            console.log('   • Channel iframe height');
            console.log('   • Receipt view item count');
            console.log('   • Button sizes and spacing');
        }
        
        // Reset viewport to natural height
        function resetViewportHeight() {
            console.log('🔄 Resetting viewport to natural height');
            
            currentTestHeight = null;
            
            // Restore original body styles
            if (originalBodyHeight !== null) {
                document.body.style.height = originalBodyHeight;
            } else {
                document.body.style.height = '';
            }
            document.body.style.maxHeight = '';
            document.body.style.overflow = '';
            
            // Remove test mode class
            document.body.classList.remove('viewport-test-mode');
            
            // Force a window resize event
            window.dispatchEvent(new Event('resize'));
            
            // Update the display
            setTimeout(updateViewportDisplay, 100);
            
            console.log('✅ Viewport reset to natural height');
        }
        
        // Test all breakpoints in sequence
        function testAllBreakpoints() {
            console.log('🧪 Testing all vertical breakpoints in sequence...');
            
            const breakpoints = [
                { height: 400, name: 'Very Short (Mobile Landscape)' },
                { height: 600, name: 'Short (Tablet Portrait)' },
                { height: 800, name: 'Standard (Desktop/Laptop)' },
                { height: 1100, name: 'Tall (Large Desktop)' }
            ];
            
            let currentIndex = 0;
            
            function testNextBreakpoint() {
                if (currentIndex < breakpoints.length) {
                    const bp = breakpoints[currentIndex];
                    console.log(`\n📐 Testing ${bp.name} (${bp.height}px)`);
                    setViewportHeight(bp.height);
                    
                    currentIndex++;
                    setTimeout(testNextBreakpoint, 3000); // 3 seconds between tests
                } else {
                    console.log('\n🔄 Test sequence complete, resetting to natural height');
                    setTimeout(resetViewportHeight, 2000);
                }
            }
            
            testNextBreakpoint();
        }
        
        // Add some CSS to indicate test mode
        function addTestModeStyles() {
            const style = document.createElement('style');
            style.textContent = `
                .viewport-test-mode::before {
                    content: "🧪 VIEWPORT TEST MODE";
                    position: fixed;
                    top: 5px;
                    right: 5px;
                    background: rgba(255, 170, 0, 0.9);
                    color: #000;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 10px;
                    font-weight: bold;
                    z-index: 10001;
                    font-family: 'SF Mono', monospace;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeViewportTracking();
            addTestModeStyles();
        });

        // NEW: Message-based system to call channel functions (works around cross-origin restrictions)
        function callChannelFunction(functionName, ...args) {
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.error('❌ Channel iframe not found or not loaded');
                return;
            }
            
            // Send message to iframe to execute the function
            channelFrame.contentWindow.postMessage({
                type: 'executeFunction',
                functionName: functionName,
                args: args
            }, '*');
            
            console.log(`📤 Sent request to execute '${functionName}' in channel iframe`);
        }

        // NEW: Check if channel iframe is ready
        function checkChannelReady() {
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('❌ Channel iframe element not found');
                return false;
            }
            
            if (!channelFrame.contentWindow) {
                console.log('❌ Channel iframe not loaded yet');
                return false;
            }
            
            console.log('✅ Channel iframe is ready');
            console.log('Channel iframe src:', channelFrame.src);
            console.log('Channel iframe display:', channelFrame.style.display);
            return true;
        }

        // NEW: Wrapper functions for easy access to channel test functions
        function testDuplicatePrevention() {
            console.log('🧪 Starting duplicate prevention test...');
            
            if (!checkChannelReady()) {
                console.log('❌ Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('testDuplicatePrevention');
        }

        function debugChannelContentState() {
            console.log('🔍 Checking channel content state...');
            
            if (!checkChannelReady()) {
                console.log('❌ Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('debugContentState');
        }

        function forceShowChannelProgramTrack() {
            console.log('🎯 Forcing channel program track to show...');
            
            if (!checkChannelReady()) {
                console.log('❌ Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('forceShowProgramTrack');
        }

        function debugChannelPositioning() {
            console.log('📐 Debugging channel positioning...');
            
            if (!checkChannelReady()) {
                console.log('❌ Channel not ready. Make sure you\'re on a channel view (like Genre channel)');
                return;
            }
            
            callChannelFunction('debugPositioning');
        }

        // NEW: Validation function to check content block sizing accuracy
        function validateContentBlockSizing() {
            console.log('🔍 Validating content block sizing accuracy...');
            
            // Get the channel frame
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel frame not available for validation');
                return;
            }
            
            // Request layout validation from the channel
            const messageHandler = (event) => {
                if (event.data.type === 'layoutValidationResponse') {
                    window.removeEventListener('message', messageHandler);
                    
                    const validationData = event.data.data;
                    console.log('📊 Received layout validation data:', validationData);
                    
                    // Analyze the validation results
                    analyzeBlockSizing(validationData);
                }
            };
            
            window.addEventListener('message', messageHandler);
            
            // Request layout validation
            channelFrame.contentWindow.postMessage({
                type: 'validateLayoutSizing'
            }, '*');
            
            // Timeout after 3 seconds
            setTimeout(() => {
                window.removeEventListener('message', messageHandler);
                console.log('⚠️ Layout validation request timed out');
            }, 3000);
        }
        
        // Analyze block sizing accuracy
        function analyzeBlockSizing(validationData) {
            console.log('\n🎯 CONTENT BLOCK SIZING ANALYSIS');
            console.log('='.repeat(50));
            
            const { timelineDuration, blocks, timelineWidth } = validationData;
            
            console.log(`Timeline Duration: ${timelineDuration} minutes`);
            console.log(`Timeline Visual Width: ${timelineWidth}px`);
            console.log(`Minutes per Pixel: ${(timelineDuration / timelineWidth).toFixed(4)}`);
            
            let totalErrors = 0;
            let maxError = 0;
            let maxErrorBlock = null;
            
            console.log('\nBlock Analysis:');
            console.log('-'.repeat(50));
            
            blocks.forEach((block, index) => {
                // Calculate expected width based on duration
                const expectedWidthPercent = (block.duration / timelineDuration) * 100;
                const expectedWidthPixels = (block.duration / timelineDuration) * timelineWidth;
                
                // Calculate actual width
                const actualWidthPercent = parseFloat(block.computedWidth);
                const actualWidthPixels = (actualWidthPercent / 100) * timelineWidth;
                
                // Calculate errors
                const percentError = Math.abs(actualWidthPercent - expectedWidthPercent);
                const pixelError = Math.abs(actualWidthPixels - expectedWidthPixels);
                const percentageOfExpected = (actualWidthPercent / expectedWidthPercent) * 100;
                
                // Track maximum error
                if (percentError > maxError) {
                    maxError = percentError;
                    maxErrorBlock = block;
                }
                
                totalErrors += percentError;
                
                // Status indicator
                const isAccurate = percentError < 0.5; // Within 0.5% is considered accurate
                const status = isAccurate ? '✅' : (percentError < 2 ? '⚠️' : '❌');
                
                console.log(`${status} Block ${index + 1}: "${block.title}"`);
                console.log(`   Duration: ${block.duration} min`);
                console.log(`   Expected: ${expectedWidthPercent.toFixed(2)}% (${expectedWidthPixels.toFixed(1)}px)`);
                console.log(`   Actual: ${actualWidthPercent.toFixed(2)}% (${actualWidthPixels.toFixed(1)}px)`);
                console.log(`   Error: ${percentError.toFixed(2)}% (${pixelError.toFixed(1)}px)`);
                console.log(`   Accuracy: ${percentageOfExpected.toFixed(1)}% of expected`);
                
                if (block.startTime !== undefined) {
                    const expectedLeftPercent = (block.startTime / timelineDuration) * 100;
                    const actualLeftPercent = parseFloat(block.computedLeft);
                    const positionError = Math.abs(actualLeftPercent - expectedLeftPercent);
                    console.log(`   Position - Expected: ${expectedLeftPercent.toFixed(2)}%, Actual: ${actualLeftPercent.toFixed(2)}%, Error: ${positionError.toFixed(2)}%`);
                }
                
                console.log('');
            });
            
            // Summary
            console.log('📋 VALIDATION SUMMARY');
            console.log('='.repeat(50));
            
            const averageError = totalErrors / blocks.length;
            const accurateBlocks = blocks.filter((block, index) => {
                const expectedWidthPercent = (block.duration / timelineDuration) * 100;
                const actualWidthPercent = parseFloat(block.computedWidth);
                return Math.abs(actualWidthPercent - expectedWidthPercent) < 0.5;
            }).length;
            
            console.log(`Total Blocks: ${blocks.length}`);
            console.log(`Accurate Blocks (±0.5%): ${accurateBlocks}/${blocks.length} (${((accurateBlocks/blocks.length)*100).toFixed(1)}%)`);
            console.log(`Average Error: ${averageError.toFixed(2)}%`);
            console.log(`Maximum Error: ${maxError.toFixed(2)}% (${maxErrorBlock ? maxErrorBlock.title : 'N/A'})`);
            
            // Overall assessment
            if (averageError < 0.5) {
                console.log('🎉 EXCELLENT: Block sizing is highly accurate');
            } else if (averageError < 1.0) {
                console.log('✅ GOOD: Block sizing is reasonably accurate');
            } else if (averageError < 2.0) {
                console.log('⚠️ FAIR: Block sizing has some inaccuracies');
            } else {
                console.log('❌ POOR: Block sizing needs improvement');
            }
            
            // Recommendations
            if (maxError > 2.0) {
                console.log('\n💡 RECOMMENDATIONS:');
                console.log('- Check timeline expansion logic for very long content');
                console.log('- Verify percentage calculations in calculateWidth()');
                console.log('- Ensure currentTimelineDuration is accurate');
            }
            
            console.log('\n✅ Block sizing validation complete');
        }

        function showState() {
            console.log('showState called');
            console.log('Current App State:', appState);
            if (typeof Tracker !== 'undefined') {
                Tracker.logRumiState(appState);
            } else {
                console.error('Tracker not available');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded');
            setTimeout(initApp, 100);
            initializeEntryPoint(); // Setup the launcher panel
        });

        // ... (rest of the code remains unchanged)

        // --- Error State Management via Message Area ---
        let wasIndexingBeforeError = false;

        function setErrorState(errorType) {
            // Save if we were indexing before error, but DON'T stop indexing
            if (errorType && appState.isIndexing) {
                wasIndexingBeforeError = true;
                // Pause indexing when error occurs
                pauseIndexing();
            }

            // Hide all error-state panels (legacy, just in case)
            document.querySelectorAll('.error-state').forEach(el => {
                if (el && el.style) el.style.display = 'none';
            });
            
            // Show error in message area using new expandable functionality
            if (errorType) {
                // Map old error types to new ones for compatibility
                let newErrorType = errorType;
                switch (errorType) {
                    case 'volume':
                        newErrorType = 'user-error';
                        break;
                    case 'connection':
                        newErrorType = 'system-error';
                        break;
                    case 'loading':
                        newErrorType = 'loading';
                        break;
                    case 'offline':
                        newErrorType = 'offline';
                        break;
                    case 'show-interrupt':
                        newErrorType = 'show-interrupt';
                        break;
                }
                
                updateMessageArea(newErrorType);
                autoExpandSections(newErrorType);
                appState.errorState = errorType;
                Tracker.logRumiAction('ERROR_STATE_SET', { errorType, timestamp: Date.now() });
            } else {
                // Clear error state
                updateMessageArea('normal');
                appState.errorState = null;
                Tracker.logRumiAction('ERROR_STATE_CLEARED', { timestamp: Date.now() });
                // Resume indexing if it was active before error
                if (wasIndexingBeforeError) {
                    wasIndexingBeforeError = false;
                    // Resume indexing using the new pause/resume system
                    resumeIndexing();
                }
            }
            updateUI();
            updateDebugButtonStates(); // Update debug button states when error state changes
        }

        function handleVolumeError() {
            setErrorState('volume');
            // Update the volume display
            const volumeDisplay = document.getElementById('current-volume-display');
            if (volumeDisplay) {
                volumeDisplay.textContent = `${appState.volumeLevel}%`;
            }
            Tracker.logRumiAction('VOLUME_ERROR_DETECTED', { 
                currentVolume: appState.volumeLevel,
                requiredVolume: 100 
            });
        }

        function handleConnectionLost() {
            setErrorState('connection');
            Tracker.logRumiAction('CONNECTION_LOST', { 
                sessionDuration: appState.isIndexing ? Date.now() - appState.indexingStartTime : 0 
            });
        }

        function handleLoadingState() {
            setErrorState('loading');
            Tracker.logRumiAction('LOADING_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function handleOfflineState() {
            setErrorState('offline');
            Tracker.logRumiAction('OFFLINE_STATE_ACTIVATED', { timestamp: Date.now() });
        }

        function clearErrorState() {
            setErrorState(null);
        }

        // Error Recovery Functions
        function retryConnection() {
            Tracker.logRumiAction('CONNECTION_RETRY_ATTEMPTED', { timestamp: Date.now() });
            
            // Simulate connection retry
            setTimeout(() => {
                clearErrorState();
                Tracker.logRumiAction('CONNECTION_RESTORED', { timestamp: Date.now() });
            }, 2000);
        }

        function resumeSession() {
            if (appState.volumeLevel >= 100) {
                clearErrorState();
                Tracker.logRumiAction('SESSION_RESUMED', { timestamp: Date.now() });
            } else {
                // Update the volume display to show current level
                const volumeDisplay = document.getElementById('current-volume-display');
                if (volumeDisplay) {
                    volumeDisplay.textContent = `${appState.volumeLevel}%`;
                }
                Tracker.logRumiAction('SESSION_RESUME_FAILED', { 
                    reason: 'Volume still below 100%',
                    currentVolume: appState.volumeLevel 
                });
            }
        }

        // Test Functions for Error States
        function testVolumeError() {
            appState.volumeLevel = 20;
            handleVolumeError();
        }

        function testVolumeRestored() {
            appState.volumeLevel = 100;
            // This will trigger auto-resume in monitorVolume
            Tracker.logRumiAction('Volume restored for testing', { volumeLevel: appState.volumeLevel });
        }

        function testConnectionLost() {
            handleConnectionLost();
        }

        function testLoadingState() {
            handleLoadingState();
            // Auto-clear after 3 seconds
            setTimeout(() => {
                clearErrorState();
            }, 3000);
        }

        function testOfflineState() {
            handleOfflineState();
        }

        // Error State Compression (for mobile)
        function compressErrorState() {
            const errorStates = document.querySelectorAll('.error-state');
            errorStates.forEach(state => {
                state.style.fontSize = '0.8em';
                state.style.padding = '8px';
            });
        }

        // Monitor volume changes (simulated)
        function monitorVolume() {
            // Simulate volume monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger volume errors if we're already in a volume error state
                if (appState.errorState === 'volume') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && appState.volumeLevel < 100) {
                    handleVolumeError();
                }
                // Note: Removed auto-resume to prevent cycling - user must manually resolve
            }, 5000);
        }

        // Monitor connection status (simulated)
        function monitorConnection() {
            // Simulate connection monitoring
            setInterval(() => {
                // Don't trigger errors if indexing is paused
                if (appState.isPaused) return;
                
                // Don't trigger connection errors if we're already in a connection error state
                if (appState.errorState === 'connection') return;
                
                // Don't trigger any errors if there's already an active error
                if (appState.errorState) return;
                
                if (appState.isIndexing && Math.random() < 0.1) {
                    handleConnectionLost();
                }
            }, 10000);
        }

        function showSettingsView() {
            Tracker.logRumiAction('Settings view shown');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<button class="settings-button" onclick="showMainView()">← BACK</button>';
            // }
            
            // Hide main view and show settings view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('settings-view').style.display = 'block';
            
            appState.view = 'settings';
        }

        // Test function for receipt flow
        function testReceipt() {
            Tracker.testReceiptFlow();
            
            // Simulate a completed session for testing
            const testSessionEarnings = 45.6;
            const testSessionDuration = 930; // 15:30
            const testMultiplier = 1.2;
            
            showReceiptView(testSessionEarnings, testSessionDuration, testMultiplier);
        }

        // Toggle Leaderboard visibility
        function toggleLeaderboard() {
            const leaderboardSection = document.getElementById('leaderboard-section');
            const isExpanded = leaderboardSection.classList.toggle('is-expanded');
            Tracker.logRumiAction('Leaderboard toggled', { expanded: isExpanded });
        }

        // Toggle queue visibility
        function toggleQueue() {
            const queueDetails = document.getElementById('queue-details');
            const queueButton = document.querySelector('.show-queue-button');
            const isExpanded = queueDetails.classList.toggle('is-expanded');

            if (isExpanded) {
                queueButton.textContent = 'Hide Queue ▲';
                updateQueueView(); // Populate the queue when showing
                Tracker.logRumiAction('Queue shown');
            } else {
                queueButton.textContent = 'Show Queue ▼';
                Tracker.logRumiAction('Queue hidden');
            }
        }
        
        // Update Queue View
        function updateQueueView() {
            const queueDetails = document.getElementById('queue-details');
            if (!queueDetails) return;

            // Clear previous items
            queueDetails.innerHTML = '';

            if (appState.queue.length > 0) {
                appState.queue.forEach(item => {
                    const queueItem = document.createElement('div');
                    queueItem.className = 'queue-item';
                    queueItem.textContent = `${item.title} - ${item.details}`;
                    queueDetails.appendChild(queueItem);
                });
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'queue-item';
                noItems.textContent = 'Queue is empty';
                queueDetails.appendChild(noItems);
            }
        }
        
        // Iframe resizing and error handling logic
        function resizeIframe(iframe) {
            console.log('resizeIframe called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Iframe visibility set to visible');
                
                // Integrate content tracking with the loaded channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoading() {
            const loadingDiv = document.getElementById('channel-loading');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelError() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available');
        }

        // Listen for messages from iframes
        window.addEventListener('message', (event) => {
            // Basic security check
            if (!event.data || !event.data.type) {
                return;
            }

            if (event.data.type === 'rumi:setBucket') {
                const bucket = event.data.payload.bucket;
                if (bucket) {
                    appState.currentBucket = bucket;
                    Tracker.logRumiAction('Bucket changed', { bucket });
                    console.log('Rumi bucket set to:', bucket);
                    updateChannelTitle(); // Update the UI
                    updateUI(); // Update button labels for automode
                }
            }
            
            if (event.data.type === 'rumi:showAdded') {
                const { showTitle, position } = event.data.payload;
                if (showTitle) {
                    console.log(`Show "${showTitle}" added to ${position} of channel`);
                    Tracker.logRumiAction('Show added to channel', { showTitle, position });
                    
                    // Show the detected show UI
                    showDetectedShowUI(showTitle);
                } else {
                    console.warn('Received showAdded message with undefined showTitle');
                }
            }
        });

        // Initialize and update channel title
        function initializeChannelTitle() {
            updateChannelTitle();
        }

        function updateChannelTitle() {
            const channelTitleEl = document.getElementById('channel-title');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Indexing channel functions
        function resizeIframeIndexing(iframe) {
            console.log('resizeIframeIndexing called for:', iframe.id);
            try {
                // Set to fixed height for consistent display
                iframe.style.height = '320px';
                console.log('Indexing iframe set to fixed height: 320px');
            } catch (e) {
                console.error('Error setting indexing iframe height:', e);
                iframe.style.height = '320px'; // Fallback height
            } finally {
                iframe.style.visibility = 'visible';
                console.log('Indexing iframe visibility set to visible');
                
                // Integrate content tracking with the loaded indexing channel
                setTimeout(() => integrateContentTrackingWithChannels(), 100);
            }
        }

        function hideChannelLoadingIndexing() {
            const loadingDiv = document.getElementById('channel-loading-indexing');
            if (loadingDiv) loadingDiv.style.display = 'none';
        }

        function showChannelErrorIndexing() {
            // Loading element is now permanently hidden, so we can't show error messages there
            console.error('Channel not available (indexing)');
        }

        function initializeChannelTitleIndexing() {
            updateChannelTitleIndexing();
        }

        function updateChannelTitleIndexing() {
            const channelTitleEl = document.getElementById('channel-title-indexing');
            if (channelTitleEl) {
                channelTitleEl.textContent = appState.currentBucket;
            }
        }

        // Channel switching functionality
        let currentChannel = 'rumi'; // 'rumi' or 'genre'
        
        function toggleChannel() {
            // This function is no longer needed - channels are handled automatically
            // based on entry point. Remove the problematic element access.
            console.log('Channel switching is now automatic based on entry point');
        }

        // Function to send show detection to genre channel
        function sendShowDetection(showData) {
            console.log('🔍 [DEBUG] sendShowDetection called with:', showData);
            
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            console.log('🔍 [DEBUG] Channel frames:', {
                main: channelFrame ? 'Found' : 'Not found',
                indexing: channelFrameIndexing ? 'Found' : 'Not found',
                mainSrc: channelFrame ? channelFrame.src : 'N/A',
                indexingSrc: channelFrameIndexing ? channelFrameIndexing.src : 'N/A'
            });
            
            const message = {
                type: 'rumi:showDetected',
                payload: showData
            };
            
            console.log('🔍 [DEBUG] Show detection message:', message);
            
            // Function to send message when iframe is ready
            function sendMessageWhenReady(iframe, frameName) {
                if (iframe && iframe.contentWindow) {
                    try {
                        console.log(`Sending to ${frameName} channel frame`);
                        console.log(`${frameName} frame src:`, iframe.src);
                        // Don't try to access iframe document properties - causes CORS errors
                        
                        iframe.contentWindow.postMessage(message, '*');
                        console.log(`📡 [DEBUG] Message sent to ${frameName} frame successfully`);
                        return true;
                    } catch (e) {
                        console.error(`❌ [DEBUG] Error sending to ${frameName} frame:`, e);
                        return false;
                    }
                } else {
                    console.error(`${frameName} channel frame not found or not ready`);
                    console.log(`${frameName} frame exists:`, !!iframe);
                    console.log(`${frameName} frame contentWindow exists:`, !!(iframe && iframe.contentWindow));
                    return false;
                }
            }
            
            // Send to both iframes (home and indexing views)
            const homeSent = sendMessageWhenReady(channelFrame, 'home');
            const indexingSent = sendMessageWhenReady(channelFrameIndexing, 'indexing');
            
            if (!homeSent || !indexingSent) {
                // If either frame wasn't ready, try again after a short delay
                console.log('Some frames not ready, retrying in 1 second...');
                setTimeout(() => {
                    sendMessageWhenReady(channelFrame, 'home (retry)');
                    sendMessageWhenReady(channelFrameIndexing, 'indexing (retry)');
                }, 1000);
            }
            
            Tracker.logRumiAction('Show detection sent', showData);
        }

        // Function to send ludicrous mode messages to genre channel
        function sendLudicrousModeMessage(messageType, payload = {}) {
            console.log('🚀 [DEBUG] sendLudicrousModeMessage called with:', messageType, payload);
            
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            const message = {
                type: messageType,
                payload: payload
            };
            
            console.log('🚀 [DEBUG] Ludicrous mode message:', message);
            
            // Function to send message when iframe is ready
            function sendToFrame(frame, frameName) {
                if (frame && frame.contentWindow) {
                    console.log(`🚀 Sending ${messageType} to ${frameName} channel frame`);
                    try {
                        frame.contentWindow.postMessage(message, '*');
                        console.log(`🚀 [DEBUG] Ludicrous mode message sent to ${frameName} frame successfully`);
                    } catch (error) {
                        console.error(`Error sending ludicrous mode message to ${frameName} frame:`, error);
                    }
                } else {
                    console.error(`${frameName} frame not available or not loaded`);
                }
            }
            
            // Send to both frames
            sendToFrame(channelFrame, 'home');
            sendToFrame(channelFrameIndexing, 'indexing');
        }

        // Function to send centralized timing to genre channel
        function sendTimingSync() {
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            const timingData = {
                elapsedTime: TimeSystem.getElapsedTime(),
                sessionDuration: TimeSystem.getSessionDuration(),
                progress: TimeSystem.getProgress(),
                currentMultiplier: TimeSystem.getCurrentMultiplier()
            };
            
            const message = {
                type: 'timingSync',
                payload: timingData
            };
            
            // Function to send message to a frame
            function sendToFrame(frame, frameName) {
                if (frame && frame.contentWindow) {
                    try {
                        frame.contentWindow.postMessage(message, '*');
                        console.log(`⏰ [DEBUG] Sent timing sync to ${frameName}:`, timingData);
                    } catch (error) {
                        console.error(`❌ [DEBUG] Failed to send timing sync to ${frameName}:`, error);
                    }
                } else {
                    console.warn(`⚠️ [DEBUG] ${frameName} frame not available`);
                }
            }
            
            // Send to both frames
            sendToFrame(channelFrame, 'home');
            sendToFrame(channelFrameIndexing, 'indexing');
        }

        // Test function to simulate show detection
        function testShowDetection() {
            // Use shows from CSV data
            if (availableShows.length === 0) {
                console.log('No shows available from CSV - loading first...');
                loadAvailableShowsFromCSV().then(() => {
                    if (availableShows.length > 0) {
                        const randomShow = availableShows[Math.floor(Math.random() * availableShows.length)];
                        sendShowDetection(randomShow);
                    } else {
                        console.error('No shows available even after loading CSV');
                    }
                });
                return;
            }
            
            const randomShow = availableShows[Math.floor(Math.random() * availableShows.length)];
            sendShowDetection(randomShow);
        }
        
        // Test function to manually trigger show detection for channel
        function testChannelShowDetection() {
            // Use shows from CSV data
            if (availableShows.length === 0) {
                console.log('No shows available from CSV - loading first...');
                loadAvailableShowsFromCSV().then(() => {
                    if (availableShows.length > 0) {
                        const testShow = availableShows[0]; // Use first show from CSV
                        console.log('Setting up manual show detection test...');
                        appState.pendingShowForGenreChannel = testShow;
                        appState.detectedShow = testShow;
                        
                        console.log('Sending show detection manually...');
                        sendShowDetection(testShow);
                    } else {
                        console.error('No shows available even after loading CSV');
                    }
                });
                return;
            }
            
            const testShow = availableShows[0]; // Use first show from CSV
            console.log('Setting up manual show detection test...');
            appState.pendingShowForGenreChannel = testShow;
            appState.detectedShow = testShow;
            
            console.log('Sending show detection manually...');
            sendShowDetection(testShow);
        }

        // Test function to manually test the animation
        function testAnimation() {
            console.log('Testing animation manually...');
            
            // Force show the nokia content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.style.display = 'block';
                console.log('Nokia content shown');
            }
            
            // Test the animation panel directly
            const panel = document.getElementById('animation-panel-content');
            if (panel) {
                console.log('Animation panel found, testing with simple content...');
                panel.innerHTML = 'TESTING ANIMATION\n################\n##WORKING####\n################\nTESTING ANIMATION';
                console.log('Set test content to panel');
            } else {
                console.error('Animation panel not found!');
            }
            
            // Also test the session stats panel
            const statsPanel = document.getElementById('session-stats-content');
            if (statsPanel) {
                statsPanel.innerHTML = 'TESTING STATS\nMULTIPLIER: 1.0x\nSESSION: +0.00 | [0:00/30:00]\n############################';
                console.log('Set test content to stats panel');
            }
        }

        // Function to show detected show UI
        function showDetectedShowUI(showTitle) {
            // The animation will be updated by the main animation loop once it starts.
            // There is no need to force an update here.
            Tracker.logRumiAction('Detected show UI shown', { showTitle });
        }

        // Function to dismiss detected show UI (home view)
        function dismissDetectedShow() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI dismissed');
        }

        // Function to dismiss detected show UI (indexing view)
        function dismissDetectedShowIndexing() {
            // Panel is now hidden permanently, no dismissal needed
            Tracker.logRumiAction('Detected show UI (indexing) dismissed');
        }

        // Function to update animation when show is detected
        function updateAnimationForShow(showTitle) {
            // Force an immediate animation update with new show data
            if (appState.isIndexing) {
                const now = Date.now();
                const elapsedMilliseconds = (now - appState.indexingStartTime) / 1000;
                updateAnimationPanel(elapsedMilliseconds);
                
                // Log the show detection for animation
                Tracker.logRumiAction('Animation updated for show', { showTitle });
            }
        }

        // Enhanced animation loop with show detection integration and automatic transitions
        function animateSessionStats() {
            // Use centralized time system for all timing calculations
            const elapsedTime = TimeSystem.getElapsedTime();
            
            // Note: Content, block, and multiplier synchronization is now handled by UnifiedTimeSync
            // Only handle UI updates here that depend on synchronized state
            
            // Update button text when content changes (check if content index changed)
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                updateButtonWithCurrentShow(appState.detectedShow);
            } else if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                // Update button text with current automode content
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    updateStopIndexingButtonText(currentItem.title);
                }
            }
                    
                    // Handle fast mode content indexing for auto mode
            if (appState.fastMode && appState.fastMode.active && appState.fastMode.mode === 'automode') {
                    handleFastModeContentIndexing(elapsedTime);
            }
            
            updateAnimationPanel(elapsedTime);
            updatePointsDisplay(); // Update points display in real-time at 60fps
            
            // Update learning insights and progress dashboard in real-time for automode
            if (appState.entryPoint === 'automode' && appState.isIndexing) {
                // Update every 2 seconds for more dynamic feel
                if (Math.floor(elapsedTime * 2) % 4 === 0) { // Every 2 seconds
                    updateLearningInsights();
                    updateProgressDashboard();
                }
            }
            
            // Note: Multiplier updates are now handled by UnifiedTimeSync
            // Update transition system if available
            if (window.transitionSystem && window.transitionSystem.updateMultiplier) {
                window.transitionSystem.updateMultiplier(appState.currentMultiplier);
            }
            
            // Apply enhanced multiplier every 30 seconds (if transition system is available)
            if (Math.floor(elapsedTime) % 30 === 0 && Math.floor(elapsedTime) > 0) {
                applyEnhancedMultiplier();
            }
            
            // Check for automatic show transitions based on duration
            checkForAutomaticTransition(elapsedTime);
            
            // Check if session should end based on synchronized timeline
            // Note: Session completion is now handled by UnifiedTimeSync
            
            // Send timing sync to genre channel every 2 seconds
            if (Math.floor(elapsedTime * 2) % 4 === 0) { // Every 2 seconds
                sendTimingSync();
            }
            
            // Update learning insights every 3 seconds if visible
            if (Math.floor(elapsedTime) % 3 === 0 && appState.entryPoint === 'automode') {
                updateLearningInsights();
                updateProgressDashboard();
            }
            
            // Note: Block progression is now handled by UnifiedTimeSync
            
            // Continue animation loop at 60fps
            animationFrameId = requestAnimationFrame(animateSessionStats);
        }
        
        // NEW: Check if current show should transition to next show automatically
        function checkForAutomaticTransition(elapsedTime) {
            // Only do automatic transitions in detection mode with transition system
            if (appState.entryPoint !== 'detection' || !window.transitionSystem) return;
            
            // Don't transition if we're already transitioning
            if (appState.isTransitioning) return;
            
            // Calculate time spent on current show
            const timeInCurrentShow = elapsedTime - (appState.contentItemStartTime || 0);
            const currentShowDuration = (appState.contentItemDuration || 45 * 60); // Duration in seconds
            
            // Check if current show has completed its duration
            if (timeInCurrentShow >= currentShowDuration) {
                console.log(`Show completed after ${timeInCurrentShow}s (duration: ${currentShowDuration}s)`);
                
                // Get next show from channel
                getNextShowFromChannel().then(nextShow => {
                    if (nextShow) {
                        console.log('Auto-transitioning to next show:', nextShow.title);
                        transitionToNextShow(nextShow);
                    } else {
                        console.log('No more shows in channel, continuing with current show');
                    }
                }).catch(error => {
                    console.error('Error getting next show:', error);
                });
            }
        }
        
        // NEW: Get the next show from the channel queue
        async function getNextShowFromChannel() {
            return new Promise((resolve) => {
                // Request current content from channel
                const channelFrame = document.getElementById('channel-frame');
                if (!channelFrame || !channelFrame.contentWindow) {
                    resolve(null);
                    return;
                }
                
                // Set up message listener for channel response
                const messageHandler = (event) => {
                    if (event.data.type === 'currentContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const channelContent = event.data.content || [];
                        console.log('Received channel content:', channelContent);
                        
                        // Find current show index
                        let currentIndex = -1;
                        if (appState.detectedShow) {
                            currentIndex = channelContent.findIndex(item => 
                                item.title === appState.detectedShow.title
                            );
                        }
                        
                        // Get next show
                        const nextIndex = currentIndex + 1;
                        if (nextIndex < channelContent.length) {
                            const nextShow = channelContent[nextIndex];
                            console.log(`Found next show at index ${nextIndex}:`, nextShow);
                            resolve(nextShow);
                        } else {
                            console.log('No next show available in channel');
                            resolve(null);
                        }
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Request current content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                
                // Timeout after 2 seconds
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    resolve(null);
                }, 2000);
            });
        }
        
        // NEW: Get the next show from channel for fast mode (uses independent index tracking)
        async function getNextShowFromChannelForFastMode() {
            return new Promise((resolve) => {
                // Request current content from channel
                const channelFrame = document.getElementById('channel-frame');
                if (!channelFrame || !channelFrame.contentWindow) {
                    resolve(null);
                    return;
                }
                
                // Set up message listener for channel response
                const messageHandler = (event) => {
                    if (event.data.type === 'currentContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const channelContent = event.data.content || [];
                        console.log('Fast Mode: Received channel content:', channelContent.length, 'items');
                        
                        // Use fast mode's independent index tracking
                        const currentFastModeIndex = appState.fastMode.currentContentIndex || 0;
                        const nextIndex = currentFastModeIndex + 1;
                        
                        console.log(`Fast Mode: Current index ${currentFastModeIndex}, next index ${nextIndex}`);
                        
                        if (nextIndex < channelContent.length) {
                            const nextShow = channelContent[nextIndex];
                            console.log(`Fast Mode: Found next show at index ${nextIndex}:`, nextShow.title);
                            resolve(nextShow);
                        } else {
                            console.log('Fast Mode: No more shows available in channel - session complete');
                            resolve(null);
                        }
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Request current content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                
                // Timeout after 2 seconds
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    resolve(null);
                }, 2000);
            });
        }
        
        // NEW: Transition to the next show in sequence
        function transitionToNextShow(nextShow) {
            console.log('=== AUTOMATIC SHOW TRANSITION ===');
            console.log('From:', appState.detectedShow?.title);
            console.log('To:', nextShow.title);
            
            // Set transition flag
            appState.isTransitioning = true;
            
            // Convert channel show format to app show format
            const formattedShow = {
                title: nextShow.title,
                season: nextShow.season || 'N/A',
                episode: nextShow.episode || 'N/A', 
                service: nextShow.service || 'Unknown',
                genre: nextShow.genre || 'Unknown',
                duration: nextShow.duration || 45,
                type: nextShow.type || 'show'
            };
            
            // Use the transition system for smooth transition
            if (window.transitionSystem) {
                transitionToShowWithSystem(formattedShow);
            } else {
                // Fallback: direct transition
                directTransitionToShow(formattedShow);
            }
            
            // Clear transition flag
            setTimeout(() => {
                appState.isTransitioning = false;
            }, 1000);
            
            console.log('=== TRANSITION COMPLETE ===');
        }
        
        // NEW: Direct transition fallback (without transition system)
        function directTransitionToShow(newShow) {
            // Store previous show
            if (appState.detectedShow) {
                markContentAsPlayedWithTransition(appState.detectedShow);
            }
            
            // Update to new show
            const previousShow = appState.detectedShow;
            appState.detectedShow = newShow;
            
            // Set originalShow only on first transition
            if (!appState.originalShow) {
                appState.originalShow = previousShow;
            }
            
            // Track transition
            appState.interruptNewShow = newShow;
            appState.showInterruptTimestamp = Date.now();
            appState.transitionCount = (appState.transitionCount || 0) + 1;
            
            // Update global variable for compatibility
            detectedShow = newShow;
            
            // Reset content timing for new show
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.contentItemStartTime = elapsedTime;
            appState.contentItemDuration = (newShow.duration || 45) * 60; // Convert to seconds
            
            // Update UI
            updateUI();
            updatePointsDisplay();
            updateContentDisplay();
            updateButtonWithCurrentShow(newShow);
            
            console.log(`Direct transition: ${previousShow?.title} → ${newShow.title}`);
        }

        function simulateStreamDetection() {
            const statusEl = document.getElementById('stream-detector-status');
            if (!statusEl) return;

            statusEl.textContent = 'DETECTING...';
            setTimeout(() => {
                statusEl.textContent = 'STREAM DETECTED!';
                // Open extension or perform other action here
            }, 2000);
        }

        function simulateAutomode() {
            // Placeholder for automode campaign logic
            alert('Automode Campaign button clicked!');
        }

        let detectedShow = null;
        // Available shows will be loaded from CSV data
        let availableShows = [];

        // Load available shows from CSV data
        async function loadAvailableShowsFromCSV() {
            try {
                const response = await fetch('full-length-content-library.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                
                availableShows = [];
                
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                    const item = {};
                    
                    headers.forEach((header, index) => {
                        item[header] = values[index] || '';
                    });
                    
                    // Convert to format expected by UI (using new CSV structure)
                    const show = {
                        title: item.show_name || item.title, // Use show_name from detected mode CSV
                        genre: item.genre,
                        service: item.service,
                        season: item.season || 'N/A',
                        episode: item.episode || 'N/A',
                        year: item.year || null,
                        duration: parseInt(item.duration_minutes) || 45,
                        type: item.type,
                        episode_title: item.episode_title || null
                    };
                    
                    availableShows.push(show);
                }
                
                console.log(`🎯 Loaded ${availableShows.length} available shows from CSV`);
                
            } catch (error) {
                console.error('❌ Failed to load available shows from CSV:', error);
                // Fallback to empty array
                availableShows = [];
            }
        }

        // NEW: State for coordinating the genre channel update
        appState.pendingShowForGenreChannel = null;

        function initializeEntryPoint() {
            // Load shows from CSV first
            loadAvailableShowsFromCSV().then(() => {
            // Pick a random show on load
                if (availableShows.length > 0) {
            detectedShow = availableShows[Math.floor(Math.random() * availableShows.length)];
            
                    // Set the selected show in the integrated dropdown
                    const detectionDropdown = document.getElementById('detection-mode-dropdown');
                    if (detectionDropdown && detectedShow) {
                        detectionDropdown.value = detectedShow.title;
                    }
                    
                    console.log('🎯 Initial detected show set to:', detectedShow.title);
                } else {
                    console.error('No shows available from CSV');
                }
            });
        }

        function launchWithDetection() {
            const streamDetectedButton = document.getElementById('stream-detected-button');
            
            // Check if button is disabled - if so, don't proceed
            if (streamDetectedButton && streamDetectedButton.disabled) {
                console.log('[RUMI] Button is disabled - please select a show first');
                return;
            }
            
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'flex';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Store the entry point info for when activation happens
            appState.pendingEntryPoint = 'detection';
            appState.pendingDetectedShow = detectedShow;
            
            // Don't set the main entry point yet - wait for activation
            // appState.entryPoint = 'detection';
            // appState.detectedShow = detectedShow;
            
            // Don't update UI yet - wait for activation
            // updateUI();
        }

        function launchWithAutomode() {
            const automodeButton = document.getElementById('automode-button');
            const automodeDropdown = document.getElementById('automode-dropdown');
            
            // Check if button is disabled - if so, don't proceed
            if (automodeButton && automodeButton.disabled) {
                console.log('[RUMI] Button is disabled - please select an intelligence bucket first');
                return;
            }
            
            // Get the selected bucket value
            const selectedBucket = automodeDropdown ? automodeDropdown.value : '';
            if (!selectedBucket) {
                console.log('[RUMI] No intelligence bucket selected');
                return;
            }
            
            // Store the selected bucket
            appState.currentBucket = selectedBucket;
            console.log('[RUMI] Launching automode with bucket:', selectedBucket);
            
            // Show the description for the selected bucket
            showAutomodeDescription(selectedBucket);
            
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Show the extension in deactivated state
            popup.style.display = 'flex';
            popup.classList.add('deactivated');
            activationCircle.style.display = 'flex';

            // Hide entry points and show user changes content button
            const entryPointPanel = document.querySelector('.entry-point-panel');
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }

            // Store the entry point info for when activation happens
            appState.pendingEntryPoint = 'automode';
            
            // Don't set the main entry point yet - wait for activation
            // appState.isIndexing = false;
            // appState.entryPoint = 'automode';
            // detectedShow = null;
            
            // Don't update UI yet - wait for activation
            // updateUI();
        }

        // Show automode description for selected bucket
        function showAutomodeDescription(selectedBucket) {
            const descriptionDiv = document.getElementById('automode-description');
            const descriptionText = document.getElementById('automode-description-text');
            
            if (!descriptionDiv || !descriptionText) {
                console.log('[RUMI] Description elements not found');
                return;
            }
            
            // Get content items for this bucket from CSV data
            const contentItems = getAutomodeContent(selectedBucket, 3600, 0.1, 1.0);
            if (contentItems && contentItems.length > 0) {
                // Find the first item with a description from the CSV
                const firstItem = contentItems[0];
                if (firstItem && firstItem.description) {
                    // Use the actual description from CSV
                    descriptionText.textContent = firstItem.description;
                    descriptionDiv.style.display = 'block';
                    console.log('[RUMI] Showing automode description from CSV:', firstItem.description);
                } else {
                    // Fallback if no description in CSV
                    descriptionText.textContent = `Learning ${selectedBucket.toLowerCase()} patterns`;
                    descriptionDiv.style.display = 'block';
                    console.log('[RUMI] No CSV description found, using fallback');
                }
            } else {
                // No content items found for this bucket
                descriptionText.textContent = `Learning ${selectedBucket.toLowerCase()} patterns`;
                descriptionDiv.style.display = 'block';
                console.log('[RUMI] No content items found for bucket:', selectedBucket);
            }
        }

        // Section 2b: Start Automode Indexing Function
        function startAutomodeIndexing() {
            console.log('Starting automode indexing...');
            
            // Set app state to start indexing
            appState.isIndexing = true;
            appState.indexingStartTime = Date.now();
            appState.sessionDuration = calculateSessionDuration();
            
            const bucketSelect = document.getElementById('automode-dropdown');
            const selectedBucket = bucketSelect ? bucketSelect.value : 'Content Intelligence';
            appState.currentBucket = selectedBucket;
            
            const contentItems = getAutomodeContent(selectedBucket, appState.sessionDuration, appState.baseRate || 0.1, appState.currentMultiplier);
            appState.automodeContentItems = contentItems;
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = contentItems[0] ? parseFloat(contentItems[0].duration) * 60 : 3600;
            
            // Start points earning
            startPointsEarning();
            
            // Initialize backend if available
            if (window.RumiBackend) {
                window.RumiBackend.startSession();
                console.log('Backend session started');
            }
            
            // Show the indexing view (nokia content) - Section 3b
            const homeContent = document.getElementById('home-content');
            const nokiaContent = document.getElementById('nokia-content');
            
            if (homeContent) homeContent.style.display = 'none';
            if (nokiaContent) nokiaContent.style.display = 'block';
            
            // Update UI to show indexing mode
            updateUI();
            
            // Explicitly show the automode channel section for indexing view
            const automodeChannelSection = document.getElementById('automode-channel-section-indexing');
            if (automodeChannelSection) {
                automodeChannelSection.style.display = 'block';
                console.log('Automode channel section explicitly shown for indexing');
            } else {
                console.log('Automode channel section not found for explicit show');
            }
            
            // Update debug button states
            updateDebugButtonStates();
            
            console.log('Automode indexing session started - advanced to Section 3b');
        }

        function activateExtension() {
            const popup = document.querySelector('.extension-popup');
            const activationCircle = document.getElementById('activation-circle');
            
            // Activate the circle with visual feedback and make popup semi-transparent
            activationCircle.classList.add('activated');
            popup.classList.add('clicked');
            
            // After a brief delay, remove the clicked state and proceed
            setTimeout(() => {
                // Remove clicked state and restore full opacity
                popup.classList.remove('deactivated');
                popup.classList.remove('clicked');
                activationCircle.style.display = 'none';
                activationCircle.classList.remove('activated');
                
                // Now proceed with the normal flow based on pending entry point
                if (appState.pendingEntryPoint === 'detection') {
                    // Set the state to show indexing screen but NOT start indexing yet
                    appState.isIndexing = false;
                    appState.entryPoint = 'detection';
                    appState.detectedShow = appState.pendingDetectedShow;
                    appState.pendingShowForGenreChannel = appState.pendingDetectedShow;
                    
                    // Initialize transition system immediately for detection mode
                    if (!window.transitionSystem) {
                        console.log('Auto-initializing transition system for detection mode...');
                        initializeTransitionSystem();
                    }
                    
                    // Set channel expansion state for new entry point (show by default in detection mode)
                    appState.channelExpanded = true;

                    // Update UI after state is set
                    updateUI();

                    // Update the UI elements within the indexing view
                    if (appState.pendingDetectedShow && appState.pendingDetectedShow.title) {
                        showDetectedShowUI(appState.pendingDetectedShow.title);
                    }

                    // Send show detection to genre channel
                    setTimeout(() => {
                        sendShowDetection(appState.pendingShowForGenreChannel);
                    }, 500);
                    
                } else if (appState.pendingEntryPoint === 'automode') {
                    // Set the state to show indexing screen but NOT start indexing yet
                    appState.isIndexing = false;
                    appState.entryPoint = 'automode';
                    detectedShow = null; // Clear detectedShow for automode

                    // Ensure we're on the Rumi channel for automode
                    currentChannel = 'rumi';
                    
                    // Reset channel expansion state for new entry point
                    appState.channelExpanded = false;
                    
                    // Show the start learning button for section 2b
                    const startLearningButton = document.getElementById('start-learning-button');
                    if (startLearningButton) {
                        startLearningButton.style.display = 'block';
                        startLearningButton.textContent = `START LEARNING ${appState.currentBucket}`;
                    }
                    
                    // Show the description for the selected bucket
                    showAutomodeDescription(appState.currentBucket);
                    
                    // Update UI after state is set
                    updateUI();

                    // Force update the expandable channel UI to show the correct channel
                    updateExpandableChannelUI();
                }
                
                // Clear pending entry point (but keep pendingShowForGenreChannel for the setTimeout)
                appState.pendingEntryPoint = null;
                appState.pendingDetectedShow = null;
                
            }, 500); // 500ms delay for visual feedback
        }

        function updateEntryPointForNextStep() {
            // Update the integrated detection section to show indexing state
            const detectionSection = document.querySelector('.entry-point-panel > div[style*="00ff41"]');
            if (detectionSection && detectedShow) {
                detectionSection.innerHTML = `
                    <div style="font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">⏳ INDEXING IN PROGRESS</div>
                    <div style="font-size: 11px; margin-bottom: 10px; color: rgba(0,0,0,0.8);">
                    Current Show: <strong>${detectedShow.title}</strong>
                </div>
                    <button class="secondary-button" onclick="simulateShowChange()" style="width: 100%; background: rgba(255,170,0,0.2); border: 1px solid rgba(255,170,0,0.5); color: #000; padding: 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">
                    Simulate User Changing Show
                </button>
            `;
            }
        }

        function simulateShowChange() {
            // Pick a new random show
            const newShow = availableShows.find(s => s.title !== detectedShow.title) || availableShows[0];
            
            // Stop current indexing if active
            if (appState.isIndexing) {
            stopIndexing();
            }
            
            // Update the detected show
            detectedShow = newShow;
            appState.detectedShow = newShow;
            appState.pendingShowForGenreChannel = newShow;
            
            // Update the entry point UI
            updateEntryPointForNextStep();
            
            // Send the new show detection
            setTimeout(() => {
                sendShowDetection(newShow);
            }, 500);
        }

        // Cache control function removed - cache button integrated elsewhere

        // Add new message listeners for genre channel coordination
        window.addEventListener('message', (event) => {
    const message = event.data;

    if (!message) return; // Ignore empty messages

    console.log('Main window received message:', message);

    switch(message.type) {
        case 'rumi:setBucket': {
            const { bucket } = message.payload;
            if (bucket) {
                appState.currentBucket = bucket;
                console.log('Rumi channel bucket updated:', appState.currentBucket);
            }
            break;
        }
        case 'genreChannelReady': {
            console.log('Genre channel ready, sending pending show detection');
            console.log('pendingShowForGenreChannel:', appState.pendingShowForGenreChannel);
            if (appState.pendingShowForGenreChannel) {
                sendShowDetection(appState.pendingShowForGenreChannel);
            } else {
                console.log('No pending show for genre channel');
            }
            break;
        }
        case 'rumiChannelReady': {
            // Rumi channel is ready, no special action needed for automode
            console.log('Rumi channel ready');
            break;
        }
        case 'genreChangeComplete': {
            if (appState.pendingShowForGenreChannel) {
                // Now that the genre channel is confirmed to be updated, start indexing.
                startIndexing();
                updateEntryPointForNextStep();
                
                // Clear the pending state
                appState.pendingShowForGenreChannel = null;
            }
            break;
        }
        case 'rumi:showSelected': {
            // Handle show selection from channel for transition
            const { showData } = message.payload;
            if (showData && appState.isIndexing) {
                console.log('Show selected for transition from channel:', showData);
                
                // Convert channel data to show format
                const newShow = {
                    title: showData.title,
                    season: showData.season || 'N/A',
                    episode: showData.episode || 'N/A',
                    service: showData.service,
                    genre: showData.genre || 'Unknown',
                    duration: showData.duration || 45,
                    type: showData.type || 'show'
                };
                
                // Trigger transition using the transition system
                transitionToShowWithSystem(newShow);
                
                Tracker.logRumiAction('Show transition via channel selection', { 
                    fromShow: appState.detectedShow?.title,
                    toShow: newShow.title 
                });
            }
            break;
        }
        case 'indexedContentUpdate': {
            // Handle indexed content updates from genre channel
            console.log('🔍 [DEBUG] Received indexedContentUpdate message:', message);
            const { indexedContent, totalIndexed } = message.payload;
            if (indexedContent && appState.isIndexing) {
                console.log('📋 [DEBUG] Processing indexed content update:', totalIndexed, 'items indexed');
                console.log('🔍 [DEBUG] Indexed content:', indexedContent);
                appState.indexedContent = indexedContent;
                
                // Update holistic indexing panel with real progress
                updateHolisticIndexingPanel();
                
                Tracker.logRumiAction('Indexed content updated', { 
                    totalIndexed: totalIndexed,
                    entryPoint: appState.entryPoint
                });
            } else {
                console.log('⚠️ [DEBUG] Indexed content update ignored - not indexing or no content');
            }
            break;
        }
        case 'rumi:updateBlockState': {
            // Handle block state updates from genre channel
            console.log('🔍 [DEBUG] Received rumi:updateBlockState message:', message);
            const { title, state, timestamp } = message.payload;
            if (title && state && appState.isIndexing) {
                console.log(`📊 [DEBUG] Processing block state update: "${title}" -> ${state}`);
                
                // Update holistic indexing panel with current block status
                updateHolisticIndexingPanel(title, state);
                
                Tracker.logRumiAction('Block state updated', { 
                    title: title,
                    state: state,
                    entryPoint: appState.entryPoint
                });
            } else {
                console.log('⚠️ [DEBUG] Block state update ignored - not indexing or missing data');
            }
            break;
        }
        case 'currentContentResponse': {
            // Handle current content response from genre channel
            console.log('🔍 [DEBUG] Received currentContentResponse:', message);
            const content = message.content || [];
            console.log('📋 [DEBUG] Channel content:', content.length, 'items');
            if (content.length > 0) {
                console.log('🔍 [DEBUG] First content item:', content[0]);
                console.log('🔍 [DEBUG] Content titles:', content.map(item => item.title));
                
                // Update total blocks for detection mode
                if (appState.entryPoint === 'detection') {
                    appState.totalBlocks = content.length;
                    console.log('🔍 [DEBUG] Set total blocks for detection mode:', appState.totalBlocks);
                    updateBlockProgressionDisplay();
                }
                
                // Convert channel content to proper format for timeline
                const timelineContent = content.map(item => ({
                    title: item.title,
                    duration: item.duration * 60, // Convert minutes to seconds
                    type: item.type || 'show',
                    service: item.service || 'UNKNOWN',
                    season: item.season || 'N/A',
                    episode: item.episode || 'N/A'
                }));
                
                // Update SynchronizedTimeline with new content to recalculate session duration
                if (timelineContent.length > 0) {
                    SynchronizedTimeline.initializeTimeline(timelineContent);
                    console.log('🎯 [DEBUG] Updated SynchronizedTimeline with new content - session duration recalculated');
                    
                    // Update cached session duration
                    appState.cachedSessionDuration = SynchronizedTimeline.totalContentDuration;
                    appState.cachedSessionDurationTimestamp = Date.now();
                    
                    // Update automode content items if in automode
                    if (appState.entryPoint === 'automode') {
                        appState.automodeContentItems = timelineContent;
                        console.log('🎯 [DEBUG] Updated automode content items with new timeline');
                    }
                    
                    // Refresh timing displays
                    if (appState.isIndexing) {
                        const elapsedTime = TimeSystem.getElapsedTime();
                        updateAnimationPanel(elapsedTime);
                        updatePointsDisplay();
                        
                        // Refresh progress bar with new session duration
                        const sessionDuration = TimeSystem.getSessionDuration();
                        const progress = TimeSystem.getProgress();
                        console.log('🎯 [DEBUG] Session duration updated:', sessionDuration / 60, 'minutes');
                        console.log('🎯 [DEBUG] Progress recalculated:', (progress * 100).toFixed(1) + '%');
                        
                        // Refresh multiplier calculation with new session duration
                        const newMultiplier = TimeSystem.calculateCurrentMultiplier(elapsedTime, sessionDuration);
                        if (Math.abs(newMultiplier - appState.currentMultiplier) >= 0.01) {
                            appState.currentMultiplier = newMultiplier;
                            console.log('🎯 [DEBUG] Multiplier updated with new session duration:', newMultiplier.toFixed(2) + 'x');
                        }
                        
                        console.log('🎯 [DEBUG] Refreshed timing displays with new session duration');
                    }
                }
            }
            break;
        }
        case 'contentCountUpdate': {
            // Handle content count update from genre channel
            console.log('📊 [DEBUG] Received contentCountUpdate:', message);
            const { totalBlocks, totalDuration } = message.payload;
            
            // Update total blocks count
            appState.totalBlocks = totalBlocks;
            console.log('📊 [DEBUG] Updated total blocks count:', appState.totalBlocks);
            
            if (totalDuration) {
                console.log('📊 [DEBUG] Content duration changed to:', totalDuration, 'minutes');
            }
            
            // Update block progression display
            updateBlockProgressionDisplay();
            
            // Request updated content from genre channel to recalculate session duration
            requestContentFromGenreChannel();
            
            // Refresh ASCII animation panel to show updated block numbers
            if (appState.isIndexing) {
                const elapsedTime = TimeSystem.getElapsedTime();
                updateAnimationPanel(elapsedTime);
                
                // Also refresh the sophisticated ASCII animation system
                if (window.ASCIIAnimationState) {
                    window.ASCIIAnimationState.updateDisplay();
                    console.log('🎨 [DEBUG] Refreshed sophisticated ASCII animation system with new block count');
                }
                
                console.log('🎨 [DEBUG] Refreshed ASCII animation panel with new block count');
            }
            
            break;
        }
    }
});

        // Entry Point 1: Launch with a detected show
        function launchWithShowDetection(show) {
            if (!show) return;

            appState.entryPoint = 'showDetection';
            Tracker.logRumiAction('Launch via show detection', { showTitle: show.title });

            // Set the detected show state immediately
            updateDetectedShowState(show); // Pass the whole show object

            // Switch to the Genre Channel view programmatically
            switchToGenreChannel();

            // Store the show data to be sent after the channel is ready
            appState.pendingShowForGenreChannel = show;
        }

        // This function sets the application state when a show is detected.
        // It's a key part of the entry point 1 flow.
        function updateDetectedShowState(show) {
            appState.detectedShow = show;
            showDetectedShowUI(show.title);
        }

        // Show receipt with mode-specific data
        function showReceipt(sessionEarnings, sessionDuration, finalMultiplier) {
            Tracker.logRumiAction('Receipt shown', { 
                sessionEarnings, 
                sessionDuration, 
                finalMultiplier,
                mode: appState.entryPoint
            });
            
            // Hide main view and show receipt view
            document.getElementById('main-view').style.display = 'none';
            document.getElementById('receipt-overlay').style.display = 'block';
            
            // Populate receipt data
            document.getElementById('receipt-total-points').textContent = `+${sessionEarnings.toFixed(2)}`;
            document.getElementById('receipt-total-pending').textContent = `+${(appState.totalPendingPoints + sessionEarnings).toFixed(2)}`;
            document.getElementById('receipt-duration').textContent = formatTime(sessionDuration);
            document.getElementById('receipt-multiplier').textContent = `${finalMultiplier.toFixed(1)}x`;
            
            // Set bonus text based on multiplier
            const bonusElement = document.getElementById('receipt-bonus');
            if (finalMultiplier >= 1.2) {
                bonusElement.textContent = '10min Streak Bonus';
                bonusElement.style.color = '#ffaa00';
            } else {
                bonusElement.textContent = 'None';
                bonusElement.style.color = '#888';
            }
            
            // Generate mode-specific content list
            generateReceiptContentList(sessionDuration, appState.entryPoint);
            
            Tracker.assertRumi('Receipt view displayed', true, 'Receipt should show session results');
        }

        // Helper function to get related content based on genre with points calculation - returns empty array
        function getRelatedContentWithPoints(genre, remainingTime, baseRate, multiplier) {
            console.log('🔍 [DEBUG] Related content requested, returning empty array - all content should come from CSV');
            // Return empty array - all content should come from CSV
            return [];
        }

        // Removed duplicate getAutomodeContent function - using CSV-based version only

        // Helper function to get generic content with points calculation - returns empty array
        function getGenericContentWithPoints(sessionDuration, baseRate, multiplier) {
            console.log('🔍 [DEBUG] Generic content requested, returning empty array - all content should come from CSV');
            // Return empty array - all content should come from CSV
            return [];
        }

        // Helper function to get show detection content based on detected show
        function getShowDetectionContent(detectedShow, sessionDuration) {
            // Get actual content from the channel iframe
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    // Request current content from the channel
                    channelFrame.contentWindow.postMessage({ 
                        type: 'requestCurrentContent' 
                    }, '*');
                    
                    // For now, return a placeholder - the actual content will be set via message handler
                    return [];
                } catch (e) {
                    console.log('Could not request content from channel:', e.message);
                }
            }
            
            // Fallback: return empty array - content will be populated via message handler
            return [];
        }

        // NEW: Message handler for channel content
        window.addEventListener('message', function(event) {
            if (event.data.type === 'currentContentResponse') {
                console.log('Received current content from channel:', event.data.content);
                
                // Convert channel content to show detection content format
                const channelContent = event.data.content || [];
                const showDetectionContent = channelContent.map(item => ({
                    title: item.title,
                    duration: item.duration * 60, // Convert minutes to seconds
                    type: item.type || 'show',
                    service: item.service || 'UNKNOWN',
                    season: item.season || 'N/A',
                    episode: item.episode || 'N/A'
                }));
                
                // Update the automode content items with actual channel content
                appState.automodeContentItems = showDetectionContent;
                
                // Initialize synchronized timeline with actual content
                if (showDetectionContent.length > 0) {
                    SynchronizedTimeline.initializeTimeline(showDetectionContent);
                    console.log('🎯 SynchronizedTimeline: Initialized with channel content');
                }
                
                // Recalculate content item duration if we have items
                if (showDetectionContent.length > 0) {
                    const firstItem = showDetectionContent[0];
                    appState.contentItemDuration = firstItem.duration;
                    console.log(`Updated show detection content with ${showDetectionContent.length} items from channel`);
                    console.log(`First item: ${firstItem.title}, duration: ${firstItem.duration} seconds`);
                    
                    // If we're currently indexing, update the UI to reflect the new content
                    if (appState.isIndexing) {
                        // Force an immediate animation update with the new content
                        const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                        updateAnimationPanel(elapsedTime);
                        updatePointsDisplay();
                        
                        // Update the button text to show the current show
                        const ctaButton = document.getElementById('cta-button');
                        if (ctaButton && appState.entryPoint === 'detection') {
                            const show = firstItem;
                            if (show.season !== 'N/A' && show.episode !== 'N/A') {
                                ctaButton.textContent = `START WATCHING ${show.title} S${show.season}E${show.episode}`;
                            } else {
                                ctaButton.textContent = `START WATCHING ${show.title}`;
                            }
                        }
                    }
                }
            }
        });

        // Debug Panel Collapsible Functions
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            const content = document.getElementById('debug-panel-content');
            const toggle = document.getElementById('debug-panel-toggle');
            
            if (panel.classList.contains('visible')) {
                // Hide the panel
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            } else {
                // Show the panel
                panel.classList.add('visible');
                trigger.style.display = 'none';
                
                // Expand the content when showing
                content.classList.remove('collapsed');
                toggle.textContent = '▼';
                toggle.classList.remove('collapsed');
                
                // Expand error testing section by default (most commonly used)
                const errorTestingContent = document.getElementById('error-testing-content');
                const errorTestingToggle = document.getElementById('error-testing-toggle');
                if (errorTestingContent && errorTestingToggle) {
                    errorTestingContent.classList.remove('collapsed');
                    errorTestingToggle.textContent = '▼';
                    errorTestingToggle.classList.remove('collapsed');
                }
            }
        }

        function toggleDebugSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const toggle = document.getElementById(sectionId + '-toggle');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = '▼';
                toggle.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.textContent = '▶';
                toggle.classList.add('collapsed');
            }
        }

        // Initialize debug panel state
        document.addEventListener('DOMContentLoaded', function() {
            // Start with debug panel hidden and trigger visible
            const panel = document.getElementById('debug-panel');
            const trigger = document.querySelector('.debug-trigger');
            
            if (panel && trigger) {
                panel.classList.remove('visible');
                trigger.style.display = 'block';
            }
            
            // Start with sections collapsed
            const basicTestingContent = document.getElementById('basic-testing-content');
            const errorTestingContent = document.getElementById('error-testing-content');
            const sessionManagementContent = document.getElementById('session-management-content');
            const basicTestingToggle = document.getElementById('basic-testing-toggle');
            const errorTestingToggle = document.getElementById('error-testing-toggle');
            const sessionManagementToggle = document.getElementById('session-management-toggle');
            
            if (basicTestingContent && errorTestingContent && sessionManagementContent) {
                basicTestingContent.classList.add('collapsed');
                errorTestingContent.classList.add('collapsed');
                sessionManagementContent.classList.add('collapsed');
                basicTestingToggle.textContent = '▶';
                errorTestingToggle.textContent = '▶';
                sessionManagementToggle.textContent = '▶';
                basicTestingToggle.classList.add('collapsed');
                errorTestingToggle.classList.add('collapsed');
                sessionManagementToggle.classList.add('collapsed');
            }

            // Initialize debug button states
            updateDebugButtonStates();
        });

        // Keyboard shortcut for debug panel (Ctrl+Shift+D)
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.shiftKey && event.key === 'D') {
                event.preventDefault();
                toggleDebugPanel();
            }
        });

        // Hide receipt overlay
        function hideReceiptView() {
            Tracker.logRumiAction('Receipt view hidden');
            
            // Keep header consistent - no need to change it
            // const headerControls = document.querySelector('.header-controls');
            // if (headerControls) {
            //     headerControls.innerHTML = '<div class="popup-balance">BALANCE: 4,349 PTS</div><button class="settings-button" onclick="showSettingsView()">⚙ SETTINGS</button>';
            // }
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // CRITICAL: Reset all session state to allow new sessions to start
            appState.isIndexing = false;
            appState.indexingStartTime = null; // This is crucial - allows new sessions to start
            appState.sessionCompleted = false;
            appState.sessionEarnings = 0;
            appState.sessionEndReason = null;
            appState.isPaused = false;
            appState.pauseStartTime = null;
            appState.pauseDuration = 0;
            appState.showInterruptTimestamp = null;
            appState.firstBlockCompleted = false;
            appState.watchWithUsPromptShown = false;
            appState.pausedForWatchWithUs = false;
            appState.currentBlockIndex = 0;
            appState.totalBlocks = 0;
            appState.indexedContent = []; // Clear previous session's indexed content
            appState.userChoice = null; // Reset user choice
            appState.showChoicePrompt = false;
            
            // Reset content tracking
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = 0;
            appState.contentTransitionProgress = 0;
            appState.automodeContentItems = []; // Clear previous session's content
            
            // Reset multiplier
            appState.currentMultiplier = 1.0;
            
            // Reset transition system if available
            if (window.transitionSystem && window.transitionSystem.startNewSession) {
                window.transitionSystem.startNewSession();
            }
            
            // Reset synchronized timeline
            if (SynchronizedTimeline && SynchronizedTimeline.reset) {
                SynchronizedTimeline.reset();
            }
            
            // Stop any running intervals or timers
            if (UnifiedTimeSync && UnifiedTimeSync.stop) {
                UnifiedTimeSync.stop();
            }
            
            // Clear any animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Clear any point accrual intervals
            if (pointAccrualInterval) {
                clearInterval(pointAccrualInterval);
                pointAccrualInterval = null;
            }
            
            // Clear any indexing timer intervals
            if (indexingTimerInterval) {
                clearInterval(indexingTimerInterval);
                indexingTimerInterval = null;
            }
            
            // Update UI
            updateUI();
            updatePointsDisplay();
            
            // Clean up modal timeout
            if (appState.watchWithUsModalTimeout) {
                clearTimeout(appState.watchWithUsModalTimeout);
                appState.watchWithUsModalTimeout = null;
            }
            
            console.log('Session state fully reset from hideReceiptView - ready for new indexing session');
        }

        function returnToEntryPoint() {
            const originalEntryPoint = appState.entryPoint; // Store before resetting
            Tracker.logRumiAction('Returning to indexing screen', { entryPoint: originalEntryPoint });
            
            // Hide receipt view and show main view
            document.getElementById('receipt-view').style.display = 'none';
            document.getElementById('main-view').style.display = 'block';
            document.getElementById('settings-view').style.display = 'none';
            
            // Show the extension popup
            const popup = document.querySelector('.extension-popup');
            if (popup) {
                popup.style.display = 'flex';
            }
            
            // Hide the entry point panel
            const entryPointPanel = document.querySelector('.entry-point-panel');
            if (entryPointPanel) {
                entryPointPanel.style.display = 'none';
            }
            
            // Show the user changes content button
            const userChangesBtn = document.getElementById('user-changes-content-btn');
            if (userChangesBtn) {
                userChangesBtn.style.display = 'block';
            }
            
            // CRITICAL: Reset all session state to allow new sessions to start
            appState.isIndexing = false;
            appState.indexingStartTime = null; // This is crucial - allows new sessions to start
            appState.sessionCompleted = false;
            appState.sessionEarnings = 0;
            appState.sessionEndReason = null;
            appState.isPaused = false;
            appState.pauseStartTime = null;
            appState.pauseDuration = 0;
            appState.showInterruptTimestamp = null;
            appState.firstBlockCompleted = false;
            appState.watchWithUsPromptShown = false;
            appState.pausedForWatchWithUs = false;
            appState.currentBlockIndex = 0;
            appState.totalBlocks = 0;
            appState.indexedContent = []; // Clear previous session's indexed content
            appState.userChoice = null; // Reset user choice
            appState.showChoicePrompt = false;
            
            // Reset content tracking
            appState.currentContentIndex = 0;
            appState.contentItemStartTime = 0;
            appState.contentItemDuration = 0;
            appState.contentTransitionProgress = 0;
            appState.automodeContentItems = []; // Clear previous session's content
            
            // Reset multiplier
            appState.currentMultiplier = 1.0;
            
            // Keep the same entry point for continuity
            appState.entryPoint = originalEntryPoint;
            
            // Reset transition system if available
            if (window.transitionSystem && window.transitionSystem.startNewSession) {
                window.transitionSystem.startNewSession();
            }
            
            // Reset synchronized timeline
            if (SynchronizedTimeline && SynchronizedTimeline.reset) {
                SynchronizedTimeline.reset();
            }
            
            // Stop any running intervals or timers
            if (UnifiedTimeSync && UnifiedTimeSync.stop) {
                UnifiedTimeSync.stop();
            }
            
            // Clear any animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Clear any point accrual intervals
            if (pointAccrualInterval) {
                clearInterval(pointAccrualInterval);
                pointAccrualInterval = null;
            }
            
            // Clear any indexing timer intervals
            if (indexingTimerInterval) {
                clearInterval(indexingTimerInterval);
                indexingTimerInterval = null;
            }
            
            // Update UI to show the indexing screen
            updateUI();
            updatePointsDisplay();
            
            // If we came from detection, restore the detected show
            if (originalEntryPoint === 'detection' && detectedShow) {
                appState.detectedShow = detectedShow;
                showDetectedShowUI(detectedShow.title);
            }
            
            // Clean up modal timeout
            if (appState.watchWithUsModalTimeout) {
                clearTimeout(appState.watchWithUsModalTimeout);
                appState.watchWithUsModalTimeout = null;
            }
            
            console.log('Session state fully reset - ready for new indexing session');
        }

        // --- Expandable Channel Section Logic ---
        function toggleChannelExpansion() {
            const expandedContainer = document.getElementById('channel-expanded-container');
            const expandHeader = document.getElementById('expand-channel-header');
            const expandText = document.getElementById('expand-channel-text');
            const expandIcon = document.getElementById('expand-channel-icon');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Channel expansion elements not found');
                return;
            }
            
            // Mark this as a user-initiated change
            appState.userInitiatedChannelChange = true;
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '▲';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '▼';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // --- Expandable Channel Section Logic for Indexing View ---
        function toggleChannelExpansionIndexing() {
            const expandedContainer = document.getElementById('channel-expanded-container-indexing');
            const expandHeader = document.getElementById('expand-channel-header-indexing');
            const expandText = document.getElementById('expand-channel-text-indexing');
            const expandIcon = document.getElementById('expand-channel-icon-indexing');
            
            if (!expandedContainer || !expandHeader || !expandText || !expandIcon) {
                console.error('Indexing channel expansion elements not found');
                return;
            }
            
            // Use the same state as the main channel expansion
            // Mark this as a user-initiated change
            appState.userInitiatedChannelChange = true;
            appState.channelExpanded = !appState.channelExpanded;
            expandedContainer.style.display = appState.channelExpanded ? 'block' : 'none';
            
            // Set contextual button text based on entry point and state
            if (appState.channelExpanded) {
                expandText.textContent = 'HIDE CHANNEL';
                expandIcon.textContent = '▲';
                // Set iframe to fixed height for consistent display
                const channelFrame = document.getElementById('channel-frame-indexing');
                if (channelFrame) {
                    channelFrame.style.visibility = 'visible';
                    channelFrame.style.height = '320px';
                }
            } else {
                if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else if (appState.entryPoint === 'automode') {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'SHOW CHANNEL';
                }
                expandIcon.textContent = '▼';
            }
            
            // Reduce the simulation-container height when channel is expanded
            const simContainer = document.querySelector('.simulation-container');
            if (simContainer) {
                if (appState.channelExpanded) {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '500px'; // Reduced from 600px
                } else {
                    simContainer.style.height = 'auto';
                    simContainer.style.minHeight = '600px';
                }
            }
            
            Tracker.logRumiAction('Indexing channel expansion toggled', { expanded: appState.channelExpanded });
        }

        // Debug function to check channel state
        function debugChannelState() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            
            console.log('=== Channel Debug Info ===');
            console.log('Entry Point:', appState.entryPoint);
            console.log('Channel Expanded:', appState.channelExpanded);
            console.log('Expandable Section Display:', expandableSection ? expandableSection.style.display : 'NOT FOUND');
            console.log('Expanded Container Display:', expandedContainer ? expandedContainer.style.display : 'NOT FOUND');
            console.log('Channel Frame Src:', channelFrame ? channelFrame.src : 'NOT FOUND');
            
            // Try to access iframe content to see if genre channel is working
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    if (channelTitle) {
                        console.log('Genre Channel Title:', channelTitle.textContent);
                    } else {
                        console.log('Genre Channel Title: NOT FOUND');
                    }
                    
                    // Check if there's content in the program track
                    const programTrack = iframeDocument.getElementById('program-track');
                    if (programTrack) {
                        console.log('Program Track Children:', programTrack.children.length);
                        if (programTrack.children.length > 0) {
                            console.log('First Program Item:', programTrack.children[0].textContent);
                        }
                    } else {
                        console.log('Program Track: NOT FOUND');
                    }
                } catch (e) {
                    console.log('Cannot access iframe content (CORS or not loaded):', e.message);
                }
            }
            
            console.log('========================');
        }

        // Update UI based on current state (additions for expandable channel)
        function updateExpandableChannelUI() {
            const expandableSection = document.getElementById('expandable-channel-section');
            const expandedContainer = document.getElementById('channel-expanded-container');
            const channelFrame = document.getElementById('channel-frame');
            const expandText = document.getElementById('expand-channel-text');
            
            // Indexing view elements
            const expandableSectionIndexing = document.getElementById('expandable-channel-section-indexing');
            const expandedContainerIndexing = document.getElementById('channel-expanded-container-indexing');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            const expandTextIndexing = document.getElementById('expand-channel-text-indexing');
            
            if (!expandableSection || !expandedContainer || !channelFrame || !expandText) return;

            console.log('updateExpandableChannelUI called, entry point:', appState.entryPoint);

            // Only show expandable section if in entry point mode
            if (appState.entryPoint === 'detection' || appState.entryPoint === 'showDetection') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WATCH YOUR NEXT SHOW WITH US';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // MODAL FIX: Prevent iframe reset during active sessions unless explicitly needed
                // Only set the src if it's not already correct AND we're not in an active session
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                console.log('Current channel frame src:', currentSrc);
                
                // Check if we should avoid resetting the iframe
                const shouldAvoidReset = appState.isIndexing && !appState.userInitiatedChannelChange;
                
                if (!currentSrc.includes('genre-channel-optimized_LUDICROUS_WORKING.html') && !shouldAvoidReset) {
                    console.log('Changing channel frame src to genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected');
                    channelFrame.src = 'genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected';
                    console.log('Channel frame src after change:', channelFrame.src);
                    if (channelFrameIndexing) {
                        console.log('Changing indexing channel frame src to genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected');
                        channelFrameIndexing.src = 'genre-channel-optimized_LUDICROUS_WORKING.html?mode=detected';
                        console.log('Indexing channel frame src after change:', channelFrameIndexing.src);
                    }
                    console.log('Detection mode: Set channel to genre-channel-optimized_LUDICROUS_WORKING.html with detected mode');
                    
                    // Check if iframe loads after a delay
                    setTimeout(() => {
                        console.log('Checking iframe src after 2 seconds:', channelFrame.src);
                        if (channelFrameIndexing) {
                            console.log('Checking indexing iframe src after 2 seconds:', channelFrameIndexing.src);
                        }
                    }, 2000);
                } else if (shouldAvoidReset) {
                    console.log('🚫 Preventing iframe reset during active session (modal protection)');
                } else {
                    console.log('Channel frame already pointing to genre-channel-optimized_LUDICROUS_WORKING.html');
                }
            } else if (appState.entryPoint === 'automode') {
                expandableSection.style.display = 'block';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'block';
                
                // Set contextual button text for both views
                if (!appState.channelExpanded) {
                    expandText.textContent = 'WHAT ARE WE LEARNING';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'WHAT ARE WE LEARNING';
                } else {
                    expandText.textContent = 'HIDE CHANNEL';
                    if (expandTextIndexing) expandTextIndexing.textContent = 'HIDE CHANNEL';
                }
                
                // MODAL FIX: Apply same protection for automode
                const currentSrc = channelFrame.src ? channelFrame.src.split('/').pop() : '';
                const shouldAvoidReset = appState.isIndexing && !appState.userInitiatedChannelChange;
                
                if (currentSrc !== 'rumi-channel.html' && !shouldAvoidReset) {
                    channelFrame.src = 'rumi-channel.html';
                    if (channelFrameIndexing) channelFrameIndexing.src = 'rumi-channel.html';
                    console.log('Automode: Set channel to rumi-channel.html');
                } else if (shouldAvoidReset) {
                    console.log('🚫 Preventing iframe reset during active session (modal protection - automode)');
                }
            } else {
                expandableSection.style.display = 'none';
                if (expandableSectionIndexing) expandableSectionIndexing.style.display = 'none';
            }
            
            // Synchronize expansion state between both views
            if (expandedContainerIndexing) {
                expandedContainerIndexing.style.display = expandedContainer.style.display;
            }
            
            // Reset the user-initiated flag after processing
            if (appState.userInitiatedChannelChange) {
                appState.userInitiatedChannelChange = false;
            }
            
            // Debug the channel state
            debugChannelState();
        }

        // Patch updateUI to call updateExpandableChannelUI
        const _originalUpdateUI = updateUI;
        updateUI = function() {
            _originalUpdateUI.apply(this, arguments);
            updateExpandableChannelUI();
        };
        // Call on load
        document.addEventListener('DOMContentLoaded', function() {
            updateExpandableChannelUI();
        });

        function checkGenreChannelContent() {
            console.log('=== Checking Genre Channel Content ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    
                    // Check for genre channel specific elements
                    const channelTitle = iframeDocument.querySelector('.channel-title');
                    console.log('Channel title element:', channelTitle ? channelTitle.textContent : 'NOT FOUND');
                    
                    const programTrack = iframeDocument.getElementById('program-track');
                    console.log('Program track element:', programTrack ? 'FOUND' : 'NOT FOUND');
                    
                    if (programTrack) {
                        console.log('Program track children count:', programTrack.children.length);
                        for (let i = 0; i < Math.min(3, programTrack.children.length); i++) {
                            const child = programTrack.children[i];
                            console.log(`Program item ${i + 1}:`, child.textContent.trim());
                        }
                    }
                    
                    // Check for genre dropdown
                    const genreDropdown = iframeDocument.getElementById('genre-select');
                    console.log('Genre dropdown:', genreDropdown ? genreDropdown.value : 'NOT FOUND');
                    
                    // Check for any error messages or loading states
                    const errorElements = iframeDocument.querySelectorAll('.error, .loading, .status');
                    if (errorElements.length > 0) {
                        console.log('Error/status elements found:');
                        errorElements.forEach(el => console.log('-', el.textContent));
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            }
            
            console.log('=== End Genre Channel Check ===');
        }

        // Debug function to test Planet Earth II detection specifically
        function testPlanetEarthDetection() {
            console.log('=== Testing Planet Earth II Detection ===');
            
            // Set the entry point to detection mode so the genre channel gets loaded
            appState.entryPoint = 'detection';
            console.log('Set entry point to detection mode');
            
            const planetEarthShow = {
                title: 'Planet Earth II',
                genre: 'Documentary',
                service: 'DISCOVERY+',
                season: 'S1',
                episode: 'E1'
            };
            
            console.log('Sending Planet Earth II detection:', planetEarthShow);
            
            // Update the UI to load the genre channel first
            updateExpandableChannelUI();
            
            // Wait for the channel to load, then send the detection
            setTimeout(() => {
                // Check if the channel loaded correctly before sending the message
                checkGenreChannelLoaded();
                
                // Send the show detection
                sendShowDetection(planetEarthShow);
                
                // Check the channel content after a delay
                setTimeout(() => {
                    console.log('Checking channel content after Planet Earth II detection...');
                    checkGenreChannelContent();
                }, 2000);
            }, 2000); // Increased delay to ensure channel loads
        }

        // Simple test to verify message passing to genre channel
        function testMessagePassing() {
            console.log('=== Testing Message Passing ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            
            // Send a simple test message
            const testMessage = {
                type: 'test-message',
                payload: { test: 'Hello from main window' }
            };
            
            console.log('Sending test message:', testMessage);
            
            if (channelFrame.contentWindow) {
                try {
                    channelFrame.contentWindow.postMessage(testMessage, '*');
                    console.log('Test message sent successfully');
                } catch (e) {
                    console.error('Error sending test message:', e);
                }
            } else {
                console.log('Channel frame not ready');
            }
        }

        // Function to check if genre channel is actually loaded
        function checkGenreChannelLoaded() {
            console.log('=== Checking Genre Channel Loaded ===');
            
            const channelFrame = document.getElementById('channel-frame');
            if (!channelFrame) {
                console.log('Channel frame not found');
                return;
            }
            
            console.log('Channel frame src:', channelFrame.src);
            console.log('Channel frame readyState:', channelFrame.contentWindow ? 'loaded' : 'not loaded');
            
            if (channelFrame.contentWindow) {
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    console.log('Iframe document title:', iframeDocument.title);
                    console.log('Iframe document readyState:', iframeDocument.readyState);
                    
                    // Check if it's actually the genre channel
                    if (iframeDocument.title === 'Rumi Genre Channel') {
                        console.log('✅ Genre channel is loaded correctly');
                    } else {
                        console.log('❌ Wrong channel loaded:', iframeDocument.title);
                    }
                    
                    // Try to access a genre channel specific element
                    const genreSelect = iframeDocument.getElementById('genre-select');
                    if (genreSelect) {
                        console.log('✅ Genre select element found');
                    } else {
                        console.log('❌ Genre select element not found');
                    }
                    
                } catch (e) {
                    console.log('Error accessing iframe content:', e.message);
                }
            } else {
                console.log('❌ Channel frame not ready');
            }
        }

        // Expandable sections functionality
        function expandSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('expanded');
            }
        }

        function collapseSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.remove('expanded');
            }
        }

        function collapseAllSections() {
            const sections = document.querySelectorAll('.expandable-section');
            sections.forEach(section => {
                section.classList.remove('expanded');
            });
        }

        // Auto-expand sections based on state
        function autoExpandSections(state) {
            // Collapse all sections first
            collapseAllSections();
            
            // Auto-expand based on state
            switch(state) {
                case 'system-error':
                case 'network-error':
                case 'browser-error':
                    expandSection('error-details-section');
                    break;
                case 'user-error':
                case 'speed-error':
                case 'language-error':
                case 'warning':
                case 'show-interrupt':
                    expandSection('warning-details-section');
                    break;
                case 'settings':
                    expandSection('settings-panel-section');
                    break;
                case 'indexing-paused':
                    // Don't expand any sections in paused state
                    break;
                default:
                    // Don't expand any sections for other states
                    break;
            }
        }

        // New Error Testing Functions
        function testSpeedError() {
            setErrorState('speed-error');
            updateMessageArea('speed-error');
            autoExpandSections('speed-error');
            Tracker.logRumiAction('SPEED_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSystemError() {
            setErrorState('system-error');
            updateMessageArea('system-error');
            autoExpandSections('system-error');
            Tracker.logRumiAction('SYSTEM_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testNetworkError() {
            setErrorState('network-error');
            updateMessageArea('network-error');
            autoExpandSections('network-error');
            Tracker.logRumiAction('NETWORK_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testBrowserError() {
            setErrorState('browser-error');
            updateMessageArea('browser-error');
            autoExpandSections('browser-error');
            Tracker.logRumiAction('BROWSER_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testSettings() {
            setErrorState('settings');
            updateMessageArea('settings');
            autoExpandSections('settings');
            Tracker.logRumiAction('SETTINGS_PANEL_ACTIVATED', { timestamp: Date.now() });
        }

        function testIndexingPaused() {
            setErrorState('indexing-paused');
            updateMessageArea('indexing-paused');
            autoExpandSections('indexing-paused');
            Tracker.logRumiAction('INDEXING_PAUSED_ACTIVATED', { timestamp: Date.now() });
        }

        function testLanguageError() {
            setErrorState('language-error');
            updateMessageArea('language-error');
            autoExpandSections('language-error');
            Tracker.logRumiAction('LANGUAGE_ERROR_ACTIVATED', { timestamp: Date.now() });
        }

        function testShowInterrupt() {
            console.log('testShowInterrupt called');
            setErrorState('show-interrupt');
            updateMessageArea('show-interrupt');
            autoExpandSections('show-interrupt');
            
            // Ensure content info is populated after a longer delay to allow DOM to fully update
            setTimeout(() => {
                console.log('Attempting to populate content after delay');
                populateInterruptContentInfo();
                
                // Additional debugging to check visibility
                setTimeout(() => {
                    const contentElement = document.getElementById('interrupt-content-info');
                    const warningSection = document.getElementById('warning-details-section');
                    console.log('Content element after population:', contentElement);
                    console.log('Warning section:', warningSection);
                    console.log('Warning section display:', warningSection?.style.display);
                    console.log('Content element innerHTML:', contentElement?.innerHTML);
                    console.log('Content element computed style:', window.getComputedStyle(contentElement));
                }, 100);
            }, 200);
            
            Tracker.logRumiAction('SHOW_INTERRUPT_ACTIVATED', { timestamp: Date.now() });
        }

        function endSession() {
            // Clear any error states
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'fatal_error';
            
            // Log the session end action
            Tracker.logRumiAction('SESSION_ENDED_FATAL_ERROR', { 
                timestamp: Date.now(),
                reason: 'fatal_error'
            });
            
            // Navigate to receipt view
            showReceiptView();
            
            console.log('Session ended due to fatal error - navigating to receipt view');
        }

        // Pause indexing (called when errors occur)
        function pauseIndexing() {
            if (appState.isPaused) return; // Already paused
            
            appState.isPaused = true;
            appState.pauseStartTime = Date.now();
            
            // Add paused class to nokia-content (but not if paused for watch with us prompt)
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent && !appState.pausedForWatchWithUs) {
                nokiaContent.classList.add('paused');
            }
            
            // Pause all intervals and animations
            if (pointAccrualInterval) {
                clearInterval(pointAccrualInterval);
                pointAccrualInterval = null;
            }
            if (indexingTimerInterval) {
                clearInterval(indexingTimerInterval);
                indexingTimerInterval = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Pause the unified time sync system
            if (UnifiedTimeSync && UnifiedTimeSync.stop) {
                UnifiedTimeSync.stop();
            }
            
            Tracker.logRumiAction('INDEXING_PAUSED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings,
                pausedForWatchWithUs: appState.pausedForWatchWithUs
            });
            
            console.log('Indexing paused', appState.pausedForWatchWithUs ? '(for watch with us prompt)' : '');
        }

        // Resume indexing (called when errors are resolved)
        function resumeIndexing() {
            if (!appState.isPaused) return; // Not paused
            
            // Calculate pause duration
            if (appState.pauseStartTime) {
                const pauseTime = Date.now() - appState.pauseStartTime;
                appState.pauseDuration += pauseTime;
                appState.pauseStartTime = null;
            }
            
            appState.isPaused = false;
            
            // Remove paused class from nokia-content
            const nokiaContent = document.getElementById('nokia-content');
            if (nokiaContent) {
                nokiaContent.classList.remove('paused');
            }
            
            // Resume intervals and animations
            startPointsEarning();
            
            // Restart the unified time sync system
            if (UnifiedTimeSync && UnifiedTimeSync.initialize) {
                UnifiedTimeSync.initialize();
            }
            
            Tracker.logRumiAction('INDEXING_RESUMED', { 
                timestamp: Date.now(),
                sessionEarnings: appState.sessionEarnings,
                totalPauseDuration: appState.pauseDuration,
                wasWatchWithUsPrompt: appState.pausedForWatchWithUs
            });
            
            console.log('Indexing resumed', appState.pausedForWatchWithUs ? '(after watch with us prompt)' : '');
        }

        // Enhanced message area update function
        function updateMessageArea(state) {
            const messageArea = document.querySelector('.message-area');
            const messageText = document.getElementById('message-summary-text');
            const errorDetails = document.getElementById('error-details');
            const errorDetailsContent = document.getElementById('error-details-content');
            const warningDetailsContent = document.getElementById('warning-details-content');
            const settingsPanelContent = document.getElementById('settings-panel-content');

            // Remove all error classes
            messageArea.classList.remove('error', 'warning', 'info');
            messageArea.classList.remove('collapsed', 'expanded');

            switch(state) {
                case 'user-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ VOLUME CHANGED - PLEASE RETURN VOLUME TO 100% TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - VOLUME DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Volume level has been detected below 100%. Rumi requires maximum volume for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Use your system volume controls<br>
                                2. Or use the volume slider below<br>
                                3. Ensure volume is at 100%<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Volume monitoring ensures optimal audio capture for content analysis.
                        </div>
                    `;
                    break;

                case 'speed-error':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ SPEED CHANGED - SET VIDEO SPEED TO 1X TO CONTINUE INDEXING <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - SPEED DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Video playback speed has been detected above 1x. Rumi requires normal speed for accurate content indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Set video speed to 1x (normal)<br>
                                2. Use player speed controls<br>
                                3. Ensure speed is not accelerated<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Speed monitoring ensures accurate content timing and analysis.
                        </div>
                    `;
                    break;

                case 'system-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '❌ INDEXING FAILED - CONNECTION TO RUMI SERVERS LOST <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: SYS-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Connection to Rumi indexing servers has been lost. This may be due to network issues or server maintenance.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your internet connection<br>
                                2. Try refreshing the page<br>
                                3. Contact support if issue persists
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your progress has been saved. You can resume indexing once connection is restored.
                        </div>
                    `;
                    break;

                case 'network-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🌐 NETWORK ERROR - INTERNET CONNECTION REQUIRED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: NET-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Network connectivity has been lost. Rumi requires an active internet connection to function properly.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">TROUBLESHOOTING</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Check your Wi-Fi or ethernet connection<br>
                                2. Try disconnecting and reconnecting<br>
                                3. Restart your router if necessary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Your session data is saved locally and will sync when connection is restored.
                        </div>
                    `;
                    break;

                case 'browser-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🔧 BROWSER ERROR - COMPATIBILITY ISSUE DETECTED <button class="inline-end-session-button" onclick="endSession()">END SESSION</button>';
                    errorDetails.innerHTML = '';
                    errorDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">ERROR CODE: BRW-001</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Your browser is not compatible with Rumi's indexing technology. Please use a supported browser.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ff4444; font-weight: 600; margin-bottom: 4px;">SUPPORTED BROWSERS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                • Google Chrome (version 90+)<br>
                                • Mozilla Firefox (version 88+)<br>
                                • Microsoft Edge (version 90+)<br>
                                • Safari (version 14+)
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Please update your browser or switch to a supported browser to continue indexing.
                        </div>
                    `;
                    break;

                case 'warning':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '⚠️ PLAYER MODIFIED - PLEASE USE THE CONTROLS BELOW INSTEAD OF PLAYER CONTROLS <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - PLAYER INTERACTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Direct interaction with the video player has been detected. Rumi requires controlled playback for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Avoid direct player interaction<br>
                                2. Use system controls if needed<br>
                                3. Let Rumi manage playback<br>
                                4. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            This ensures accurate content tracking and optimal indexing performance.
                        </div>
                    `;
                    break;

                case 'settings':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '⚙️ SETTINGS CONFIGURATION - INDEXING PAUSED DURING SETTINGS <button class="message-button" onclick="simResolveError()">CANCEL</button> <button class="message-button primary" onclick="saveSettings()">SAVE</button>';
                    errorDetails.innerHTML = '';
                    settingsPanelContent.innerHTML = `
                        <!-- Account Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">ACCOUNT</div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 10px;">
                                <span style="color: #888;">Username</span>
                                <span style="color: #fff;">CRYPTO_MAVEN</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 10px;">
                                <span style="color: #888;">Member Since</span>
                                <span style="color: #fff;">Dec 2023</span>
                            </div>
                            <button class="secondary-button" style="width: 100%; margin-top: 8px; background: #ff4444; color: #fff; border-color: #ff4444;">LOGOUT</button>
                        </div>

                        <!-- Preferences Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PREFERENCES</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Desktop Notifications</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-start Indexing</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Disabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Audio Settings Section -->
                        <div style="margin-bottom: 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">AUDIO SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Volume Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Auto-resume on Volume Fix</span>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" checked style="margin-right: 4px;">
                                    <span style="font-size: 9px; color: #ccc;">Enabled</span>
                                </label>
                            </div>
                        </div>

                        <!-- Playback Settings Section -->
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #00ff41; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">PLAYBACK SETTINGS</div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 10px; color: #ccc;">Speed Detection Sensitivity</span>
                                <select style="background: #222; color: #fff; border: 1px solid #444; padding: 2px 4px; font-size: 9px;">
                                    <option>High</option>
                                    <option selected>Medium</option>
                                    <option>Low</option>
                                </select>
                            </div>
                        </div>

                        <div style="font-size: 10px; color: #888; font-style: italic; text-align: center;">
                            Settings will be applied immediately. Indexing will resume when you save and close.
                        </div>
                    `;
                    break;

                case 'indexing-paused':
                    messageArea.classList.add('info', 'expanded');
                    messageText.innerHTML = '⏸️ INDEXING PAUSED - READY TO RESUME WHEN ERROR IS RESOLVED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    break;

                case 'language-error':
                    messageArea.classList.add('error', 'expanded');
                    messageText.innerHTML = '🌍 LANGUAGE ERROR - CONTENT LANGUAGE NOT SUPPORTED <button class="inline-resume-button" onclick="simResolveError()">RESUME</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">WARNING DETAILS - LANGUAGE DETECTION</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                Content language has been detected as Japanese. Rumi currently supports English content only for accurate indexing.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">SUPPORTED LANGUAGES</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                • English (Primary)<br>
                                • Spanish (Beta)<br>
                                • French (Beta)<br>
                                • German (Beta)
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #ffaa00; font-weight: 600; margin-bottom: 4px;">HOW TO FIX</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. Switch to English content<br>
                                2. Or select a supported language<br>
                                3. Click "RESUME" to continue
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Note: Language detection is automatic. Indexing will resume once supported content is detected.
                        </div>
                    `;
                    break;

                case 'show-interrupt':
                    messageArea.classList.add('warning', 'expanded');
                    messageText.innerHTML = '<span style="color: #0088ff;">🔄 SHOW INTERRUPT - DIFFERENT CONTENT DETECTED</span> <button class="inline-resume-button" onclick="confirmShowInterrupt()">CONTINUE INDEXING</button> <button class="inline-end-session-button" onclick="endSessionFromInterrupt()">GO TO RECEIPT</button>';
                    errorDetails.innerHTML = '';
                    warningDetailsContent.innerHTML = `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">CONTENT CHANGE DETECTED</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                A different show or movie has been detected. You can continue indexing this new content for additional points.
                            </div>
                        </div>
                        <div style="margin-bottom: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 12px;">
                            <div style="font-size: 11px; color: #ffff00; font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">NEW CONTENT DETECTED</div>
                            <div id="interrupt-content-info" style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                <!-- Content info will be populated by JavaScript -->
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #0088ff; font-weight: 600; margin-bottom: 4px;">YOUR OPTIONS</div>
                            <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                                1. <strong>Continue Indexing:</strong> Chain points for additional multiplier (+0.1)<br>
                                2. <strong>Go to Receipt:</strong> End session and view earnings summary
                            </div>
                        </div>
                        <div style="font-size: 10px; color: #888; font-style: italic;">
                            Continuing will add the new content to your session and increase your multiplier bonus.
                        </div>
                    `;
                    // Populate the content info with random show data
                    // populateInterruptContentInfo(); // Commented out - will be called with delay
                    break;

                default:
                    // Normal state - collapse all sections
                    messageText.textContent = 'System operational - Daily bonus in 2h 34m';
                    errorDetails.innerHTML = '';
                    collapseAllSections();
                    break;
            }
        }

        // Helper functions for error recovery
        function saveSettings() {
            clearErrorState();
            Tracker.logRumiAction('SETTINGS_SAVED', { timestamp: Date.now() });
        }

        // Universal error resolution function
        function simResolveError() {
            // Reset simulated volume level if this was a volume error
            if (appState.errorState === 'volume') {
                appState.volumeLevel = 100;
            }
            
            // Clear error state
            clearErrorState();
            
            // Resume indexing if it was paused
            if (appState.isPaused) {
                resumeIndexing();
            }
            
            Tracker.logRumiAction('ERROR_RESOLVED', { 
                timestamp: Date.now(),
                previousError: appState.errorState
            });
            
            console.log('Error resolved, indexing resumed');
        }

        // Helper function to populate interrupt content info with random show data
        function populateInterruptContentInfo() {
            console.log('populateInterruptContentInfo called');
            const contentInfoElement = document.getElementById('interrupt-content-info');
            console.log('Content info element found:', contentInfoElement);
            
            if (!contentInfoElement) {
                console.error('interrupt-content-info element not found');
                return;
            }

            // Get a random show that's different from the current one
            const currentShow = appState.detectedShow;
            console.log('Current show:', currentShow);
            const newShow = availableShows.find(s => s.title !== currentShow?.title) || availableShows[0];
            console.log('New show selected:', newShow);
            
            // Store the new show for later use
            appState.interruptNewShow = newShow;

            const contentHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #fff; font-weight: 600;">${newShow.title}</span>
                    <span style="color: #888;">${newShow.service}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Genre:</span>
                    <span style="color: #fff;">${newShow.genre}</span>
                </div>
                ${newShow.season !== 'N/A' ? `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Episode:</span>
                    <span style="color: #fff;">${newShow.season} ${newShow.episode}</span>
                </div>
                ` : `
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span style="color: #ccc;">Year:</span>
                    <span style="color: #fff;">${newShow.year || 'N/A'}</span>
                </div>
                `}
            `;
            
            console.log('Setting content HTML:', contentHTML);
            contentInfoElement.innerHTML = contentHTML;
            console.log('Content populated successfully');
        }

        // Function to handle confirming show interrupt and continuing indexing
        function confirmShowInterrupt() {
            const newShow = appState.interruptNewShow;
            if (!newShow) {
                console.error('No new show data available for interrupt');
                return;
            }

            // Store the original show for receipt display
            appState.originalShow = appState.detectedShow;
            
            // Record the timestamp when the interrupt occurred
            appState.showInterruptTimestamp = Date.now();

            // Update the detected show to the new one
            appState.detectedShow = newShow;
            detectedShow = newShow;

            // Add chain bonus to multiplier
            if (appState.currentMultiplier) {
                appState.currentMultiplier += 0.1;
            } else {
                appState.currentMultiplier = 1.1;
            }

            // Clear the interrupt state
            clearErrorState();

            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_CONFIRMED', { 
                timestamp: Date.now(),
                newShow: newShow.title,
                newMultiplier: appState.currentMultiplier,
                interruptTimestamp: appState.showInterruptTimestamp
            });

            // Resume indexing with the new show
            resumeIndexing();

            console.log(`Show interrupt confirmed. Continuing with ${newShow.title}. New multiplier: ${appState.currentMultiplier}`);
        }

        // NEW: Enhanced Multiplier Progression System
        function calculateEnhancedMultiplier(sessionData) {
            const baseMultiplier = 1.0;
            let enhancedMultiplier = baseMultiplier;
            let multiplierReasons = [];
            
            // Time-based progression (every 5 minutes)
            const sessionMinutes = sessionData.sessionTime / 60;
            const timeBonus = Math.floor(sessionMinutes / 5) * 0.1;
            if (timeBonus > 0) {
                enhancedMultiplier += timeBonus;
                multiplierReasons.push(`Time bonus: +${timeBonus.toFixed(1)}x (${Math.floor(sessionMinutes / 5)} × 5min)`);
            }
            
            // Show transition bonus (escalating for multiple transitions)
            if (sessionData.numberOfShows > 1) {
                const transitionCount = sessionData.numberOfShows - 1;
                // Escalating bonus: 0.15x for 1st, 0.20x for 2nd, 0.25x for 3rd+
                let transitionBonus = 0;
                for (let i = 1; i <= transitionCount; i++) {
                    if (i === 1) transitionBonus += 0.15;
                    else if (i === 2) transitionBonus += 0.20;
                    else transitionBonus += 0.25;
                }
                enhancedMultiplier += transitionBonus;
                multiplierReasons.push(`Transition bonus: +${transitionBonus.toFixed(1)}x (${transitionCount} transitions, escalating)`);
            }
            
            // Content variety bonus (different types of content)
            const contentTypes = new Set();
            if (window.transitionSystem && window.transitionSystem.state && window.transitionSystem.state.playedContent) {
                const playedContent = window.transitionSystem.state.playedContent;
                playedContent.forEach(content => {
                    if (content.type) contentTypes.add(content.type);
                    if (content.service) contentTypes.add(content.service);
                });
                
                if (contentTypes.size > 2) {
                    const varietyBonus = (contentTypes.size - 2) * 0.05;
                    enhancedMultiplier += varietyBonus;
                    multiplierReasons.push(`Variety bonus: +${varietyBonus.toFixed(1)}x (${contentTypes.size} types)`);
                }
            }
            
            // Quality session bonus (long sessions with multiple shows)
            if (sessionMinutes > 15 && sessionData.numberOfShows > 2) {
                const qualityBonus = 0.2;
                enhancedMultiplier += qualityBonus;
                multiplierReasons.push(`Quality session: +${qualityBonus.toFixed(1)}x`);
            }
            
            // Cap at 3.0x maximum
            enhancedMultiplier = Math.min(enhancedMultiplier, 3.0);
            
            return {
                multiplier: enhancedMultiplier,
                reasons: multiplierReasons,
                improvement: enhancedMultiplier - baseMultiplier
            };
        }

        // NEW: Apply enhanced multiplier during session
        function applyEnhancedMultiplier() {
            if (!window.transitionSystem) return;
            
            const sessionData = window.transitionSystem.getCurrentState();
            const enhanced = calculateEnhancedMultiplier(sessionData);
            
            // Only update if there's an improvement
            if (enhanced.improvement > 0.05) { // 0.05x threshold
                const oldMultiplier = appState.currentMultiplier;
                appState.currentMultiplier = enhanced.multiplier;
                
                console.log(`Enhanced multiplier applied: ${oldMultiplier.toFixed(1)}x → ${enhanced.multiplier.toFixed(1)}x`);
                enhanced.reasons.forEach(reason => console.log(`  ${reason}`));
                
                // Update transition system multiplier
                if (window.transitionSystem.updateMultiplier) {
                    window.transitionSystem.updateMultiplier(enhanced.multiplier);
                }
                
                // Update UI
                updateUI();
                
                // Log the enhancement
                Tracker.logRumiAction('Enhanced multiplier applied', {
                    oldMultiplier: oldMultiplier,
                    newMultiplier: enhanced.multiplier,
                    improvement: enhanced.improvement,
                    reasons: enhanced.reasons
                });
            }
        }

        // Function to handle ending session from interrupt
        function endSessionFromInterrupt() {
            // Clear the interrupt state
            clearErrorState();
            
            // Set session end reason
            appState.sessionEndReason = 'show_interrupt_declined';
            
            // Log the action
            Tracker.logRumiAction('SHOW_INTERRUPT_DECLINED', { 
                timestamp: Date.now(),
                reason: 'user_declined_new_content'
            });
            
            // Calculate session duration and earnings
            const sessionDuration = appState.isIndexing ? Date.now() - appState.indexingStartTime : 0;
            const finalMultiplier = appState.currentMultiplier || 1.0;
            
            // Navigate to receipt view
            showReceiptView(sessionDuration, appState.currentMode || 'detection', finalMultiplier);
            
            console.log('Session ended due to show interrupt decline - navigating to receipt view');
        }

        // Helper function to get related content based on genre - returns empty array
        function getRelatedContent(genre, remainingTime) {
            console.log('🔍 [DEBUG] Related content requested, returning empty array - all content should come from CSV');
            // Return empty array - all content should come from CSV
            return [];
        }

        // Helper function to get automode content based on bucket using CSV data
        function getAutomodeContent(bucket, sessionDuration, baseRate, multiplier) {
            console.log('🔍 [DEBUG] getAutomodeContent called with bucket:', bucket, 'sessionDuration:', sessionDuration, 'seconds');
            
            // Request content from the genre channel which has the CSV data
            return new Promise((resolve) => {
                const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
                if (!channelFrame || !channelFrame.contentWindow) {
                                    console.log('🔍 [DEBUG] Channel frame not available, using CSV content');
                generateRobustFallbackContent(bucket, sessionDuration, baseRate, multiplier)
                    .then(csvContent => resolve(csvContent));
                return;
                }
                
                // Set up message listener for CSV content response
                const messageHandler = (event) => {
                    if (event.data.type === 'csvContentResponse') {
                        window.removeEventListener('message', messageHandler);
                        
                        const csvContent = event.data.content || [];
                        console.log('🔍 [DEBUG] Received CSV content:', csvContent.length, 'items');
                        
                        // Generate content ensuring we have enough for the full session
                        const items = generateFullSessionContent(csvContent, bucket, sessionDuration, baseRate, multiplier);
                        
                        console.log('🔍 [DEBUG] Generated automode content:', items.length, 'items for', sessionDuration / 60, 'minutes');
                        resolve(items);
                    }
                };
                
                window.addEventListener('message', messageHandler);
                
                // Request CSV content from channel
                channelFrame.contentWindow.postMessage({
                    type: 'requestCSVContent',
                    bucket: bucket
                }, '*');
                
                // Timeout after 3 seconds with CSV content
                setTimeout(() => {
                    window.removeEventListener('message', messageHandler);
                    console.log('🔍 [DEBUG] CSV content request timed out, using direct CSV load');
                    generateRobustFallbackContent(bucket, sessionDuration, baseRate, multiplier)
                        .then(csvContent => resolve(csvContent));
                }, 3000);
            });
        }
        
        // Enhanced content generation that ensures full session coverage
        function generateFullSessionContent(csvContent, bucket, sessionDuration, baseRate, multiplier) {
            console.log('🔍 [DEBUG] generateFullSessionContent - Target duration:', sessionDuration / 60, 'minutes');
            
            // Filter content by intelligence bucket first
            let bucketContent = csvContent.filter(item => 
                item.intelligence_bucket === bucket && 
                item.automode_eligible === 'true'
            );
            
            console.log('🔍 [DEBUG] Bucket-specific content:', bucketContent.length, 'items');
            
            // If bucket has insufficient content, expand to include all automode-eligible content
            if (bucketContent.length === 0) {
                console.log('🔍 [DEBUG] No bucket-specific content found, using all automode-eligible content');
                bucketContent = csvContent.filter(item => item.automode_eligible === 'true');
            }
            
            // Ensure minimum content variety for 240-minute sessions
            const minContentItemsFor240Min = 24; // At least 24 different clips (average 10 minutes each)
            if (bucketContent.length < minContentItemsFor240Min) {
                console.log('🔍 [DEBUG] Insufficient content variety, expanding to include related content');
                
                // Add content from similar buckets or expand criteria
                const allAutoEligible = csvContent.filter(item => item.automode_eligible === 'true');
                const missingCount = minContentItemsFor240Min - bucketContent.length;
                
                // Prioritize similar genres or services to maintain coherence
                const similarContent = allAutoEligible.filter(item => 
                    !bucketContent.some(existing => existing.title === item.title) &&
                    (bucketContent.some(existing => existing.genre === item.genre) ||
                     bucketContent.some(existing => existing.service === item.service))
                ).slice(0, missingCount);
                
                bucketContent = [...bucketContent, ...similarContent];
                console.log('🔍 [DEBUG] Expanded content pool to', bucketContent.length, 'items for better variety');
            }
            
            // Calculate total duration of available content
            const totalAvailableDuration = bucketContent.reduce((total, item) => {
                return total + (parseInt(item.duration_seconds) || 45 * 60);
            }, 0);
            
            console.log('🔍 [DEBUG] Total available content duration:', totalAvailableDuration / 60, 'minutes');
            
            const items = [];
            let timeLeft = sessionDuration;
            let contentIndex = 0;
            let cycleCount = 0;
            
            // Generate content, cycling through available content multiple times if needed
            while (timeLeft > 0 && bucketContent.length > 0) {
                const item = bucketContent[contentIndex];
                
                // Use actual duration from CSV (duration_seconds)
                const itemDurationSeconds = parseInt(item.duration_seconds) || 45 * 60;
                const itemTime = Math.min(itemDurationSeconds, timeLeft);
                const itemPoints = Math.round((itemTime * baseRate * multiplier) * 100) / 100;
                
                // Create unique title for recycled content
                let displayTitle = item.title;
                if (cycleCount > 0) {
                    displayTitle = `${item.title} (Cycle ${cycleCount + 1})`;
                }
                
                items.push({
                    title: displayTitle,
                    originalTitle: item.title, // Keep original for reference
                    duration: `${Math.floor(itemTime / 60)}:${String(itemTime % 60).padStart(2, '0')}`,
                    duration_seconds: itemDurationSeconds,
                    points: itemPoints.toFixed(1),
                    type: item.type,
                    genre: item.genre,
                    service: item.service,
                    season: item.season,
                    episode: item.episode,
                    year: item.year,
                    cycleNumber: cycleCount,
                    intelligence_bucket: item.intelligence_bucket
                });
                
                timeLeft -= itemTime;
                contentIndex++;
                
                // If we've used all content in the bucket, start over with cycle increment
                if (contentIndex >= bucketContent.length) {
                    contentIndex = 0;
                    cycleCount++;
                    console.log('🔍 [DEBUG] Starting content cycle', cycleCount + 1, '- Time remaining:', timeLeft / 60, 'minutes');
                    
                    // Safety check to prevent infinite loops
                    if (cycleCount > 10) {
                        console.warn('🔍 [DEBUG] Maximum content cycles reached, padding with final content');
                        break;
                    }
                }
            }
            
            // If we still have time left, pad with the last item
            if (timeLeft > 0 && items.length > 0) {
                const lastItem = items[items.length - 1];
                const paddingTime = Math.min(timeLeft, 45 * 60); // Max 45 minutes padding
                const paddingPoints = Math.round((paddingTime * baseRate * multiplier) * 100) / 100;
                
                items.push({
                    title: `${lastItem.originalTitle || lastItem.title} (Extended)`,
                    originalTitle: lastItem.originalTitle || lastItem.title,
                    duration: `${Math.floor(paddingTime / 60)}:${String(paddingTime % 60).padStart(2, '0')}`,
                    duration_seconds: paddingTime,
                    points: paddingPoints.toFixed(1),
                    type: lastItem.type,
                    genre: lastItem.genre,
                    service: lastItem.service,
                    season: lastItem.season,
                    episode: lastItem.episode,
                    year: lastItem.year,
                    cycleNumber: cycleCount,
                    intelligence_bucket: lastItem.intelligence_bucket,
                    isPadding: true
                });
            }
            
            const totalGeneratedDuration = items.reduce((total, item) => total + item.duration_seconds, 0);
            console.log('🔍 [DEBUG] Generated content summary:');
            console.log('🔍 [DEBUG] - Items:', items.length);
            console.log('🔍 [DEBUG] - Total duration:', totalGeneratedDuration / 60, 'minutes');
            console.log('🔍 [DEBUG] - Target duration:', sessionDuration / 60, 'minutes');
            console.log('🔍 [DEBUG] - Coverage:', (totalGeneratedDuration / sessionDuration * 100).toFixed(1), '%');
            
            return items;
        }

        // CSV-based content generator - loads content from CSV files only
        function generateRobustFallbackContent(bucket, sessionDuration, baseRate, multiplier) {
            console.log('🔍 [DEBUG] generateRobustFallbackContent - Loading CSV content for', sessionDuration / 60, 'minutes');
            
            // Return a Promise that resolves with CSV-based content
            return new Promise((resolve) => {
                fetch('content-library-expanded_LUDICROUS_WORKING.csv')
                    .then(response => response.text())
                    .then(csvText => {
                        const csvContent = parseCSVContent(csvText);
                        
                        // Filter content for the specified bucket
                        let contentPool = csvContent.filter(item => 
                            item.intelligence_bucket === bucket && 
                            item.automode_eligible === 'true'
                        );
                        
                        // If no bucket-specific content, use all automode-eligible content
                        if (contentPool.length === 0) {
                            console.log('🔍 [DEBUG] No bucket-specific content found, using all automode-eligible content');
                            contentPool = csvContent.filter(item => item.automode_eligible === 'true');
                        }
                        
                        // If still no content, use all CSV content
                        if (contentPool.length === 0) {
                            console.log('🔍 [DEBUG] No automode-eligible content found, using all CSV content');
                            contentPool = csvContent;
                        }
                        
                        // With 165+ items in CSV, we should always have sufficient content
                        if (contentPool.length === 0) {
                            console.error('🔍 [ERROR] CSV file appears to be empty or corrupted');
                        }
                        
                        console.log('🔍 [DEBUG] Using', contentPool.length, 'CSV content items');
                        
                        const content = generateContentFromPool(contentPool, bucket, sessionDuration, baseRate, multiplier);
                        resolve(content);
                    })
                    .catch(error => {
                        console.error('🔍 [ERROR] Failed to load CSV content:', error);
                        // Return empty array - CSV should be sufficient now
                        console.error('🔍 [ERROR] CSV file is required and should contain sufficient content');
                        resolve([]);
                    });
            });
        }
        
        // Helper function to parse CSV content
        function parseCSVContent(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
            const content = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = parseCSVLine(lines[i]);
                const item = {};
                
                headers.forEach((header, index) => {
                    item[header] = values[index] || '';
                });
                
                // Convert duration to seconds
                if (item.duration_seconds) {
                    item.duration_seconds = parseInt(item.duration_seconds);
                } else if (item.duration_minutes) {
                    item.duration_seconds = parseInt(item.duration_minutes) * 60;
                } else {
                    item.duration_seconds = 180; // Default 3 minutes
                }
                
                content.push(item);
            }
            
            return content;
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());
            
            return values;
        }
        
        // Generate content from CSV content pool
        function generateContentFromPool(contentPool, bucket, sessionDuration, baseRate, multiplier) {
            const items = [];
            let timeLeft = sessionDuration;
            let contentIndex = 0;
            let cycleCount = 0;
            
            // Generate content, cycling through available CSV content multiple times if needed
            while (timeLeft > 0 && contentPool.length > 0) {
                const item = contentPool[contentIndex];
                
                const itemDurationSeconds = item.duration_seconds || 180; // Use CSV duration_seconds
                const itemTime = Math.min(itemDurationSeconds, timeLeft);
                const itemPoints = Math.round((itemTime * baseRate * multiplier) * 100) / 100;
                
                // Create unique title for recycled content
                let displayTitle = item.title;
                if (cycleCount > 0) {
                    displayTitle = `${item.title} (Cycle ${cycleCount + 1})`;
                }
                
                items.push({
                    title: displayTitle,
                    originalTitle: item.title,
                    duration: `${Math.floor(itemTime / 60)}:${String(itemTime % 60).padStart(2, '0')}`,
                    duration_seconds: itemDurationSeconds,
                    points: itemPoints.toFixed(1),
                    type: item.type,
                    genre: item.genre,
                    service: item.service,
                    season: item.season || '',
                    episode: item.episode || '',
                    year: item.year || '',
                    cycleNumber: cycleCount,
                    intelligence_bucket: item.intelligence_bucket || bucket,
                    isFallback: true
                });
                
                timeLeft -= itemTime;
                contentIndex++;
                
                // If we've used all content in the pool, start over with cycle increment
                if (contentIndex >= contentPool.length) {
                    contentIndex = 0;
                    cycleCount++;
                    console.log('🔍 [DEBUG] Starting CSV content cycle', cycleCount + 1, '- Time remaining:', timeLeft / 60, 'minutes');
                    
                    // Safety check to prevent infinite loops
                    if (cycleCount > 15) {
                        console.warn('🔍 [DEBUG] Maximum CSV content cycles reached');
                        break;
                    }
                }
            }
            
            const totalGeneratedDuration = items.reduce((total, item) => total + item.duration_seconds, 0);
            console.log('🔍 [DEBUG] Generated CSV content summary:');
            console.log('🔍 [DEBUG] - Items:', items.length);
            console.log('🔍 [DEBUG] - Total duration:', totalGeneratedDuration / 60, 'minutes');
            console.log('🔍 [DEBUG] - Target duration:', sessionDuration / 60, 'minutes');
            console.log('🔍 [DEBUG] - Coverage:', (totalGeneratedDuration / sessionDuration * 100).toFixed(1), '%');
            
            return items;
        }

        // Helper function to get automode content with points for preview/receipt systems
        function getAutomodeContentWithPoints(bucket, sessionDuration, baseRate, multiplier) {
            console.log('🔍 [DEBUG] getAutomodeContentWithPoints called with bucket:', bucket, 'sessionDuration:', sessionDuration, 'seconds');
            
            // Use the same CSV-based content generation system as the main automode function
            // This ensures consistency between preview and actual session content
            // Note: This returns a Promise, so callers must handle it appropriately
            return generateRobustFallbackContent(bucket, sessionDuration, baseRate, multiplier);
        }

                // NEW: Comprehensive Time Skip Function
        function debugSkipTime(minutes) {
            console.log(`=== DEBUG TIME SKIP: ${minutes} minutes ===`);
            
            // Check if indexing is active
            if (!appState.isIndexing) {
                console.log('Skip Time: Not available - indexing not active');
                return;
            }
            
            // Calculate time to skip in seconds
            const skipSeconds = minutes * 60;
            const oldElapsedTime = TimeSystem.getElapsedTime();
            
            // 1. Adjust the indexing start time to simulate elapsed time
            appState.indexingStartTime -= (skipSeconds * 1000);
            
            // 2. Get new elapsed time and check if session should end
            const newElapsedTime = TimeSystem.getElapsedTime();
            const sessionDurationSeconds = TimeSystem.getSessionDuration(); // Use calculated duration from content
            
            console.log(`Skip Time: Session duration from TimeSystem: ${sessionDurationSeconds / 60} min`);
            
            console.log(`Skip Time: Old elapsed: ${(oldElapsedTime / 60).toFixed(1)} min, New elapsed: ${(newElapsedTime / 60).toFixed(1)} min`);
            console.log(`Skip Time: Session duration: ${(sessionDurationSeconds / 60).toFixed(1)} min`);
            
            // 3. Check if we've exceeded session duration
            if (newElapsedTime >= sessionDurationSeconds) {
                console.log('Skip Time: Session duration exceeded - ending session');
                
                // Force session completion
                const finalPoints = TimeSystem.getSessionDuration() * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1);
                
                // Create end-of-session receipt
                const receipt = {
                    sessionId: `debug_skip_${Date.now()}`,
                    totalPoints: finalPoints,
                    totalTimeIndexed: Math.floor(TimeSystem.getSessionDuration() / 60), // Use calculated duration in minutes
                    numberOfShows: appState.playedContent?.length || 1,
                    playedContent: appState.playedContent || [],
                    mode: appState.entryPoint,
                    debugSkipped: true,
                    minutesSkipped: minutes
                };
                
                // Stop indexing and show receipt
                stopIndexing();
                showSessionReceipt(receipt);
                
                Tracker.logRumiAction('DEBUG_SKIP_SESSION_ENDED', { 
                    minutesSkipped: minutes,
                    finalPoints: finalPoints,
                    sessionDuration: Math.floor(TimeSystem.getSessionDuration() / 60) // Use calculated duration in minutes
                });
                
                return;
            }
            
            // 4. Update multiplier based on new elapsed time
            const oldMultiplier = appState.currentMultiplier;
            const newMultiplier = TimeSystem.getCurrentMultiplier();
            appState.currentMultiplier = newMultiplier;
            
            console.log(`Skip Time: Multiplier updated: ${oldMultiplier.toFixed(1)}x → ${newMultiplier.toFixed(1)}x`);
            
            // 5. Force block progression if we're in detection mode
            // 5. Update block progression for all modes
            const blocksToAdvance = calculateBlocksToAdvance(skipSeconds);
            
            if (blocksToAdvance > 0 && appState.totalBlocks > 0) {
                console.log('Skip Time: Advancing block progression');
                
                // Calculate new block index
                const newBlockIndex = Math.min(
                    appState.currentBlockIndex + blocksToAdvance,
                    appState.totalBlocks - 1
                );
                
                if (newBlockIndex > appState.currentBlockIndex) {
                    appState.currentBlockIndex = newBlockIndex;
                    console.log(`Skip Time: Advanced to block ${appState.currentBlockIndex + 1}/${appState.totalBlocks}`);
                    
                    // Update block progression display
                    updateBlockProgressionDisplay();
                    
                    // Synchronize content with new block position
                    synchronizeContentWithBlocks();
                    
                    // Update "watching" text
                    updateWatchingText();
                }
            }
            
            // 6. Update all time-dependent displays
            updatePointsDisplay();
            updateStopIndexingButton();
            
            // 7. Send comprehensive timing sync to genre channel
            sendTimingSync();
            
            // 8. Send multiplier sync to genre channel (this is the source of truth issue you mentioned)
            if (window.genreChannelFrame && window.genreChannelFrame.contentWindow) {
                window.genreChannelFrame.contentWindow.postMessage({
                    type: 'multiplierSync',
                    multiplier: appState.currentMultiplier,
                    elapsedTime: newElapsedTime,
                    sessionDuration: appState.sessionDuration,
                    source: 'main_app_debug_skip'
                }, '*');
                console.log(`Skip Time: Sent multiplier sync to genre channel: ${appState.currentMultiplier.toFixed(1)}x`);
            }
            
            // 9. Force update ASCII animation with new timing
            if (typeof updateASCIIAnimation === 'function') {
                updateASCIIAnimation();
            }
            
            console.log(`Skip Time: Successfully skipped ${minutes} minutes`);
            console.log(`Skip Time: New state - Elapsed: ${(newElapsedTime / 60).toFixed(1)} min, Multiplier: ${appState.currentMultiplier.toFixed(1)}x`);
            
            Tracker.logRumiAction('DEBUG_TIME_SKIPPED', { 
                timestamp: Date.now(),
                minutesSkipped: minutes,
                oldElapsedTime: oldElapsedTime,
                newElapsedTime: newElapsedTime,
                oldMultiplier: oldMultiplier,
                newMultiplier: appState.currentMultiplier,
                blocksAdvanced: appState.entryPoint === 'detection' ? Math.floor(skipSeconds / 30) : 0
            });
        }

        // NEW: Debug function to skip to tomorrow (move pending points to lifetime)
        function debugSkipToTomorrow() {
            // Check cooldown
            if (appState.debugTomorrowCooldown > 0) {
                console.log('Debug skip to tomorrow: Still in cooldown');
                return;
            }
            
            console.log('Debug skip to tomorrow: Executing...');
            
            // Get current pending points
            const pendingPoints = appState.pendingPoints || 0;
            
            if (pendingPoints <= 0) {
                console.log('Debug skip to tomorrow: No pending points to move');
                return;
            }
            
            // Move pending points to lifetime
            appState.lifetimePoints = (appState.lifetimePoints || 0) + pendingPoints;
            appState.pendingPoints = 0;
            
            // Update leaderboard position
            updateLeaderboardPosition();
            
            console.log(`Debug skip to tomorrow: Moved ${pendingPoints.toFixed(2)} points to lifetime`);
            Tracker.logRumiAction('DEBUG_SKIP_TO_TOMORROW', {
                pendingPointsMoved: pendingPoints,
                newLifetimePoints: appState.lifetimePoints,
                timestamp: Date.now()
            });
            
            // Update displays
            updatePointsDisplay();
            
            // Set cooldown (30 seconds)
            appState.debugTomorrowCooldown = 30;
            
            // Update button state
            const skipTomorrowBtn = document.getElementById('debug-skip-tomorrow-btn');
            if (skipTomorrowBtn) {
                skipTomorrowBtn.disabled = true;
                skipTomorrowBtn.classList.add('cooldown');
                skipTomorrowBtn.textContent = `Skip to Tomorrow (${appState.debugTomorrowCooldown}s)`;
                
                // Start cooldown timer
                const cooldownTimer = setInterval(() => {
                    appState.debugTomorrowCooldown--;
                    if (skipTomorrowBtn) {
                        if (appState.debugTomorrowCooldown > 0) {
                            skipTomorrowBtn.textContent = `Skip to Tomorrow (${appState.debugTomorrowCooldown}s)`;
                        } else {
                            skipTomorrowBtn.disabled = false;
                            skipTomorrowBtn.classList.remove('cooldown');
                            skipTomorrowBtn.textContent = 'Skip to Tomorrow';
                            clearInterval(cooldownTimer);
                        }
                    }
                }, 1000);
            }
        }

        // NEW: Update leaderboard position based on lifetime points
        function updateLeaderboardPosition() {
            const lifetimePoints = appState.lifetimePoints || 0;
            
            // Calculate position based on points (simplified algorithm)
            let position = 23; // Default position
            
            if (lifetimePoints >= 15000) position = 1;
            else if (lifetimePoints >= 12000) position = 2;
            else if (lifetimePoints >= 10000) position = 3;
            else if (lifetimePoints >= 8000) position = 5;
            else if (lifetimePoints >= 6000) position = 8;
            else if (lifetimePoints >= 5000) position = 12;
            else if (lifetimePoints >= 4000) position = 15;
            else if (lifetimePoints >= 3000) position = 18;
            else if (lifetimePoints >= 2000) position = 20;
            else if (lifetimePoints >= 1000) position = 22;
            
            // Update leaderboard display
            const leaderboardRank = document.querySelector('.user-rank');
            if (leaderboardRank) {
                leaderboardRank.textContent = `🔥 YOU: #${position}`;
            }
            
            console.log(`Leaderboard position updated: #${position} with ${lifetimePoints} points`);
        }

        // NEW: Auto mode fast mode - 500x speed playback
        function startAutoModeFastMode() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Starting 500x speed playback...');
            
            // Store original session duration for restoration
            appState.fastMode.originalSessionDuration = appState.sessionDuration;
            appState.fastMode.originalStartTime = appState.indexingStartTime;
            
            // Calculate accelerated session duration (500x faster)
            const originalDurationMs = appState.sessionDuration * 60 * 1000; // Convert to milliseconds
            const acceleratedDurationMs = originalDurationMs / appState.fastMode.speedMultiplier;
            
            console.log(`Auto Mode Fast Mode: Original session ${appState.sessionDuration} min, accelerated to ${(acceleratedDurationMs / 1000).toFixed(1)}s`);
            
            // Update session start time to simulate 500x speed
            const currentTime = Date.now();
            const elapsedTime = currentTime - appState.indexingStartTime;
            const acceleratedElapsedTime = elapsedTime * appState.fastMode.speedMultiplier;
            
            // Adjust start time so that elapsed time appears much longer
            appState.indexingStartTime = currentTime - acceleratedElapsedTime;
            
            // Set up completion timer
            const remainingTime = acceleratedDurationMs - (elapsedTime / appState.fastMode.speedMultiplier);
            
            if (remainingTime > 0) {
                console.log(`Auto Mode Fast Mode: Session will complete in ${(remainingTime / 1000).toFixed(1)}s`);
                
                appState.fastMode.completionTimer = setTimeout(() => {
                    if (appState.fastMode && appState.fastMode.active) {
                        completeAutoModeFastModeSession();
                    }
                }, remainingTime);
            } else {
                // Session should complete immediately
                console.log('Auto Mode Fast Mode: Session duration exceeded, completing immediately');
                setTimeout(() => completeAutoModeFastModeSession(), 100);
            }
        }

        // NEW: Stop auto mode fast mode
        function stopAutoModeFastMode() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Stopping 500x speed...');
            
            // Clear completion timer
            if (appState.fastMode.completionTimer) {
                clearTimeout(appState.fastMode.completionTimer);
                appState.fastMode.completionTimer = null;
            }
            
            // Restore original timing (calculate actual elapsed time at normal speed)
            if (appState.fastMode.originalStartTime) {
                const currentTime = Date.now();
                const acceleratedElapsedTime = currentTime - appState.indexingStartTime;
                const normalElapsedTime = acceleratedElapsedTime / appState.fastMode.speedMultiplier;
                
                // Set start time to reflect normal elapsed time
                appState.indexingStartTime = currentTime - normalElapsedTime;
                
                console.log(`Auto Mode Fast Mode: Restored to normal timing, actual elapsed: ${(normalElapsedTime / 1000 / 60).toFixed(1)} min`);
            }
        }

        // NEW: Complete auto mode fast mode session
        function completeAutoModeFastModeSession() {
            if (!appState.fastMode || appState.fastMode.mode !== 'automode') return;
            
            console.log('Auto Mode Fast Mode: Session completed - showing receipt...');
            
            // Deactivate fast mode
            appState.fastMode.active = false;
            
            // Calculate final session stats
            const sessionDurationMinutes = Math.floor(TimeSystem.getSessionDuration() / 60); // Use calculated duration from content
            const totalPoints = sessionDurationMinutes * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1);
            
            // Create receipt
            const receipt = {
                sessionId: `automode_fast_${Date.now()}`,
                totalPoints: totalPoints,
                totalTimeIndexed: sessionDurationMinutes,
                numberOfShows: 1, // Auto mode typically has one continuous session
                playedContent: appState.playedContent || [],
                mode: 'automode',
                fastMode: true,
                speedMultiplier: 500
            };
            
            // Stop indexing
            stopIndexing();
            
            // Show receipt
            showSessionReceipt(receipt);
            
            // Clean up fast mode state
            appState.fastMode = null;
            
            console.log('Auto Mode Fast Mode: Receipt displayed, session complete');
        }

        // NEW: Smart fast mode navigation system
        function startFastModeNavigation() {
            if (!appState.fastMode || !appState.fastMode.active) return;
            
            const currentShow = appState.detectedShow;
            if (!currentShow) return;
            
            const showDurationSeconds = (currentShow.duration || 22) * 60; // Convert minutes to seconds
            const normalSpeedBuffer = appState.fastMode.normalSpeedBuffer;
            
            console.log(`Fast Mode: Starting navigation for "${currentShow.title}" (${showDurationSeconds}s duration)`);
            
            // Immediately skip to 4 seconds before the end
            const skipToTime = showDurationSeconds - normalSpeedBuffer;
            
            // Update the content start time to simulate fast-forward
            const currentTime = Date.now();
            const elapsedTime = (currentTime - appState.indexingStartTime) / 1000;
            
            // Calculate how much time to "skip"
            const timeToSkip = skipToTime;
            
            // Update content item start time to simulate we've been watching for most of the duration
            appState.contentItemStartTime = elapsedTime - skipToTime;
            
            console.log(`Fast Mode: Skipping to ${skipToTime}s (${normalSpeedBuffer}s from end)`);
            console.log(`Fast Mode: Content will transition in ${normalSpeedBuffer} seconds`);
            
            // Set flag that we're in the final seconds
            appState.fastMode.isInFinalSeconds = true;
            
            // Update content display to show current state
            triggerContentDisplayUpdate('fast_mode_transition');
            
            // Schedule the transition to next content
                    setTimeout(() => {
                if (appState.fastMode && appState.fastMode.active) {
                    transitionToNextContentInFastMode();
                }
            }, normalSpeedBuffer * 1000);
        }

                // NEW: Handle transition to next content in fast mode
        function transitionToNextContentInFastMode() {
            if (!appState.fastMode || !appState.fastMode.active) return;
            
            console.log('Fast Mode: Transitioning to next content...');
            
            // Initialize fast mode content index if not set
            if (typeof appState.fastMode.currentContentIndex === 'undefined') {
                appState.fastMode.currentContentIndex = 0;
            }
            
            // Get next show from channel using fast mode index
            getNextShowFromChannelForFastMode().then(nextShow => {
                if (nextShow && appState.fastMode && appState.fastMode.active) {
                    console.log(`Fast Mode: Transitioning to "${nextShow.title}" (index ${appState.fastMode.currentContentIndex + 1})`);
                    
                    // Increment fast mode index BEFORE transition
                    appState.fastMode.currentContentIndex++;
                    
                    // Use transition system to switch shows
                    transitionToShowWithSystem(nextShow).then(() => {
                        appState.fastMode.isInFinalSeconds = false;
                        
                        // Update visual content display and all UI elements
                        triggerContentDisplayUpdate('fast_mode_transition');
                        updateUI();
                        updatePointsDisplay();
                        
                        // Start navigation for the new content after a brief delay
                        setTimeout(() => {
                            if (appState.fastMode && appState.fastMode.active) {
                                startFastModeNavigation();
                            }
                        }, 1000); // 1 second delay to let transition complete
                    });
                } else {
                    console.log('Fast Mode: No next content available - completing session');
                    
                    // Deactivate fast mode
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                    
                    // Complete the session and show receipt
                    if (window.transitionSystem) {
                        console.log('Fast Mode: Completing session with transition system...');
                        completeSessionWithTransitionSystem();
            } else {
                        console.log('Fast Mode: Completing session normally...');
                        // Fallback to regular session completion
                        stopIndexing();
                        
                        // Show receipt if we have session data
                        if (appState.sessionEarnings > 0) {
                            const receipt = {
                                sessionId: `session_${Date.now()}`,
                                totalPoints: appState.sessionEarnings,
                                totalTimeIndexed: Math.floor((Date.now() - appState.indexingStartTime) / 60000),
                                numberOfShows: (appState.transitionCount || 0) + 1,
                                playedContent: appState.playedContent || []
                            };
                            showSessionReceipt(receipt);
                        }
                    }
                    
                    console.log('Fast Mode: Session completed - showing final receipt');
                }
            }).catch(error => {
                console.error('Fast Mode: Error getting next content:', error);
                
                // On error, also complete the session
                console.log('Fast Mode: Error occurred - completing session');
                
                // Safely clear fast mode state
                if (appState.fastMode) {
                    appState.fastMode.active = false;
                    appState.fastMode = null;
                }
                
                if (window.transitionSystem) {
                    completeSessionWithTransitionSystem();
                } else {
                    stopIndexing();
                }
            });
        }



        // NEW: Function to update debug button states based on cooldowns and error states
        function updateDebugButtonStates() {
            // No specific button state management needed for time skip buttons
            // They work based on indexing state which is checked in the function itself
            console.log('Debug button states updated');
        }

        // NEW: Function to handle debug button cooldowns
        function startDebugCooldown(type) {
            const cooldownInterval = setInterval(() => {
                if (type === 'skip') {
                    appState.debugSkipCooldown--;
                    if (appState.debugSkipCooldown <= 0) {
                        clearInterval(cooldownInterval);
                    }
                } else if (type === 'tomorrow') {
                    appState.debugTomorrowCooldown--;
                    if (appState.debugTomorrowCooldown <= 0) {
                        clearInterval(cooldownInterval);
                    }
                }
                updateDebugButtonStates();
            }, 1000);
        }

        // NEW: Function to show user choice prompt
        function showUserChoicePrompt() {
            appState.showChoicePrompt = true;
            
            // Choose colors based on entry point
            const primaryColor = (appState.entryPoint === 'automode') ? '#ffff00' : '#00ff41';
            
            // Create and show the choice prompt overlay
            const promptHTML = `
                <div id="user-choice-prompt" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                ">
                    <div style="
                        background: #1a1a1a;
                        border: 2px solid ${primaryColor};
                        border-radius: 12px;
                        padding: 24px;
                        max-width: 400px;
                        text-align: center;
                    ">
                        <div style="
                            font-size: 16px;
                            color: ${primaryColor};
                            font-weight: 700;
                            margin-bottom: 16px;
                            text-transform: uppercase;
                            letter-spacing: 1px;
                        ">
                            Choose Your Next Content
                        </div>
                        <div style="
                            font-size: 12px;
                            color: #ccc;
                            margin-bottom: 20px;
                            line-height: 1.4;
                        ">
                            <strong>Continue with Rumi:</strong> Go to the Genre Channel where Rumi curates content based on your interests and session goals. You can let it play continuously or switch back to direct recommendations anytime.
                        </div>
                        <div style="
                            font-size: 12px;
                            color: #ccc;
                            margin-bottom: 20px;
                            line-height: 1.4;
                        ">
                            <strong>Let Streamer Choose:</strong> Give control back to the streamer to select the next piece of content.
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button onclick="chooseRumiControl()" style="
                                flex: 1;
                                background: ${primaryColor};
                                color: #000;
                                border: none;
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 12px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                            ">
                                Continue with Rumi
                            </button>
                            <button onclick="chooseStreamerControl()" style="
                                flex: 1;
                                background: #222;
                                color: ${primaryColor};
                                border: 2px solid ${primaryColor};
                                padding: 12px;
                                border-radius: 6px;
                                font-size: 12px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                            ">
                                Let Streamer Choose
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', promptHTML);
        }

        // NEW: Function to handle Rumi control choice
        function chooseRumiControl() {
            appState.userChoice = 'rumi';
            appState.showChoicePrompt = false;
            
            // MODAL FIX: Mark this as a user-initiated channel change
            appState.userInitiatedChannelChange = true;
            console.log('🎯 Modal button clicked - marking as user-initiated channel change');
            
            // Remove the prompt
            const prompt = document.getElementById('user-choice-prompt');
            if (prompt) {
                prompt.remove();
            }

            // Go directly to genre channel and auto-start next content
            showGenreChannel();
            Tracker.logRumiAction('USER_CHOICE_MADE', { choice: 'rumi', action: 'genre_channel' });
        }

        // NEW: Function to handle streamer control choice
        function chooseStreamerControl() {
            appState.userChoice = 'streamer';
            appState.showChoicePrompt = false;
            
            // MODAL FIX: Mark this as a user-initiated action
            appState.userInitiatedChannelChange = true;
            console.log('🎯 Modal button clicked - marking as user-initiated action');
            
            // Remove the prompt
            const prompt = document.getElementById('user-choice-prompt');
            if (prompt) {
                prompt.remove();
            }
            
            // Trigger a random piece of content to start (like the "show interrupt" debug button)
            simulateShowChange();
            
            Tracker.logRumiAction('USER_CHOICE_MADE', { choice: 'streamer', action: 'show_interrupt' });
        }

        // Add debounce mechanism for channel expansion updates
        let channelExpansionTimeout = null;
        let lastChannelExpansionState = false;

        // NEW: Function to show "Watch with Us" popup after first content block
        function showWatchWithUsPrompt() {
            if (appState.watchWithUsPromptShown) return; // Already shown
            
            appState.watchWithUsPromptShown = true;
            appState.pausedForWatchWithUs = true;
            
            // Pause indexing before second block
            pauseIndexing();
            
            // Choose colors based on entry point
            const primaryColor = (appState.entryPoint === 'automode') ? '#ffff00' : '#00ff41';
            
            // MODAL FIX: Add auto-dismiss timeout to prevent sessions from getting stuck
            const autoAcceptTimeout = setTimeout(() => {
                console.log('🔄 Auto-dismissing Watch with Us modal after 30 seconds');
                const prompt = document.getElementById('watch-with-us-prompt');
                if (prompt) {
                    // Auto-accept "Watch with Rumi" for automode, auto-decline for detection mode
                    if (appState.entryPoint === 'automode') {
                        chooseWatchWithRumi();
                    } else {
                        declineWatchWithRumi();
                    }
                }
            }, 30000); // 30 seconds timeout
            
            // Store timeout ID to clear it if user interacts
            appState.watchWithUsModalTimeout = autoAcceptTimeout;
            
            // Create and show the watch with us prompt as a self-contained modal
            const promptHTML = `
                <div id="watch-with-us-prompt" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(4px);
                ">
                    <div class="watch-with-us-modal" style="
                        background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
                        border: 3px solid ${primaryColor};
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 480px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        text-align: center;
                        box-shadow: 
                            0 20px 60px rgba(0, 0, 0, 0.8),
                            0 0 0 1px rgba(255, 255, 255, 0.1),
                            inset 0 1px 0 rgba(255, 255, 255, 0.1);
                        position: relative;
                    ">
                        <!-- Blue circle icon -->
                        <div style="
                            width: 64px;
                            height: 64px;
                            background: ${primaryColor};
                            border-radius: 50%;
                            margin: 0 auto 24px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 28px;
                            box-shadow: 0 8px 24px rgba(0, 102, 255, 0.4);
                            animation: modalPulse 2s ease-in-out infinite;
                        ">
                            🎬
                        </div>
                        
                        <!-- Header -->
                        <div style="
                            font-size: 20px;
                            color: ${primaryColor};
                            font-weight: 700;
                            margin-bottom: 16px;
                            text-transform: uppercase;
                            letter-spacing: 1.5px;
                            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                        ">
                            Watch with Us
                        </div>
                        
                        <!-- Subtitle -->
                        <div style="
                            font-size: 14px;
                            color: #888;
                            margin-bottom: 24px;
                            font-weight: 600;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                        ">
                            First Content Block Complete!
                        </div>
                        
                        <!-- Main message -->
                        <div style="
                            font-size: 14px;
                            color: #ccc;
                            margin-bottom: 24px;
                            line-height: 1.6;
                        ">
                            Great job completing your first content block! Ready to continue your session with Rumi's curated content recommendations?
                        </div>
                        
                        <!-- Benefits section -->
                        <div style="
                            background: rgba(0, 0, 0, 0.3);
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            padding: 16px;
                            margin-bottom: 24px;
                            text-align: left;
                        ">
                            <div style="
                                font-size: 12px;
                                color: ${primaryColor};
                                font-weight: 700;
                                margin-bottom: 8px;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                            ">
                                ✨ Watch with Rumi Benefits:
                            </div>
                            <ul style="
                                font-size: 11px;
                                color: #ccc;
                                line-height: 1.5;
                                margin: 0;
                                padding-left: 16px;
                            ">
                                <li>Intelligent content curation for maximum points</li>
                                <li>Seamless viewing experience with smart transitions</li>
                                <li>Optimized content matching your preferences</li>
                                <li>Enhanced session continuity and flow</li>
                            </ul>
                        </div>
                        
                        <!-- Action buttons -->
                        <div style="display: flex; gap: 16px; margin-top: 24px;">
                            <button onclick="chooseWatchWithRumi()" style="
                                flex: 1;
                                background: ${primaryColor};
                                color: #000;
                                border: none;
                                padding: 16px 20px;
                                border-radius: 8px;
                                font-size: 14px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                                transition: all 0.2s ease;
                                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 0, 0, 0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.3)';">
                                Watch with Rumi
                            </button>
                            <button onclick="declineWatchWithRumi()" style="
                                flex: 1;
                                background: transparent;
                                color: ${primaryColor};
                                border: 2px solid ${primaryColor};
                                padding: 16px 20px;
                                border-radius: 8px;
                                font-size: 14px;
                                font-weight: 700;
                                cursor: pointer;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                                transition: all 0.2s ease;
                                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                            " onmouseover="this.style.background='${primaryColor}'; this.style.color='#000'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 0, 0, 0.4)';" onmouseout="this.style.background='transparent'; this.style.color='${primaryColor}'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.3)';">
                                Continue Solo
                            </button>
                        </div>
                        
                        <!-- Close button (optional) -->
                        <button onclick="declineWatchWithRumi()" style="
                            position: absolute;
                            top: 12px;
                            right: 12px;
                            background: none;
                            border: none;
                            color: #666;
                            font-size: 18px;
                            cursor: pointer;
                            width: 32px;
                            height: 32px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='rgba(255, 255, 255, 0.1)'; this.style.color='#ccc';" onmouseout="this.style.background='none'; this.style.color='#666';">
                            ×
                        </button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', promptHTML);
            
            // Add animation keyframes if not already present
            if (!document.getElementById('modal-animations')) {
                const style = document.createElement('style');
                style.id = 'modal-animations';
                style.textContent = `
                    @keyframes modalPulse {
                        0%, 100% { transform: scale(1); box-shadow: 0 8px 24px rgba(0, 102, 255, 0.4); }
                        50% { transform: scale(1.05); box-shadow: 0 12px 32px rgba(0, 102, 255, 0.6); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            Tracker.logRumiAction('WATCH_WITH_US_PROMPT_SHOWN', { 
                timestamp: Date.now(),
                entryPoint: appState.entryPoint,
                currentBlockIndex: appState.currentBlockIndex
            });
        }

        // NEW: Function to handle "Watch with Rumi" choice
        function chooseWatchWithRumi() {
            appState.userChoice = 'rumi';
            appState.pausedForWatchWithUs = false;
            
            // MODAL FIX: Clear auto-dismiss timeout if user interacted
            if (appState.watchWithUsModalTimeout) {
                clearTimeout(appState.watchWithUsModalTimeout);
                appState.watchWithUsModalTimeout = null;
            }
            
            // Remove the prompt
            const prompt = document.getElementById('watch-with-us-prompt');
            if (prompt) {
                prompt.remove();
            }
            
            // Resume indexing and continue with Rumi curation
            resumeIndexing();
            
            // Show genre channel for continued curation
            appState.userInitiatedChannelChange = true;
            showGenreChannel();
            
            Tracker.logRumiAction('WATCH_WITH_US_ACCEPTED', { 
                timestamp: Date.now(),
                entryPoint: appState.entryPoint,
                currentBlockIndex: appState.currentBlockIndex
            });
        }

        // NEW: Function to handle decline "Watch with Rumi" choice
        function declineWatchWithRumi() {
            appState.userChoice = 'streamer';
            appState.pausedForWatchWithUs = false;
            
            // MODAL FIX: Clear auto-dismiss timeout if user interacted
            if (appState.watchWithUsModalTimeout) {
                clearTimeout(appState.watchWithUsModalTimeout);
                appState.watchWithUsModalTimeout = null;
            }
            
            // Remove the prompt
            const prompt = document.getElementById('watch-with-us-prompt');
            if (prompt) {
                prompt.remove();
            }
            
            // Resume indexing
            resumeIndexing();
            
            // Trigger content detected alert in menu bar
            triggerContentDetectedAlert();
            
            Tracker.logRumiAction('WATCH_WITH_US_DECLINED', { 
                timestamp: Date.now(),
                entryPoint: appState.entryPoint,
                currentBlockIndex: appState.currentBlockIndex
            });
        }

        // NEW: Function to trigger content detected alert in menu bar
        function triggerContentDetectedAlert() {
            const messageArea = document.querySelector('.message-area');
            const messageText = document.getElementById('message-summary-text');
            
            if (messageArea && messageText) {
                // Show content detected alert
                messageArea.classList.remove('collapsed');
                messageArea.classList.add('info', 'expanded');
                messageText.innerHTML = '🎯 CONTENT DETECTED - New content available for indexing <button class="inline-resume-button" onclick="dismissContentDetectedAlert()">DISMISS</button>';
                
                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    dismissContentDetectedAlert();
                }, 10000);
                
                Tracker.logRumiAction('CONTENT_DETECTED_ALERT_SHOWN', { 
                    timestamp: Date.now(),
                    entryPoint: appState.entryPoint
                });
            }
        }

        // NEW: Function to dismiss content detected alert
        function dismissContentDetectedAlert() {
            const messageArea = document.querySelector('.message-area');
            const messageText = document.getElementById('message-summary-text');
            
            if (messageArea && messageText) {
                messageArea.classList.remove('info', 'expanded');
                messageArea.classList.add('collapsed');
                messageText.textContent = 'System operational - Daily bonus in 2h 34m';
                
                Tracker.logRumiAction('CONTENT_DETECTED_ALERT_DISMISSED', { 
                    timestamp: Date.now()
                });
            }
        }

        // NEW: Function to show genre channel and auto-start next content
        function showGenreChannel() {
            console.log('Showing genre channel for Rumi recommendations');
            
            // Don't stop indexing - continue the session
            // Just switch to genre channel view while keeping the session active
            currentChannel = 'genre';
            
            // Use debounced channel expansion to prevent rapid toggling
            setChannelExpansionState(true);
            
            // Update UI to show genre channel
            updateUI();
            
            // Continue the current session but switch to genre channel content
            // The session should continue running with the genre channel's next content
            setTimeout(() => {
                // Send message to genre channel to continue with next content
                const channelFrame = document.getElementById('channel-frame');
                const channelFrameIndexing = document.getElementById('channel-frame-indexing');
                
                const message = {
                    type: 'continueWithNextContent',
                    payload: {
                        continueSession: true,
                        currentShow: detectedShow ? detectedShow.title : 'Unknown',
                        sessionActive: appState.isIndexing
                    }
                };
                
                if (channelFrame && channelFrame.contentWindow) {
                    channelFrame.contentWindow.postMessage(message, '*');
                }
                if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                    channelFrameIndexing.contentWindow.postMessage(message, '*');
                }
                
                console.log('Sent continue session message to genre channel');
                
                // Add a delayed UI update to ensure button text updates after content change
                setTimeout(() => {
                    console.log('Performing delayed UI update after genre channel activation');
                    updateUI();
                    updatePointsDisplay();
                }, 2000); // 2 second delay to allow content to update
                
            }, 1000);
            
            Tracker.logRumiAction('Genre channel activated', { 
                continueSession: true,
                previousShow: detectedShow ? detectedShow.title : 'Unknown',
                sessionActive: appState.isIndexing
            });
        }

        // NEW: Debounced channel expansion state setter
        function setChannelExpansionState(expanded) {
            // Debug logging
            console.log(`setChannelExpansionState called: expanded=${expanded}, isIndexing=${appState.isIndexing}, userInitiated=${appState.userInitiatedChannelChange}`);
            
            // Prevent automatic channel state changes during active indexing sessions
            // unless it's a user-initiated action
            if (appState.isIndexing && !appState.userInitiatedChannelChange) {
                console.log(`🚫 Preventing channel expansion change during active session (${expanded})`);
                return;
            }
            
            // Clear any pending timeout
            if (channelExpansionTimeout) {
                clearTimeout(channelExpansionTimeout);
            }
            
            // Only update if the state is actually changing
            if (appState.channelExpanded !== expanded) {
                console.log(`Setting channel expansion state: ${expanded} (was: ${appState.channelExpanded})`);
                
                // Set the state immediately
                appState.channelExpanded = expanded;
                lastChannelExpansionState = expanded;
                
                // Debounce the UI update to prevent rapid toggling
                channelExpansionTimeout = setTimeout(() => {
                    updateExpandableChannelUI();
                    channelExpansionTimeout = null;
                }, 100); // 100ms debounce
            } else {
                console.log(`Channel expansion state already set to: ${expanded}`);
            }
            
            // Reset the user-initiated flag after processing
            appState.userInitiatedChannelChange = false;
        }

        // NEW: Helper function to update current multiplier based on elapsed time and dynamic milestones
        function updateCurrentMultiplier(elapsedTime) {
            const sessionDuration = calculateSessionDuration();
            const milestones = calculateDynamicMultiplierMilestones(sessionDuration);
            
            // Find the current multiplier based on elapsed time
            let currentMultiplier = 1.0;
            const progress = elapsedTime / sessionDuration;
            
            for (let i = 0; i < milestones.length; i++) {
                if (progress >= milestones[i].time) {
                    currentMultiplier = milestones[i].multiplier;
                } else {
                    break;
                }
            }
            
            // Only update if the multiplier has changed significantly (avoid micro-updates)
            if (Math.abs(currentMultiplier - appState.currentMultiplier) >= 0.1) {
                const oldMultiplier = appState.currentMultiplier;
                appState.currentMultiplier = currentMultiplier;
                
                console.log(`🎯 Multiplier updated: ${oldMultiplier.toFixed(1)}x → ${currentMultiplier.toFixed(1)}x at ${(progress * 100).toFixed(1)}% progress`);
                
                // Update transition system if available
                if (window.transitionSystem && window.transitionSystem.updateMultiplier) {
                    window.transitionSystem.updateMultiplier(currentMultiplier);
                }
            }
        }

        // NEW: Helper function to format time in MM:SS format
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // NEW: Helper function to calculate points with proper multiplier application
        function calculatePointsWithMultipliers(elapsedTimeSeconds, baseRate, sessionDurationSeconds) {
            const sessionDurationMinutes = sessionDurationSeconds / 60;
            const milestones = calculateDynamicMultiplierMilestones(sessionDurationSeconds);
            
            let totalPoints = 0;
            let lastMilestoneTime = 0;
            let currentMultiplier = 1.0;
            
            // Calculate points for each time segment with appropriate multiplier
            for (let i = 0; i < milestones.length; i++) {
                const milestone = milestones[i];
                const milestoneTimeSeconds = milestone.time * sessionDurationSeconds;
                
                // Calculate time spent in this multiplier segment
                const segmentEndTime = Math.min(elapsedTimeSeconds, milestoneTimeSeconds);
                const segmentDuration = Math.max(0, segmentEndTime - lastMilestoneTime);
                
                if (segmentDuration > 0) {
                    const segmentPoints = segmentDuration * baseRate * currentMultiplier;
                    totalPoints += segmentPoints;
                    
                    console.log(`📊 Points Segment: ${formatTime(lastMilestoneTime)} - ${formatTime(segmentEndTime)} at ${currentMultiplier.toFixed(1)}x = ${segmentPoints.toFixed(2)} pts`);
                }
                
                // If we haven't reached this milestone yet, stop calculating
                if (elapsedTimeSeconds < milestoneTimeSeconds) {
                    break;
                }
                
                // Update for next segment
                lastMilestoneTime = milestoneTimeSeconds;
                currentMultiplier = milestone.multiplier;
            }
            
            // Handle remaining time at final multiplier if session goes beyond last milestone
            if (elapsedTimeSeconds > lastMilestoneTime) {
                const remainingTime = elapsedTimeSeconds - lastMilestoneTime;
                const remainingPoints = remainingTime * baseRate * currentMultiplier;
                totalPoints += remainingPoints;
                
                console.log(`📊 Final Segment: ${formatTime(lastMilestoneTime)} - ${formatTime(elapsedTimeSeconds)} at ${currentMultiplier.toFixed(1)}x = ${remainingPoints.toFixed(2)} pts`);
            }
            
            console.log(`📊 Total Points: ${totalPoints.toFixed(2)} (${elapsedTimeSeconds}s at base rate ${baseRate})`);
            return totalPoints;
        }

        // NEW: Helper function to calculate dynamic multiplier milestones based on session duration
        function calculateDynamicMultiplierMilestones(sessionDurationSeconds) {
            const sessionDurationMinutes = sessionDurationSeconds / 60;
            const milestones = [{ time: 0, multiplier: 1.0 }]; // Always start with 1.0x at 0 minutes
            
            // Time-based milestones at 90-minute increments
            const baseInterval = 90; // 90 minutes
            let currentTime = baseInterval;
            let currentMultiplier = 1.2;
            
            // For 240-minute sessions: 0min=1.0x, 90min=1.2x, 180min=1.4x, 240min=1.5x (MAX)
            while (currentTime <= Math.min(sessionDurationMinutes, 240)) {
                const multiplier = currentTime === 240 ? 1.5 : currentMultiplier; // Cap at 1.5x for 240min
                milestones.push({
                    time: currentTime / sessionDurationMinutes, // Convert to ratio for existing logic
                    multiplier: multiplier
                });
                
                currentTime += baseInterval;
                currentMultiplier += 0.1; // Smaller increments: 1.2, 1.3, 1.4, 1.5
            }
            
            // If session is longer than 240 minutes, add more frequent but smaller multipliers
            if (sessionDurationMinutes > 240) {
                // From 240 minutes onward, add multipliers every 60 minutes (not 30)
                const acceleratedInterval = 60; // 60 minutes
                currentTime = 240 + acceleratedInterval; // Start at 300 minutes
                
                // Very small increments after 240 minutes, capped at 1.5x
                let extendedMultiplier = 1.5;
                
                while (currentTime <= Math.min(sessionDurationMinutes, 350)) { // Cap at 350 minutes max
                    milestones.push({
                        time: currentTime / sessionDurationMinutes,
                        multiplier: 1.5 // Keep at 1.5x maximum for extended sessions
                    });
                    
                    currentTime += acceleratedInterval;
                }
                }
                
            console.log(`🎯 Time-Based Multiplier Milestones (Max 1.5x):`, {
                    sessionDurationMinutes: sessionDurationMinutes.toFixed(1),
                totalMilestones: milestones.length,
                milestones: milestones.map(m => ({
                    timeMinutes: Math.round(m.time * sessionDurationMinutes),
                    multiplier: m.multiplier.toFixed(1)
                }))
                });
                
                return milestones;
        }

        // NEW: Helper function to calculate session duration based on current state
        function calculateSessionDuration() {
            // Check if we have a valid cached value (30-second cache)
            if (appState.cachedSessionDuration && appState.cachedSessionDurationTimestamp) {
                const cacheAge = Date.now() - appState.cachedSessionDurationTimestamp;
                if (cacheAge < 30000) { // 30 seconds
                    return appState.cachedSessionDuration;
                }
            }
            
            let sessionDuration;
            
            // If we have a chained session duration (extended session), use that
            if (appState.chainedSessionDuration) {
                sessionDuration = appState.chainedSessionDuration;
            } else if (appState.entryPoint === 'automode' && appState.automodeContentItems.length > 0) {
                // For automode, calculate total session duration from content items
                sessionDuration = appState.automodeContentItems.reduce((total, item) => {
                    const durationParts = item.duration.split(':');
                    return total + (parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]));
                }, 0);
            } else if (detectedShow) {
                // For show detection, use detected show duration if available
                if (detectedShow.duration && !isNaN(detectedShow.duration)) {
                    sessionDuration = detectedShow.duration * 60; // Assume duration is in minutes
                } else {
                    // Use genre/type-based averages if duration is not available
                    let genre = (detectedShow.type || '').toLowerCase();
                    if (!genre && detectedShow.genre) genre = detectedShow.genre.toLowerCase();
                    
                    // Check for specific content types first
                    if (genre.includes('sitcom') || genre.includes('comedy')) {
                        sessionDuration = 22 * 60; // 22 min for sitcoms/comedy
                    } else if (genre.includes('sketch') || genre.includes('variety')) {
                        sessionDuration = 30 * 60; // 30 min for sketch/variety shows
                    } else if (genre.includes('reality')) {
                        sessionDuration = 60 * 60; // 60 min for reality shows
                    } else if (genre.includes('drama') || genre.includes('show') || genre.includes('series')) {
                        sessionDuration = 45 * 60; // 45 min for dramas/series
                    } else if (genre.includes('movie') || genre.includes('film')) {
                        sessionDuration = 135 * 60; // 135 min (2h 15m) for movies
                    } else if (genre.includes('documentary')) {
                        sessionDuration = 90 * 60; // 90 min for documentaries
                    } else if (genre.includes('miniseries') || genre.includes('limited')) {
                        sessionDuration = 60 * 60; // 60 min for miniseries episodes
                    } else {
                        sessionDuration = 45 * 60; // Fallback to 45 minutes
                    }
                }
            } else {
                sessionDuration = 30 * 60; // Fallback to 30 minutes
            }
            
            // Cache the calculated session duration
            appState.cachedSessionDuration = sessionDuration;
            appState.cachedSessionDurationTimestamp = Date.now();
            
            return sessionDuration;
        }

        // NEW: Helper function to format running time display
        function formatRunningTime(elapsedTime) {
            const sessionDuration = calculateSessionDuration();
            const elapsedMinutes = Math.floor(elapsedTime / 60);
            const elapsedSeconds = Math.floor(elapsedTime % 60);
            const totalMinutes = Math.floor(sessionDuration / 60);
            const totalSeconds = Math.floor(sessionDuration % 60);
            return `${elapsedMinutes}:${elapsedSeconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
        }

        // NEW: Function to handle general session completion
        function handleSessionComplete() {
            if (appState.sessionCompleted) return;
            appState.sessionCompleted = true;
            
            console.log('🎯 Session completed - triggered by synchronized timeline');
            
            // Set session end reason
            appState.sessionEndReason = 'timeline_complete';
            
            // Log the completion
            Tracker.logRumiAction('Session completed - timeline complete', { 
                entryPoint: appState.entryPoint,
                totalDuration: SynchronizedTimeline.totalContentDuration / 60,
                contentItems: SynchronizedTimeline.contentItems.length
            });
            
            // Route to appropriate completion handler
            if (appState.entryPoint === 'detection') {
                handleShowDetectionSessionComplete();
            } else {
                // For automode or other entry points, complete session directly
                setTimeout(() => {
                    stopIndexing();
                }, 2000);
            }
        }

        // NEW: Function to handle show detection session completion
        function handleShowDetectionSessionComplete() {
            // Only handle completion once
            if (appState.sessionCompleted) return;
            appState.sessionCompleted = true;
            
            console.log('Show detection session completed');
            
            // Always record actual indexed content before showing receipt
            recordActualIndexedContentBeforeReceipt();
            
            // Record the actual indexed content
            if (detectedShow) {
                const sessionDuration = calculateSessionDuration();
                const sessionDurationMinutes = Math.floor(sessionDuration / 60);
                const totalElapsedTime = Math.floor((Date.now() - appState.indexingStartTime) / 60000);
                const actualDuration = Math.min(sessionDurationMinutes, totalElapsedTime);
                
                // Check if there was a show transition (interrupt)
                if (appState.originalShow && appState.interruptNewShow) {
                    // Calculate time spent on each show using actual interrupt timestamp
                    let originalShowTime, chainedShowTime;
                    
                    if (appState.showInterruptTimestamp) {
                        // Use actual interrupt timestamp to calculate viewing times
                        const interruptTimeMinutes = Math.floor((appState.showInterruptTimestamp - appState.indexingStartTime) / 60000);
                        originalShowTime = Math.min(interruptTimeMinutes, actualDuration);
                        chainedShowTime = Math.max(0, actualDuration - originalShowTime);
                    } else {
                        // Fallback: assume the interrupt happened at 75% of the session duration
                        const interruptTime = Math.floor(actualDuration * 0.75);
                        originalShowTime = interruptTime;
                        chainedShowTime = actualDuration - interruptTime;
                    }
                    
                    // Record the original show
                    const originalShowItem = {
                        title: `${appState.originalShow.title} ${appState.originalShow.season !== 'N/A' ? `S${appState.originalShow.season} E${appState.originalShow.episode}` : '(Film)'}`,
                        duration: originalShowTime,
                        type: 'detected_show',
                        points: Math.round((originalShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(originalShowItem);
                    
                    // Record the chained show
                    const chainedShowItem = {
                        title: `${appState.interruptNewShow.title} ${appState.interruptNewShow.season !== 'N/A' ? `S${appState.interruptNewShow.season} E${appState.interruptNewShow.episode}` : '(Film)'} (Chained)`,
                        duration: chainedShowTime,
                        type: 'chained_show',
                        points: Math.round((chainedShowTime * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(chainedShowItem);
                    
                    // Mark both content items as played to prevent duplicates
                    markContentAsPlayed(originalShowItem);
                    markContentAsPlayed(chainedShowItem);
                    
                    console.log('Recorded show transition:', {
                        originalShow: originalShowItem,
                        chainedShow: chainedShowItem,
                        interruptTimestamp: appState.showInterruptTimestamp
                    });
                } else {
                    // No show transition - record only the current show
                    const indexedContentItem = {
                        title: `${detectedShow.title} ${detectedShow.season !== 'N/A' ? `S${detectedShow.season} E${detectedShow.episode}` : '(Film)'}`,
                        duration: actualDuration,
                        type: 'detected_show',
                        points: Math.round((actualDuration * 60 * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                    };
                    
                    appState.indexedContent.push(indexedContentItem);
                    
                    // Mark content as played to prevent duplicates
                    markContentAsPlayed(indexedContentItem);
                }
            }
            
            // Check if this was completed by user action (debug skip)
            const wasUserCompleted = appState.debugSkipCooldown > 0;
            
            if (wasUserCompleted && !appState.userChoice) {
                // Show user choice prompt for Rumi vs Streamer control (always show, not just when channel expanded)
                showUserChoicePrompt();
            } else {
                // End the session and show receipt
                setTimeout(() => {
                    stopIndexing();
                }, 2000); // Give user 2 seconds to see "Session complete"
            }
            
            Tracker.logRumiAction('Show detection session completed', { 
                wasUserCompleted: wasUserCompleted,
                detectedShow: detectedShow ? detectedShow.title : 'Unknown',
                originalShow: appState.originalShow ? appState.originalShow.title : null,
                chainedShow: appState.interruptNewShow ? appState.interruptNewShow.title : null,
                indexedContent: appState.indexedContent
            });
        }

        // NEW: Message handler for content tracking data requests
        window.addEventListener('message', function(event) {
            if (event.data.type === 'requestContentTrackingData') {
                console.log('Received content tracking data request from:', event.data.channelName);
                
                // Get the currently playing content ID
                let currentlyPlayingId = null;
                if (appState.indexedContent.length > 0) {
                    const currentContent = appState.indexedContent[appState.indexedContent.length - 1];
                    currentlyPlayingId = generateContentId(currentContent);
                }
                
                // Send content tracking data back to the channel
                event.source.postMessage({
                    type: 'contentTrackingData',
                    channelName: event.data.channelName,
                    excludeContentIds: currentlyPlayingId ? [currentlyPlayingId] : [],
                    playedContentIds: Array.from(appState.playedContent),
                    channelContentIds: Array.from(appState.channelContent.get(event.data.channelName) || [])
                }, '*');
            }
        });

        // NEW: Content tracking utility functions
        // NEW: Helper function to update current content item
        function updateCurrentContentItem(elapsedTime) {
            if (!appState.automodeContentItems.length) return;
            
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Check if we need to move to next item
            if (timeInCurrentItem >= appState.contentItemDuration) {
                moveToNextContentItem(elapsedTime);
            }
        }

        // NEW: Handle fast mode content indexing for auto mode
        function handleFastModeContentIndexing(elapsedTime) {
            if (!appState.automodeContentItems || appState.automodeContentItems.length === 0) return;
            
            // Calculate how many content items should have been completed by now
            let totalExpectedTime = 0;
            let expectedContentIndex = 0;
            
            for (let i = 0; i < appState.automodeContentItems.length; i++) {
                const item = appState.automodeContentItems[i];
                let itemDuration;
                
                // Parse duration
                if (typeof item.duration === 'string' && item.duration.includes(':')) {
                    const durationParts = item.duration.split(':');
                    itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                } else {
                    itemDuration = item.duration || (45 * 60); // Default 45 minutes
                }
                
                if (totalExpectedTime + itemDuration <= elapsedTime) {
                    totalExpectedTime += itemDuration;
                    expectedContentIndex = i;
                } else {
                    break;
                }
            }
            
            // If we're behind where we should be, catch up by indexing content
            if (expectedContentIndex > appState.currentContentIndex) {
                console.log(`Fast Mode: Catching up content indexing. Current: ${appState.currentContentIndex}, Expected: ${expectedContentIndex}`);
                
                // Index all the content items we "skipped through"
                for (let i = appState.currentContentIndex; i < expectedContentIndex; i++) {
                    const item = appState.automodeContentItems[i];
                    if (item) {
                        // Calculate item duration
                        let itemDuration;
                        if (typeof item.duration === 'string' && item.duration.includes(':')) {
                            const durationParts = item.duration.split(':');
                            itemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            itemDuration = item.duration || (45 * 60);
                        }
                        
                        // Add to indexed content
                        const indexedContentItem = {
                            title: item.title,
                            duration: Math.floor(itemDuration / 60), // Convert to minutes for display
                            type: 'automode_content',
                            points: Math.round((itemDuration * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                        };
                        
                        // Only add if not already in indexed content
                        const alreadyIndexed = appState.indexedContent.some(existing => 
                            existing.title === indexedContentItem.title && 
                            existing.type === indexedContentItem.type
                        );
                        
                        if (!alreadyIndexed) {
                            appState.indexedContent.push(indexedContentItem);
                            console.log(`Fast Mode: Indexed content item: ${item.title} (${itemDuration}s)`);
                        }
                    }
                }
                
                // Update current content index and timing
                appState.currentContentIndex = expectedContentIndex;
                
                // Calculate start time for current item
                let cumulativeTime = 0;
                for (let i = 0; i < appState.currentContentIndex; i++) {
                    const prevItem = appState.automodeContentItems[i];
                    if (prevItem) {
                        let prevDuration;
                        if (typeof prevItem.duration === 'string' && prevItem.duration.includes(':')) {
                            const durationParts = prevItem.duration.split(':');
                            prevDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            prevDuration = prevItem.duration || (45 * 60);
                        }
                        cumulativeTime += prevDuration;
                    }
                }
                
                appState.contentItemStartTime = cumulativeTime;
                
                // Set duration for current item
                if (appState.currentContentIndex < appState.automodeContentItems.length) {
                    const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                    if (currentItem) {
                        if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                            const durationParts = currentItem.duration.split(':');
                            appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                            appState.contentItemDuration = currentItem.duration || (45 * 60);
                        }
                    }
                }
                
                console.log(`Fast Mode: Updated to content index ${appState.currentContentIndex}, total indexed items: ${appState.indexedContent.length}`);
            }
        }

        // NEW: Helper function to move to next content item
        function moveToNextContentItem(elapsedTime) {
            // Always index the current content item before moving to next or completing session
            if (appState.currentContentIndex >= 0 && appState.currentContentIndex < appState.automodeContentItems.length) {
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    // Calculate duration for the current item
                        let itemDurationSeconds;
                    if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                        const durationParts = currentItem.duration.split(':');
                            itemDurationSeconds = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                        } else {
                        itemDurationSeconds = currentItem.duration || (45 * 60);
                        }
                        
                        // Add to indexed content if not already tracked
                        const indexedItem = {
                        title: currentItem.title,
                            duration: Math.floor(itemDurationSeconds / 60), // Convert to minutes for display
                            type: appState.entryPoint === 'automode' ? 'automode_content' : 'content',
                            points: Math.round((itemDurationSeconds * (appState.baseRate || 0.1) * (appState.currentMultiplier || 1.0)) * 100) / 100
                        };
                        
                        // Check if already indexed to avoid duplicates
                        const alreadyIndexed = appState.indexedContent.some(existing => 
                            existing.title === indexedItem.title && existing.type === indexedItem.type
                        );
                        
                        if (!alreadyIndexed) {
                            appState.indexedContent.push(indexedItem);
                            console.log(`📊 Indexed content item: ${indexedItem.title} (${indexedItem.duration}min, ${indexedItem.points} pts)`);
                        }
                    }
                }
                
            if (appState.automodeContentItems.length > 0 && appState.currentContentIndex < appState.automodeContentItems.length - 1) {
                // Check if this content was completed by user action (debug skip)
                const wasUserCompleted = appState.debugSkipCooldown > 0;
                
                // Move to next content item
                appState.currentContentIndex++;
                // Use the passed elapsed time to avoid timing mismatch
                appState.contentItemStartTime = elapsedTime;
                
                // Calculate duration for new content item
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    // Handle both duration strings (e.g., "0:45") and numeric durations
                    if (typeof currentItem.duration === 'string' && currentItem.duration.includes(':')) {
                        // Parse duration string (e.g., "0:45") to seconds
                        const durationParts = currentItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        // Use duration as-is (already in seconds)
                        appState.contentItemDuration = currentItem.duration;
                    }
                }
                
                // If content was completed by user action and channel is open, show choice prompt
                if (wasUserCompleted && appState.channelExpanded && !appState.userChoice) {
                    showUserChoicePrompt();
                }
                
                Tracker.logRumiAction('Content item transitioned', { 
                    newItem: currentItem.title,
                    index: appState.currentContentIndex,
                    wasUserCompleted: wasUserCompleted
                });
            } else {
                // Reached end of all content - trigger session completion
                console.log('End of channel content reached - completing session');
                console.log(`📊 Final indexed content count: ${appState.indexedContent.length} items`);
                
                if (!appState.sessionCompleted) {
                    appState.sessionCompleted = true;
                    
                    if (appState.entryPoint === 'detection' && detectedShow) {
                        // For show detection mode, use existing completion handler
                        handleShowDetectionSessionComplete();
                    } else {
                        // For automode or other entry points, complete session directly
                        console.log('Auto-completing session after reaching end of content');
                        
                        // Set session end reason
                        appState.sessionEndReason = 'content_complete';
                        
                        // Log the completion
                        Tracker.logRumiAction('Session completed - end of content', { 
                            entryPoint: appState.entryPoint,
                            totalContentItems: appState.automodeContentItems.length,
                            completedIndex: appState.currentContentIndex,
                            totalIndexedItems: appState.indexedContent.length
                        });
                        
                        // Give user 2 seconds to see "Session complete" message, then show receipt
                        setTimeout(() => {
                            stopIndexing();
                        }, 2000);
                    }
                }
            }
        }

        // NEW: Helper function to scroll text for current content item
        function scrollText(text, elapsedTime, visibleWidth) {
            if (!text) return '';
            
            // Only scroll if text is longer than visible width
            if (text.length <= visibleWidth) {
                return text;
            }
            
            // Calculate scroll position based on time within current content item
            const timeInCurrentItem = elapsedTime - appState.contentItemStartTime;
            
            // Start scrolling after transition on is complete (0.5 seconds)
            const scrollStartTime = 0.5;
            const scrollEndTime = appState.contentItemDuration - 3.0; // Stop scrolling 3 seconds before end
            
            if (timeInCurrentItem < scrollStartTime || timeInCurrentItem > scrollEndTime) {
                // Don't scroll during transitions, just show the beginning of the text
                return text.substring(0, visibleWidth);
            }
            
            // Calculate effective scroll time (subtract transition periods)
            const effectiveScrollTime = timeInCurrentItem - scrollStartTime;
            const scrollSpeed = 1.6; // characters per second (doubled from 0.8)
            const scrollOffset = Math.floor(effectiveScrollTime * scrollSpeed) % text.length;
            
            // Scroll from right to left
            const startPos = scrollOffset;
            const endPos = Math.min(startPos + visibleWidth, text.length);
            let scrolledText = text.substring(startPos, endPos);
            
            // If we're near the end, wrap around
            if (endPos === text.length && startPos + visibleWidth > text.length) {
                const remainingChars = visibleWidth - (text.length - startPos);
                scrolledText += ' • ' + text.substring(0, remainingChars);
            }
            
            return scrolledText;
        }
        // ============================================================================
// TRANSITION SYSTEM INTEGRATION
// ============================================================================

// Global transition system instance
let transitionSystem = null;

// Initialize transition system with UI callbacks
function initializeTransitionSystem() {
    if (typeof TransitionSystem === 'undefined') {
        console.warn('TransitionSystem not loaded - skipping initialization');
        return;
    }

    console.log('Initializing transition system...');
    
    window.transitionSystem = new TransitionSystem();
    transitionSystem = window.transitionSystem; // Keep local reference for compatibility
    
    // Set up UI callbacks
    transitionSystem.state.uiCallbacks = {
        onStateChange: (newState) => {
            console.log('Transition system state changed:', newState);
            // Sync with app state
            appState.isIndexing = newState.isIndexing;
            appState.isTransitioning = newState.isTransitioning;
            updateUI();
        },
        
        onShowChange: (newShow) => {
            console.log('Show changed:', newShow);
            
            // Update app state with new show
            if (appState.entryPoint === 'detection') {
                // Store the previous show as completed
                if (appState.detectedShow) {
                    markContentAsPlayedWithTransition(appState.detectedShow);
                }
                
                // Update to new show
                const previousShow = appState.detectedShow;
                appState.detectedShow = newShow;
                
                // Set originalShow only on first transition
                if (!appState.originalShow) {
                    appState.originalShow = previousShow;
                }
                
                // Always update the most recent transition
                appState.interruptNewShow = newShow;
                appState.showInterruptTimestamp = Date.now();
                
                // Track transition count
                appState.transitionCount = (appState.transitionCount || 0) + 1;
                
                console.log(`Transition #${appState.transitionCount} ${appState.originalShow ? 'chain' : 'initial'}: ${previousShow.title} → ${newShow.title}`);
                console.log('Total transitions in session:', appState.transitionCount);
                
                // Update global detectedShow variable for compatibility
                detectedShow = newShow;
                
                // Add new show to synchronized timeline
                const newShowItem = {
                    title: `${newShow.title} ${newShow.season !== 'N/A' ? `S${newShow.season} E${newShow.episode}` : '(Film)'}`,
                    duration: (newShow.duration || 45) * 60, // Convert to seconds
                    type: newShow.type || 'show',
                    service: newShow.service || 'UNKNOWN',
                    season: newShow.season || 'N/A',
                    episode: newShow.episode || 'N/A'
                };
                
                if (SynchronizedTimeline.isInitialized) {
                    SynchronizedTimeline.addContentItem(newShowItem);
                    console.log('🎯 SynchronizedTimeline: Added new show to timeline');
                } else {
                    // Initialize timeline with the new show if not already initialized
                    SynchronizedTimeline.initializeTimeline([newShowItem]);
                    console.log('🎯 SynchronizedTimeline: Initialized with new show');
                }
                
                // Reset content items to include the new show
                const sessionDuration = calculateSessionDuration();
                appState.automodeContentItems = getShowDetectionContent(newShow, sessionDuration);
                appState.currentContentIndex = 0;
                appState.contentItemStartTime = (Date.now() - appState.indexingStartTime) / 1000; // Current elapsed time
                
                // Calculate duration for new content item
                if (appState.automodeContentItems.length > 0) {
                    const newItem = appState.automodeContentItems[0];
                    if (typeof newItem.duration === 'string' && newItem.duration.includes(':')) {
                        const durationParts = newItem.duration.split(':');
                        appState.contentItemDuration = parseInt(durationParts[0]) * 60 + parseInt(durationParts[1]);
                    } else {
                        appState.contentItemDuration = newItem.duration || 45 * 60;
                    }
                }
                
                // Extend session duration to accommodate the new show (legacy support)
                const currentElapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                const remainingTimeForNewShow = (newShow.duration || 45) * 60; // Convert to seconds
                
                // If this is the first extension, start from current elapsed time
                // If this is a subsequent extension, add to the existing chained duration
                const baseSessionDuration = appState.chainedSessionDuration || currentElapsedTime;
                const extendedSessionDuration = baseSessionDuration + remainingTimeForNewShow;
                
                // Update chained session duration
                appState.chainedSessionDuration = extendedSessionDuration;
                
                // Clear session duration cache to force recalculation (not needed with synchronized timeline)
                appState.cachedSessionDuration = null;
                appState.cachedSessionDurationTimestamp = null;
                
                console.log(`Show transition: ${appState.originalShow.title} → ${newShow.title}`);
                console.log('Extended session duration:', extendedSessionDuration / 60, 'minutes');
                console.log('New content item duration:', appState.contentItemDuration);
                console.log('Content item start time:', appState.contentItemStartTime);
            }
            
            // Update all UI elements
            updateUI();
            updatePointsDisplay();
            
            // Force update the animation panel immediately
            if (appState.indexingStartTime) {
                const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
                updateAnimationPanel(elapsedTime);
            }
            
            // Update content display to show locked previous content
            triggerContentDisplayUpdate('show_transition');
            
            // Update button text with current show title
            updateButtonWithCurrentShow(newShow);
        },
        
        onMultiplierChange: (newMultiplier) => {
            console.log('Multiplier changed:', newMultiplier);
            appState.currentMultiplier = newMultiplier;
            updatePointsDisplay();
        },
        
        onProgressUpdate: (progress) => {
            console.log('Progress updated:', progress);
            // Update session earnings based on progress
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                const timeIndexedMinutes = progress.timeIndexed;
                const points = timeIndexedMinutes * (appState.baseRate || 0.1) * progress.multiplier;
                appState.sessionEarnings = points;
                updatePointsDisplay();
            }
        },
        
        onSessionComplete: (receipt) => {
            console.log('Session completed:', receipt);
            appState.sessionCompleted = true;
            // Store receipt for display
            appState.sessionReceipt = receipt;
            showSessionReceipt(receipt);
        }
    };
    
    console.log('Transition system initialized successfully');
}

// Integrate transition system with existing content tracking
function integrateTransitionSystemWithContentTracking() {
    if (!transitionSystem) return;
    
    // Sync played content with transition system
    appState.playedContent.forEach(contentId => {
        transitionSystem.markContentAsCompleted(contentId);
    });
    
    // Sync channel content
    appState.channelContent.forEach((contentSet, channelName) => {
        contentSet.forEach(contentId => {
            // Mark as in channel but not completed
            if (!transitionSystem.isContentCompleted(contentId)) {
                // This content is available in the channel
                console.log(`Content ${contentId} available in channel ${channelName}`);
            }
        });
    });
    
    console.log('Transition system integrated with content tracking');
}

// Enhanced content tracking functions that work with transition system
function markContentAsPlayedWithTransition(content) {
    const contentId = generateContentId(content);
    
    // Use existing function
    markContentAsPlayed(content);
    
    // Also mark in transition system
    if (transitionSystem) {
        transitionSystem.markContentAsCompleted(contentId);
    }
}

// Enhanced show transition function
async function transitionToShowWithSystem(newShow) {
    if (!transitionSystem || !appState.detectedShow) {
        console.warn('Transition system or current show not available');
        return;
    }
    
    try {
        // Use transition system for smooth transition
        await transitionSystem.transitionToShow(newShow);
        
        // Update app state
        appState.interruptNewShow = newShow;
        appState.showInterruptTimestamp = Date.now();
        
        console.log('Show transition completed via transition system');
        
    } catch (error) {
        console.error('Error during show transition:', error);
        // Fallback to direct state update
        appState.interruptNewShow = newShow;
        appState.showInterruptTimestamp = Date.now();
    }
}

// Enhanced session management
function startIndexingWithTransitionSystem() {
    // Use existing startIndexing logic
    startIndexing();
    
    // Initialize transition system if not already done
    if (!transitionSystem) {
        initializeTransitionSystem();
    }
    
    // Initialize transition system with current show
    if (appState.entryPoint === 'detection' && appState.detectedShow) {
        const showData = {
            id: generateContentId(appState.detectedShow),
            title: appState.detectedShow.title,
            duration: appState.detectedShow.duration || 45,
            type: 'show'
        };
        
        // Update button text with initial show
        updateButtonWithCurrentShow(appState.detectedShow);
        
        // Update content display
        triggerContentDisplayUpdate('session_start');
        
        transitionSystem.initialize(showData, {
            baseRate: appState.baseRate || 0.1,
            multiplierThresholds: [
                { time: 60, multiplier: 1.2 },
                { time: 120, multiplier: 1.5 },
                { time: 180, multiplier: 2.0 }
            ]
        });
        
        console.log('Transition system initialized with detected show:', showData);
    }
}

// Enhanced session completion
function completeSessionWithTransitionSystem() {
    if (!transitionSystem) {
        console.warn('Transition system not available for session completion');
        return;
    }
    
    // Complete current show in transition system
    transitionSystem.completeCurrentShow();
    
    // Get session receipt
    const receipt = transitionSystem.getSessionReceipt();
    
    // Update app state
    appState.sessionCompleted = true;
    appState.sessionReceipt = receipt;
    
    // Show receipt
    showSessionReceipt(receipt);
    
    console.log('Session completed via transition system');
}

// Function to show session receipt (placeholder - implement UI as needed)
function showSessionReceipt(receipt) {
    console.log('=== SESSION RECEIPT ===');
    console.log('Session ID:', receipt.sessionId);
    console.log('Total Time:', receipt.totalTime);
    console.log('Final Multiplier:', receipt.finalMultiplier);
    console.log('Total Points:', receipt.totalPoints);
    console.log('Content Played:');
    
    // Handle both receipt.content and receipt.playedContent
    const contentArray = receipt.content || receipt.playedContent || [];
    if (Array.isArray(contentArray) && contentArray.length > 0) {
        contentArray.forEach(item => {
            console.log(`  - ${item.title}: ${item.timeIndexed}min, ${item.points} points (${item.multiplier}x)`);
        });
    } else {
        console.log('  No content played in this session');
    }
    console.log('=====================');
    
    // TODO: Implement UI display for receipt
    // This could be a modal, overlay, or dedicated receipt view
}

// Debug function for transition system
function debugTransitionSystem() {
    if (!transitionSystem) {
        console.log('Transition system not initialized');
        return;
    }
    
    console.log('=== TRANSITION SYSTEM DEBUG ===');
    const state = transitionSystem.getCurrentState();
    console.log('Current State:', state);
    console.log('Log:', transitionSystem.getLog());
    console.log('=== END TRANSITION SYSTEM DEBUG ===');
}

        // NEW: Update content display in the channel iframe
        function updateContentDisplay() {
            console.log('updateContentDisplay: Sending update message to channel iframe');
            
            // Send message to channel iframe to update content blocks
            const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('updateContentDisplay: Channel iframe not found or not loaded');
                return;
            }
            
            console.log('=== UPDATING CONTENT DISPLAY ===');
            console.log('Trigger: updateContentDisplay called');
            
            // Get transition system data if available
            let playedContent = [];
            if (window.transitionSystem && window.transitionSystem.state && window.transitionSystem.state.playedContent) {
                playedContent = window.transitionSystem.state.playedContent;
                console.log('Played content from transition system:', playedContent.length, 'items');
            } else {
                console.log('No transition system or playedContent available');
            }
            
            // Prepare content data to send to channel
            const contentData = {
                playedContent: playedContent,
                currentShow: appState.detectedShow,
                elapsedTime: appState.indexingStartTime ? 
                    Math.floor((Date.now() - appState.indexingStartTime) / 60000) : 0,
                // NEW: Add fast mode context to preserve content visibility
                fastModeActive: appState.fastMode && appState.fastMode.active,
                preserveAllContent: true, // Always preserve all content blocks
                // NEW: Add session start context to prevent clearing content
                isSessionStart: appState.indexingStartTime && (Date.now() - appState.indexingStartTime) < 5000, // First 5 seconds of session
                // NEW: Add transition context to preserve existing content during transitions
                isTransition: appState.isTransitioning || false,
                // NEW: Indicate this is a state update, not a content replacement
                updateType: 'status_update' // vs 'content_replacement'
            };
            
            // Send message to channel iframe to update content blocks
            try {
                channelFrame.contentWindow.postMessage({
                    type: 'updateContentBlocks',
                    data: contentData
                }, '*');
                console.log('Sent content update message to channel:', contentData);
                console.log('=== END CONTENT DISPLAY UPDATE ===');
            } catch (error) {
                console.error('Error sending message to channel iframe:', error);
            }
        }

        // Request current content from genre channel to update session duration
        function requestContentFromGenreChannel() {
            console.log('🔍 [DEBUG] Requesting current content from genre channel');
            
            // Send message to both channel frames
            const channelFrame = document.getElementById('channel-frame');
            const channelFrameIndexing = document.getElementById('channel-frame-indexing');
            
            const message = {
                type: 'requestCurrentContent',
                timestamp: Date.now()
            };
            
            if (channelFrame && channelFrame.contentWindow) {
                try {
                    channelFrame.contentWindow.postMessage(message, '*');
                    console.log('🔍 [DEBUG] Sent content request to channel-frame');
                } catch (error) {
                    console.error('🔍 [DEBUG] Error sending to channel-frame:', error);
                }
            }
            
            if (channelFrameIndexing && channelFrameIndexing.contentWindow) {
                try {
                    channelFrameIndexing.contentWindow.postMessage(message, '*');
                    console.log('🔍 [DEBUG] Sent content request to channel-frame-indexing');
                } catch (error) {
                    console.error('🔍 [DEBUG] Error sending to channel-frame-indexing:', error);
                }
            }
        }

        // NEW: Manual trigger for testing content display
        function testContentDisplay() {
            console.log('=== MANUAL CONTENT DISPLAY TEST ===');
            console.log('Current app state:', {
                isIndexing: appState.isIndexing,
                detectedShow: appState.detectedShow?.title,
                transitionSystem: !!window.transitionSystem
            });
            
            // Add some test content to transition system if available
            if (window.transitionSystem) {
                const testContent = {
                    title: 'Test Show S1:E1',
                    timeIndexed: 22,
                    points: 4.4,
                    multiplier: 1.0,
                    duration: 22,
                    service: 'Netflix'
                };
                window.transitionSystem.state.playedContent.push(testContent);
                console.log('Added test content to transition system');
            }
            
            triggerContentDisplayUpdate('manual_test');
        }

        // NEW: Trigger content display update with specific transition context
        function triggerContentDisplayUpdate(context = 'general') {
            console.log(`=== CONTENT DISPLAY TRIGGER: ${context.toUpperCase()} ===`);
            
            const triggers = {
                'session_start': 'Session started - initializing content blocks',
                'show_transition': 'Show transition - updating current/completed blocks',
                'fast_mode_transition': 'Fast mode transition - rapid block updates',
                'session_complete': 'Session completed - finalizing all blocks',
                'manual_update': 'Manual update requested',
                'general': 'General content display update'
            };
            
            console.log('Context:', triggers[context] || 'Unknown trigger context');
            console.log('Current detected show:', appState.detectedShow?.title || 'None');
            console.log('Transition system available:', !!window.transitionSystem);
            
            // Call the main update function
            updateContentDisplay();
        }
        
        // NEW: Update button text with current show title
        function updateButtonWithCurrentShow(show) {
            const ctaButton = document.getElementById('cta-button');
            const stopIndexingButton = document.getElementById('stop-indexing-button');
            
            if (!show) return;
            
            // Format show title for button
            let buttonText = '';
            if (show.season && show.episode) {
                buttonText = `STOP WATCHING ${show.title} ${show.season}:${show.episode}`;
            } else if (show.year) {
                buttonText = `STOP WATCHING ${show.title} (${show.year})`;
            } else {
                buttonText = `STOP WATCHING ${show.title}`;
            }
            
            // Update both buttons if they exist
            if (ctaButton) {
                ctaButton.textContent = buttonText;
                console.log('Updated CTA button text:', buttonText);
            }
            
            if (stopIndexingButton) {
                stopIndexingButton.textContent = buttonText;
                console.log('Updated stop indexing button text:', buttonText);
            }
        }

        // NEW: Update stop indexing button (wrapper function)
        function updateStopIndexingButton() {
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                updateButtonWithCurrentShow(appState.detectedShow);
            } else if (appState.entryPoint === 'automode' && appState.automodeContentItems && appState.automodeContentItems.length > 0) {
                const currentItem = appState.automodeContentItems[appState.currentContentIndex];
                if (currentItem) {
                    updateStopIndexingButtonText(currentItem.title);
                } else {
                    const stopButton = document.getElementById('stop-indexing-btn');
                    if (stopButton) {
                        stopButton.textContent = 'STOP INDEXING';
                    }
                }
            }
        }
        
        // NEW: Update stop indexing button text with specific content title
        function updateStopIndexingButtonText(title) {
            const stopButton = document.getElementById('stop-indexing-btn');
            if (stopButton) {
                stopButton.textContent = `STOP INDEXING ${title}`;
                console.log(`Updated stop indexing button text: ${title}`);
            }
        }

        // NEW: Test function for multiple transitions
        function testMultipleTransitions() {
            console.log('=== TESTING MULTIPLE TRANSITIONS ===');
            
            if (!window.transitionSystem) {
                console.log('Transition system not available');
                return;
            }
            
            // Test shows for transitions - will be loaded from CSV
            const testShows = availableShows.slice(0, 4); // Use first 4 shows from CSV
            
            console.log('Current transition count:', appState.transitionCount || 0);
            console.log('Available test shows:', testShows.length);
            
            // Show current state
            const currentState = window.transitionSystem.getCurrentState();
            console.log('Current show:', currentState.currentShow?.title || 'None');
            console.log('Played content count:', currentState.playedContent.length);
            
            // Instructions for manual testing
            console.log('');
            console.log('To test multiple transitions:');
            console.log('1. Start a session with startIndexingWithTransitionSystem()');
            console.log('2. Add some time: transitionSystem.updateIndexingProgress(1)');
            console.log('3. Transition to show 1: transitionToShowWithSystem(testShows[0])');
            console.log('4. Add more time: transitionSystem.updateIndexingProgress(1)');
            console.log('5. Transition to show 2: transitionToShowWithSystem(testShows[1])');
            console.log('6. Continue pattern for 3rd, 4th transitions...');
            console.log('');
            console.log('Use debugTransitionSystem() to check state after each transition');
            
            // Make test shows available globally for easy access
            window.testShows = testShows;
            console.log('Test shows available as window.testShows');
            
            console.log('=== END MULTIPLE TRANSITIONS TEST ===');
        }

        // ============================================================================
        // END TRANSITION SYSTEM INTEGRATION
        // ============================================================================

        // NEW: Test function for automatic transitions with short durations
        function testAutomaticTransitions() {
            console.log('=== TESTING AUTOMATIC TRANSITIONS ===');
            
            if (!appState.isIndexing) {
                console.log('Please start an indexing session first');
                return;
            }
            
            if (!window.transitionSystem) {
                console.log('Transition system not available');
                return;
            }
            
            // Set very short durations for testing (10 seconds per show)
            const testDuration = 10; // 10 seconds
            appState.contentItemDuration = testDuration;
            
            console.log(`Set show duration to ${testDuration} seconds for testing`);
            console.log('Current show will auto-transition to next show in channel after 10 seconds');
            console.log('Watch the console for transition messages...');
            
            // Reset the start time for current content item
            const elapsedTime = (Date.now() - appState.indexingStartTime) / 1000;
            appState.contentItemStartTime = elapsedTime;
            
            console.log('Test started! Automatic transition will happen in 10 seconds...');
            console.log('=== END TEST SETUP ===');
        }

        // NEW: Debug function to test fast mode and channel expansion fixes
        function testFastModeAndChannelFixes() {
            console.log('=== TESTING FAST MODE AND CHANNEL FIXES ===');
            
            // Debug current state first
            console.log('Current app state:', {
                isIndexing: appState.isIndexing,
                channelExpanded: appState.channelExpanded,
                userInitiatedChannelChange: appState.userInitiatedChannelChange
            });
            
            // Test 1: Channel expansion protection during indexing
            console.log('\nTest 1: Channel expansion protection during indexing');
            if (appState.isIndexing) {
                console.log('Session is active - testing channel expansion protection');
                const originalState = appState.channelExpanded;
                
                // IMPORTANT: Ensure the userInitiatedChannelChange flag is false for this test
                appState.userInitiatedChannelChange = false;
                console.log('Reset userInitiatedChannelChange to false for test');
                
                // Try to change channel state without user initiation (should be blocked)
                console.log(`Attempting automatic change from ${originalState} to ${!originalState}`);
                setChannelExpansionState(!originalState);
                console.log(`Result - Original: ${originalState}, Current: ${appState.channelExpanded}`);
                
                if (appState.channelExpanded === originalState) {
                    console.log('✅ Channel expansion protection working - automatic change blocked');
                } else {
                    console.log('❌ Channel expansion protection failed - automatic change allowed');
                }
                
                // Try to change with user initiation (should work)
                console.log(`\nTesting user-initiated change from ${appState.channelExpanded} to ${!appState.channelExpanded}`);
                appState.userInitiatedChannelChange = true;
                setChannelExpansionState(!appState.channelExpanded);
                console.log(`After user-initiated change: ${appState.channelExpanded}`);
                
                if (appState.channelExpanded !== originalState) {
                    console.log('✅ User-initiated channel change working');
                } else {
                    console.log('❌ User-initiated channel change failed');
                }
                
                // Restore original state
                appState.userInitiatedChannelChange = true;
                setChannelExpansionState(originalState);
                console.log(`Restored to original state: ${appState.channelExpanded}`);
            } else {
                console.log('No active session - start indexing first to test channel protection');
            }
            
            // Test 2: Fast mode content preservation
            console.log('\nTest 2: Fast mode content preservation');
            if (appState.fastMode && appState.fastMode.active) {
                console.log('Fast mode is active - testing content preservation');
                triggerContentDisplayUpdate('fast_mode_test');
                console.log('Content display update triggered with fast mode context');
            } else if (appState.isIndexing) {
                console.log('Session active but fast mode not active - you can test by enabling fast mode');
            } else {
                console.log('No active session - start indexing and enable fast mode to test');
            }
            
            // Test 3: Content display data structure
            console.log('\nTest 3: Content display data structure');
            const testData = {
                playedContent: [],
                currentShow: appState.detectedShow,
                elapsedTime: 0,
                fastModeActive: appState.fastMode && appState.fastMode.active,
                preserveAllContent: true
            };
            console.log('Test content data structure:', testData);
            
            console.log('\n=== END FAST MODE AND CHANNEL FIXES TEST ===');
        }

        window.initializeTransitionSystem = initializeTransitionSystem;
        window.debugTransitionSystem = debugTransitionSystem;
        window.startIndexingWithTransitionSystem = startIndexingWithTransitionSystem;
        window.transitionToShowWithSystem = transitionToShowWithSystem;
        window.completeSessionWithTransitionSystem = completeSessionWithTransitionSystem;
        window.testMultipleTransitions = testMultipleTransitions;
        window.testAutomaticTransitions = testAutomaticTransitions;
        window.testFastModeAndChannelFixes = testFastModeAndChannelFixes;
        
        // NEW: Simple test function for channel protection
        function testChannelProtection() {
            console.log('=== SIMPLE CHANNEL PROTECTION TEST ===');
            console.log('Current state:', {
                isIndexing: appState.isIndexing,
                channelExpanded: appState.channelExpanded,
                userInitiated: appState.userInitiatedChannelChange
            });
            
            if (!appState.isIndexing) {
                console.log('❌ No active session - start indexing first');
                return;
            }
            
            const originalState = appState.channelExpanded;
            
            // Test 1: Automatic change (should be blocked)
            console.log('\n1. Testing automatic change (should be blocked):');
            appState.userInitiatedChannelChange = false;
            setChannelExpansionState(!originalState);
            
            if (appState.channelExpanded === originalState) {
                console.log('✅ PASS: Automatic change was blocked');
            } else {
                console.log('❌ FAIL: Automatic change was allowed');
            }
            
            // Test 2: User-initiated change (should work)
            console.log('\n2. Testing user-initiated change (should work):');
            appState.userInitiatedChannelChange = true;
            setChannelExpansionState(!originalState);
            
            if (appState.channelExpanded !== originalState) {
                console.log('✅ PASS: User-initiated change worked');
            } else {
                console.log('❌ FAIL: User-initiated change was blocked');
            }
            
            // Restore original state
            appState.userInitiatedChannelChange = true;
            setChannelExpansionState(originalState);
            
            console.log('\n=== END SIMPLE TEST ===');
        }
        
        window.testChannelProtection = testChannelProtection;
        
        // NEW: Test function to verify content preservation during indexing start
        function testContentPreservationOnIndexingStart() {
            console.log('=== TESTING CONTENT PRESERVATION ON INDEXING START ===');
            
            if (appState.isIndexing) {
                console.log('❌ Session already active - stop indexing first to test');
                return;
            }
            
            // Check if channel has content before starting
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel iframe not found or not loaded');
                return;
            }
            
            console.log('✅ Channel iframe found');
            console.log('1. Check if channel has content before starting indexing');
            console.log('2. Start indexing');
            console.log('3. Verify content is preserved');
            
            // Start indexing and monitor
            console.log('\nStarting indexing session...');
            startIndexing();
            
            // Check content after a brief delay
            setTimeout(() => {
                console.log('\nChecking content preservation after indexing start...');
                
                try {
                    const iframeDocument = channelFrame.contentWindow.document;
                    const programTrack = iframeDocument.getElementById('program-track');
                    
                    if (programTrack) {
                        const programSlots = programTrack.querySelectorAll('.program-slot');
                        console.log(`Program track found with ${programSlots.length} slots`);
                        
                        const visibleSlots = Array.from(programSlots).filter(slot => 
                            slot.style.display !== 'none' && slot.style.visibility !== 'hidden'
                        );
                        
                        console.log(`${visibleSlots.length} slots are visible`);
                        
                        if (visibleSlots.length > 0) {
                            console.log('✅ PASS: Content preserved during indexing start');
                            visibleSlots.slice(0, 3).forEach((slot, index) => {
                                const title = slot.querySelector('.program-title')?.textContent || 'Unknown';
                                console.log(`  Slot ${index + 1}: ${title}`);
                            });
                        } else {
                            console.log('❌ FAIL: All content disappeared during indexing start');
                        }
                    } else {
                        console.log('❌ Program track not found in channel');
                    }
                } catch (e) {
                    console.log('❌ Cannot access channel content (CORS):', e.message);
                }
                
                console.log('\n=== END CONTENT PRESERVATION TEST ===');
            }, 1000);
        }
        
        window.testContentPreservationOnIndexingStart = testContentPreservationOnIndexingStart;
        
        // NEW: Better test that uses message passing to verify content preservation
        function testContentPreservationViaMsgs() {
            console.log('=== TESTING CONTENT PRESERVATION VIA MESSAGES ===');
            
            if (appState.isIndexing) {
                console.log('❌ Session already active - stop indexing first to test');
                return;
            }
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel iframe not found or not loaded');
                return;
            }
            
            let contentBeforeIndexing = [];
            let contentAfterIndexing = [];
            
            // Step 1: Get content before starting indexing
            console.log('Step 1: Getting content before indexing starts...');
            
            // Set up message listener for content responses
            const messageHandler = (event) => {
                if (event.data.type === 'currentContentResponse') {
                    if (contentBeforeIndexing.length === 0) {
                        contentBeforeIndexing = event.data.content || [];
                        console.log(`✅ Content before indexing: ${contentBeforeIndexing.length} items`);
                        
                        if (contentBeforeIndexing.length > 0) {
                            console.log('  First item:', contentBeforeIndexing[0].title);
                            
                            // Step 2: Start indexing
                            console.log('\nStep 2: Starting indexing...');
                            startIndexing();
                            
                            // Step 3: Check content after indexing starts
                            setTimeout(() => {
                                console.log('\nStep 3: Getting content after indexing started...');
                                channelFrame.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
                            }, 1000);
                        } else {
                            console.log('❌ No content found before indexing - populate channel first');
                            window.removeEventListener('message', messageHandler);
                        }
                    } else {
                        // This is the response after indexing started
                        contentAfterIndexing = event.data.content || [];
                        console.log(`✅ Content after indexing: ${contentAfterIndexing.length} items`);
                        
                        // Compare results
                        console.log('\n=== COMPARISON RESULTS ===');
                        if (contentAfterIndexing.length === contentBeforeIndexing.length) {
                            console.log('✅ PASS: Same number of content items preserved');
                            console.log(`  Before: ${contentBeforeIndexing.length} items`);
                            console.log(`  After: ${contentAfterIndexing.length} items`);
                            
                            // Check if first item is the same
                            if (contentBeforeIndexing[0] && contentAfterIndexing[0] && 
                                contentBeforeIndexing[0].title === contentAfterIndexing[0].title) {
                                console.log('✅ PASS: First item preserved correctly');
                                console.log(`  Item: ${contentAfterIndexing[0].title}`);
                            } else {
                                console.log('⚠️ WARNING: First item may have changed');
                            }
                        } else {
                            console.log('❌ FAIL: Content count changed during indexing start');
                            console.log(`  Before: ${contentBeforeIndexing.length} items`);
                            console.log(`  After: ${contentAfterIndexing.length} items`);
                        }
                        
                        console.log('\n=== END CONTENT PRESERVATION TEST ===');
                        window.removeEventListener('message', messageHandler);
                    }
                }
            };
            
            window.addEventListener('message', messageHandler);
            
            // Request initial content
            channelFrame.contentWindow.postMessage({ type: 'requestCurrentContent' }, '*');
        }
        
        window.testContentPreservationViaMsgs = testContentPreservationViaMsgs;
        
        // NEW: Test function to validate visual styles and CSS classes
        function testVisualStyles() {
            console.log('=== TESTING VISUAL STYLES AND CSS CLASSES ===');
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel iframe not found or not loaded');
                return;
            }
            
            let testResults = {
                visibility: { pass: 0, fail: 0, total: 0 },
                cssClasses: { pass: 0, fail: 0, total: 0 },
                statusIcons: { pass: 0, fail: 0, total: 0 }
            };
            
            // Set up message listener for style validation
            const styleTestHandler = (event) => {
                if (event.data.type === 'styleValidationResponse') {
                    const results = event.data.results;
                    console.log('\n=== STYLE VALIDATION RESULTS ===');
                    
                    // Test 1: Block Visibility
                    console.log('\n1. Block Visibility Test:');
                    results.blocks.forEach((block, index) => {
                        const isVisible = block.display !== 'none' && block.visibility !== 'hidden';
                        console.log(`  Block ${index + 1} (${block.title}): ${isVisible ? '✅ VISIBLE' : '❌ HIDDEN'}`);
                        console.log(`    Display: ${block.display}, Visibility: ${block.visibility}`);
                        
                        testResults.visibility.total++;
                        if (isVisible) testResults.visibility.pass++;
                        else testResults.visibility.fail++;
                    });
                    
                    // Test 2: CSS Classes
                    console.log('\n2. CSS Classes Test:');
                    results.blocks.forEach((block, index) => {
                        console.log(`  Block ${index + 1} (${block.title}):`);
                        console.log(`    Classes: ${block.classes.join(', ') || 'none'}`);
                        
                        testResults.cssClasses.total++;
                        
                        // Check for proper class usage
                        const hasValidClasses = block.classes.includes('program-slot');
                        if (hasValidClasses) {
                            console.log(`    ✅ Has proper base class`);
                            testResults.cssClasses.pass++;
                        } else {
                            console.log(`    ❌ Missing base class 'program-slot'`);
                            testResults.cssClasses.fail++;
                        }
                        
                        // Check state classes
                        const stateClasses = block.classes.filter(cls => 
                            ['completed', 'current', 'playing'].includes(cls)
                        );
                        if (stateClasses.length > 0) {
                            console.log(`    State classes: ${stateClasses.join(', ')}`);
                        }
                    });
                    
                    // Test 3: Status Icons
                    console.log('\n3. Status Icons Test:');
                    results.blocks.forEach((block, index) => {
                        testResults.statusIcons.total++;
                        
                        if (block.statusIcon) {
                            console.log(`  Block ${index + 1}: ✅ Has status icon "${block.statusIcon}"`);
                            testResults.statusIcons.pass++;
                        } else {
                            console.log(`  Block ${index + 1}: ⚪ No status icon`);
                            // No status icon is not necessarily a failure
                            testResults.statusIcons.pass++;
                        }
                    });
                    
                    // Test 4: Fast Mode Specific Checks
                    if (appState.fastMode && appState.fastMode.active) {
                        console.log('\n4. Fast Mode Specific Tests:');
                        const allVisible = results.blocks.every(block => 
                            block.display !== 'none' && block.visibility !== 'hidden'
                        );
                        console.log(`  All blocks visible in fast mode: ${allVisible ? '✅ PASS' : '❌ FAIL'}`);
                    }
                    
                    // Test 5: Indexing State Checks
                    if (appState.isIndexing) {
                        console.log('\n5. Indexing State Tests:');
                        const programTrackVisible = results.programTrackDisplay === 'block';
                        console.log(`  Program track visible during indexing: ${programTrackVisible ? '✅ PASS' : '❌ FAIL'}`);
                    }
                    
                    // Summary
                    console.log('\n=== TEST SUMMARY ===');
                    console.log(`Visibility: ${testResults.visibility.pass}/${testResults.visibility.total} passed`);
                    console.log(`CSS Classes: ${testResults.cssClasses.pass}/${testResults.cssClasses.total} passed`);
                    console.log(`Status Icons: ${testResults.statusIcons.pass}/${testResults.statusIcons.total} passed`);
                    
                    const totalTests = testResults.visibility.total + testResults.cssClasses.total + testResults.statusIcons.total;
                    const totalPassed = testResults.visibility.pass + testResults.cssClasses.pass + testResults.statusIcons.pass;
                    
                    console.log(`\n🎯 OVERALL SCORE: ${totalPassed}/${totalTests} tests passed (${Math.round(totalPassed/totalTests*100)}%)`);
                    
                    if (totalPassed === totalTests) {
                        console.log('🎉 ALL TESTS PASSED! Visual styles are working correctly.');
                    } else if (totalPassed / totalTests >= 0.8) {
                        console.log('⚠️ Most tests passed, but some issues detected.');
                    } else {
                        console.log('❌ Multiple style issues detected. Review the results above.');
                    }
                    
                    console.log('\n=== END VISUAL STYLES TEST ===');
                    window.removeEventListener('message', styleTestHandler);
                }
            };
            
            window.addEventListener('message', styleTestHandler);
            
            // Request style validation from channel
            console.log('Requesting style validation from channel...');
            channelFrame.contentWindow.postMessage({ type: 'validateStyles' }, '*');
        }
        
        window.testVisualStyles = testVisualStyles;
        
        // NEW: Test styles in different modes (normal, fast mode, indexing)
        function testStylesInAllModes() {
            console.log('=== TESTING STYLES IN ALL MODES ===');
            
            // Test 1: Normal mode (ensure we're not in any special mode)
            console.log('\n🔄 Testing Normal Mode Styles...');
            if (appState.fastMode) appState.fastMode.active = false;
            if (appState.isIndexing) {
                console.log('⚠️ Currently indexing, stopping for clean test');
                stopIndexing();
                setTimeout(() => testNormalModeStyles(), 1000);
            } else {
                testNormalModeStyles();
            }
            
            function testNormalModeStyles() {
                console.log('📊 Normal Mode - Running style validation...');
                testVisualStyles();
                
                setTimeout(() => {
                    // Test 2: Fast mode
                    console.log('\n🔄 Testing Fast Mode Styles...');
                    if (!appState.fastMode) appState.fastMode = {};
                    appState.fastMode.active = true;
                    console.log('⚡ Fast mode activated');
                    
                    // Trigger content update to apply fast mode styles
                    triggerContentDisplayUpdate('fast_mode_test');
                    
                    setTimeout(() => {
                        console.log('📊 Fast Mode - Running style validation...');
                        testVisualStyles();
                        
                        setTimeout(() => {
                            // Test 3: Indexing mode
                            console.log('\n🔄 Testing Indexing Mode Styles...');
                            appState.fastMode.active = false;
                            
                            // Simulate indexing start
                            if (!appState.isIndexing) {
                                console.log('🎬 Starting indexing for style test...');
                                startIndexing();
                            }
                            
                            setTimeout(() => {
                                console.log('📊 Indexing Mode - Running style validation...');
                                testVisualStyles();
                                
                                setTimeout(() => {
                                    // Cleanup
                                    console.log('\n🧹 Cleaning up test modes...');
                                    if (appState.fastMode) appState.fastMode.active = false;
                                    if (appState.isIndexing) stopIndexing();
                                    console.log('✅ All mode tests completed!');
                                }, 2000);
                            }, 2000);
                        }, 2000);
                    }, 2000);
                }, 2000);
            }
        }
        
        window.testStylesInAllModes = testStylesInAllModes;
        
        // NEW: Quick style validation test (just checks current state)
        function quickStyleTest() {
            console.log('=== QUICK STYLE VALIDATION ===');
            console.log('Current app state:');
            console.log('- Is indexing:', appState.isIndexing);
            console.log('- Fast mode active:', appState.fastMode?.active || false);
            console.log('- Show detected:', appState.detectedShow?.title || 'None');
            
            testVisualStyles();
        }

        // NEW: Test function for modal activation protection
        function testModalActivationProtection() {
            console.log('=== Testing Modal Activation Protection ===');
            
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel frame not found or not accessible');
                return;
            }
            
            let preModalContent = null;
            let postModalContent = null;
            
            // Step 1: Get content before modal activation
            console.log('📊 Step 1: Getting content before modal activation...');
            channelFrame.contentWindow.postMessage({ 
                type: 'requestContentCount',
                requestId: 'pre-modal'
            }, '*');
            
            // Listen for the response
            const messageHandler = (event) => {
                if (event.data && event.data.type === 'contentCountResponse') {
                    if (event.data.requestId === 'pre-modal') {
                        preModalContent = event.data.content;
                        console.log(`✅ Pre-modal: ${preModalContent.count} content items`);
                        console.log('Pre-modal items:', preModalContent.items.map(item => item.title));
                        
                                                // Step 2: Simulate modal button click (Continue with Rumi)
                        console.log('🔄 Step 2: Simulating modal button click (Continue with Rumi)...');
                        
                        // Simulate what happens when user clicks "Continue with Rumi" button
                        setTimeout(() => {
                            console.log('Simulating "Continue with Rumi" button click...');
                            // This is what the actual button click does
                            appState.userInitiatedChannelChange = true;
                            showGenreChannel();
                            
                            // Step 3: Get content after modal activation
                            setTimeout(() => {
                                console.log('📊 Step 3: Getting content after modal activation...');
                                channelFrame.contentWindow.postMessage({ 
                                    type: 'requestContentCount',
                                    requestId: 'post-modal'
                                }, '*');
                            }, 1000);
                        }, 500);
                        
                    } else if (event.data.requestId === 'post-modal') {
                        postModalContent = event.data.content;
                        console.log(`✅ Post-modal: ${postModalContent.count} content items`);
                        console.log('Post-modal items:', postModalContent.items.map(item => item.title));
                        
                        // Step 4: Compare results
                        console.log('🔍 Step 4: Comparing results...');
                        const contentLoss = preModalContent.count - postModalContent.count;
                        
                        if (contentLoss === 0) {
                            console.log('✅ SUCCESS: No content loss during modal activation!');
                            console.log(`✅ Content preserved: ${preModalContent.count} → ${postModalContent.count}`);
                            
                            // Check if items are identical
                            const preItems = preModalContent.items.map(item => item.title).sort();
                            const postItems = postModalContent.items.map(item => item.title).sort();
                            const itemsIdentical = JSON.stringify(preItems) === JSON.stringify(postItems);
                            
                            if (itemsIdentical) {
                                console.log('✅ Content identical: Modal protection working correctly');
                            } else {
                                console.log('⚠️ Content different: Items changed during modal activation');
                                console.log('Pre-modal:', preItems);
                                console.log('Post-modal:', postItems);
                            }
                        } else {
                            console.log(`❌ CONTENT LOSS: Lost ${contentLoss} items during modal activation`);
                            console.log(`❌ Content changed: ${preModalContent.count} → ${postModalContent.count}`);
                            console.log('❌ Modal protection may not be working correctly');
                        }
                        
                        // Cleanup
                        window.removeEventListener('message', messageHandler);
                        console.log('=== Modal Protection Test Complete ===');
                    }
                }
            };
            
            window.addEventListener('message', messageHandler);
        }
        
        window.quickStyleTest = quickStyleTest;

        // NEW: Test function for vertical layout stability
        function testVerticalLayoutStability() {
            console.log('=== Testing Vertical Layout Stability ===');
            
            const channelFrame = document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel frame not found or not accessible');
                return;
            }
            
            let initialPositions = [];
            let testCount = 0;
            const maxTests = 5;
            
            // Function to get current positions
            function getCurrentPositions() {
                return new Promise((resolve) => {
                    const messageHandler = (event) => {
                        if (event.data && event.data.type === 'layoutPositionsResponse') {
                            window.removeEventListener('message', messageHandler);
                            resolve(event.data.positions);
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    channelFrame.contentWindow.postMessage({ type: 'getLayoutPositions' }, '*');
                    
                    // Timeout after 2 seconds
                    setTimeout(() => {
                        window.removeEventListener('message', messageHandler);
                        resolve(null);
                    }, 2000);
                });
            }
            
            // Function to run a single test
            async function runLayoutTest() {
                testCount++;
                console.log(`\n📊 Layout Test ${testCount}/${maxTests}:`);
                
                // Get current positions
                const positions = await getCurrentPositions();
                if (!positions) {
                    console.log('❌ Could not get layout positions');
                    return false;
                }
                
                console.log(`Found ${positions.length} content blocks`);
                positions.forEach((pos, index) => {
                    console.log(`  Block ${index + 1}: top=${pos.top}px, left=${pos.left}%, height=${pos.height}px`);
                });
                
                if (testCount === 1) {
                    // Store initial positions
                    initialPositions = positions;
                    console.log('✅ Initial positions recorded');
                    return true;
                } else {
                    // Compare with initial positions
                    let layoutStable = true;
                    
                    if (positions.length !== initialPositions.length) {
                        console.log(`❌ Content count changed: ${initialPositions.length} → ${positions.length}`);
                        layoutStable = false;
                    } else {
                        for (let i = 0; i < positions.length; i++) {
                            const initial = initialPositions[i];
                            const current = positions[i];
                            
                            // Check for vertical shifts (top position changes)
                            if (Math.abs(current.top - initial.top) > 1) {
                                console.log(`❌ Block ${i + 1} shifted vertically: ${initial.top}px → ${current.top}px`);
                                layoutStable = false;
                            }
                            
                            // Check for height changes
                            if (Math.abs(current.height - initial.height) > 1) {
                                console.log(`⚠️ Block ${i + 1} height changed: ${initial.height}px → ${current.height}px`);
                            }
                        }
                    }
                    
                    if (layoutStable) {
                        console.log('✅ Layout stable - no vertical shifts detected');
                    }
                    
                    return layoutStable;
                }
            }
            
            // Function to trigger UI updates (simulating playback)
            function triggerUIUpdates() {
                console.log('🔄 Triggering UI updates to simulate playback...');
                
                // Trigger various updates that might cause layout shifts
                updateUI();
                triggerContentDisplayUpdate('layout_test');
                
                // Update points display
                if (typeof updatePointsDisplay === 'function') {
                    updatePointsDisplay();
                }
                
                // Update progress if in session
                if (appState.isIndexing) {
                    updateProgress();
                }
            }
            
            // Run the test sequence
            async function runTestSequence() {
                console.log('Starting vertical layout stability test...');
                
                // Initial measurement
                const initialTest = await runLayoutTest();
                if (!initialTest) {
                    console.log('❌ Failed to get initial layout measurements');
                    return;
                }
                
                let allTestsPassed = true;
                
                // Run tests with UI updates
                for (let i = 2; i <= maxTests; i++) {
                    // Trigger UI updates
                    triggerUIUpdates();
                    
                    // Wait for updates to complete
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Test layout stability
                    const testPassed = await runLayoutTest();
                    if (!testPassed) {
                        allTestsPassed = false;
                    }
                }
                
                // Final summary
                console.log('\n🎯 VERTICAL LAYOUT STABILITY TEST RESULTS:');
                if (allTestsPassed) {
                    console.log('✅ ALL TESTS PASSED: Layout is stable during playback');
                    console.log('✅ No vertical shifting detected in content boxes');
                } else {
                    console.log('❌ SOME TESTS FAILED: Vertical layout shifts detected');
                    console.log('❌ Content boxes are shifting during playback');
                }
                
                console.log('=== Vertical Layout Test Complete ===');
            }
            
            runTestSequence();
        }
        
        // NEW: Test function to validate content preservation during show transitions
        function testTransitionContentPreservation() {
            console.log('=== TESTING TRANSITION CONTENT PRESERVATION ===');
            
            const channelFrame = document.getElementById('channel-frame') || document.getElementById('channel-frame-indexing');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('❌ Channel iframe not found or not loaded');
                return;
            }
            
            // Variables to store test data across handler calls
            let preTransitionCount = 0;
            let preTransitionItems = [];
            let previousShow = null;
            
            // First, get the current content count
            console.log('Step 1: Getting current content before transition...');
            
            const transitionTestHandler = (event) => {
                if (event.data.type === 'contentCountResponse' && event.data.testContext === 'pre-transition') {
                    preTransitionCount = event.data.count;
                    preTransitionItems = event.data.items;
                    
                    console.log(`Pre-transition content: ${preTransitionCount} items`);
                    console.log('Pre-transition items:', preTransitionItems);
                    
                    // Now simulate a show transition
                    console.log('\nStep 2: Simulating show transition...');
                    
                    // Create a test transition
                    const testNewShow = {
                        title: 'Test Transition Show',
                        season: 'S1',
                        episode: 'E1',
                        duration: 45,
                        service: 'Test Service'
                    };
                    
                    // Mark as transitioning
                    appState.isTransitioning = true;
                    
                    // Update detected show
                    previousShow = appState.detectedShow;
                    appState.detectedShow = testNewShow;
                    
                    // Trigger a show transition content update
                    triggerContentDisplayUpdate('show_transition');
                    
                    // Wait a moment for the transition to process
                    setTimeout(() => {
                        console.log('\nStep 3: Checking content after transition...');
                        
                        // Request content count again
                        channelFrame.contentWindow.postMessage({
                            type: 'contentCountRequest',
                            testContext: 'post-transition'
                        }, '*');
                        
                        // Clean up transition state
                        appState.isTransitioning = false;
                        appState.detectedShow = previousShow; // Restore original show
                        
                    }, 1000);
                    
                } else if (event.data.type === 'contentCountResponse' && event.data.testContext === 'post-transition') {
                    const postTransitionCount = event.data.count;
                    const postTransitionItems = event.data.items;
                    
                    console.log(`Post-transition content: ${postTransitionCount} items`);
                    console.log('Post-transition items:', postTransitionItems);
                    
                    // Compare results
                    console.log('\n=== TRANSITION PRESERVATION RESULTS ===');
                    
                    if (postTransitionCount === 0) {
                        console.log('❌ CRITICAL ISSUE: All content disappeared during transition!');
                        console.log('This confirms the reported bug.');
                    } else if (postTransitionCount < preTransitionCount) {
                        console.log(`⚠️ CONTENT LOSS: ${preTransitionCount - postTransitionCount} items lost during transition`);
                        console.log('Some content preservation working, but not complete.');
                    } else if (postTransitionCount === preTransitionCount) {
                        console.log('✅ CONTENT PRESERVED: All items maintained during transition');
                        console.log('Transition content preservation is working correctly!');
                        
                        // Check if items are the same
                        const itemsMatch = preTransitionItems.length === postTransitionItems.length &&
                            preTransitionItems.every((item, index) => 
                                item.title === postTransitionItems[index]?.title
                            );
                        
                        if (itemsMatch) {
                            console.log('✅ CONTENT IDENTICAL: Same items in same order');
                        } else {
                            console.log('🔄 CONTENT REORDERED: Same count but different order/items');
                        }
                    } else {
                        console.log(`🔄 CONTENT CHANGED: ${postTransitionCount - preTransitionCount} items difference`);
                        console.log('Content may have been updated rather than lost.');
                    }
                    
                    // Additional debugging info
                    console.log('\nDetailed comparison:');
                    console.log('Before:', preTransitionItems.map(item => item.title));
                    console.log('After:', postTransitionItems.map(item => item.title));
                    
                    console.log('\n=== END TRANSITION PRESERVATION TEST ===');
                    window.removeEventListener('message', transitionTestHandler);
                }
            };
            
            window.addEventListener('message', transitionTestHandler);
            
            // Start the test by requesting current content
            channelFrame.contentWindow.postMessage({
                type: 'contentCountRequest',
                testContext: 'pre-transition'
            }, '*');
        }
        
        window.testTransitionContentPreservation = testTransitionContentPreservation;
        
        // Learning Insights and Dashboard Functions
        function toggleLearningInsights() {
            const statsGrid = document.getElementById('insights-stats-grid');
            const expandIcon = document.getElementById('insights-expand-icon');
            
            if (statsGrid.classList.contains('expanded')) {
                statsGrid.classList.remove('expanded');
                expandIcon.textContent = '▼';
            } else {
                statsGrid.classList.add('expanded');
                expandIcon.textContent = '▲';
                // Update insights data when expanded
                updateLearningInsights();
            }
            
            Tracker.logRumiAction('Learning insights toggled', { expanded: statsGrid.classList.contains('expanded') });
        }
        
        function toggleProgressDashboard() {
            const dashboardGrid = document.getElementById('progress-dashboard-grid');
            const expandIcon = document.getElementById('dashboard-expand-icon');
            
            if (dashboardGrid.classList.contains('expanded')) {
                dashboardGrid.classList.remove('expanded');
                expandIcon.textContent = '▼';
            } else {
                dashboardGrid.classList.add('expanded');
                expandIcon.textContent = '▲';
                // Update dashboard when expanded
                updateProgressDashboard();
            }
            
            Tracker.logRumiAction('Progress dashboard toggled', { expanded: dashboardGrid.classList.contains('expanded') });
        }
        
        function updateLearningInsights() {
            // Update insights with real-time data based on current session
            const elapsedTime = appState.isIndexing ? TimeSystem.getElapsedTime() : 0;
            const sessionMinutes = Math.floor(elapsedTime / 60);
            
            // Get current clip information for context-aware updates
            const currentItem = appState.automodeContentItems && appState.automodeContentItems.length > 0 ? 
                appState.automodeContentItems[appState.currentContentIndex] : null;
            
            // Calculate dynamic values based on session progress and current clip
            const basePatterns = 127;
            const baseGenres = 8;
            const baseAccuracy = 12;
            const baseConnections = 2847;
            const baseSamples = 1203;
            const baseConfidence = 87.3;
            
            // Adjust multipliers based on current clip type
            let contentMultiplier = 1.0;
            if (currentItem) {
                switch (currentItem.type?.toLowerCase()) {
                    case 'movie':
                        contentMultiplier = 1.5; // Movies provide more complex patterns
                        break;
                    case 'series':
                    case 'episode':
                        contentMultiplier = 1.2; // Series have narrative patterns
                        break;
                    case 'documentary':
                        contentMultiplier = 1.8; // Documentaries have rich metadata
                        break;
                    default:
                        contentMultiplier = 1.0;
                }
            }
            
            // Update patterns detected (increases with time and content complexity)
            const patternsDetected = basePatterns + Math.floor(sessionMinutes * 2.3 * contentMultiplier);
            document.getElementById('patterns-detected').textContent = patternsDetected.toLocaleString();
            
            // Update genres identified (increases slowly, faster with diverse content)
            const genresIdentified = Math.min(baseGenres + Math.floor(sessionMinutes / 10) + (currentItem?.genre ? 1 : 0), 15);
            document.getElementById('genres-identified').textContent = genresIdentified;
            
            // Update accuracy improvement (varies based on content type)
            const accuracyImprovement = baseAccuracy + Math.floor(sessionMinutes * 0.5 * contentMultiplier);
            document.getElementById('accuracy-improving').textContent = `+${accuracyImprovement}%`;
            
            // Update neural connections (increases with indexing)
            const neuralConnections = baseConnections + Math.floor(sessionMinutes * 15 * contentMultiplier);
            document.getElementById('neural-connections').textContent = neuralConnections.toLocaleString();
            
            // Update training samples (increases with processed content)
            const trainingSamples = baseSamples + Math.floor(sessionMinutes * 8 * contentMultiplier);
            document.getElementById('training-samples').textContent = trainingSamples.toLocaleString();
            
            // Update model confidence (improves with more data)
            const modelConfidence = Math.min(baseConfidence + (sessionMinutes * 0.2 * contentMultiplier), 95.0);
            document.getElementById('model-confidence').textContent = `${modelConfidence.toFixed(1)}%`;
            
            // Add progress bars to each stat item
            updateLearningInsightsProgressBars(sessionMinutes, contentMultiplier);
        }
        
        // NEW: Add progress bars to learning insights
        function updateLearningInsightsProgressBars(sessionMinutes, contentMultiplier) {
            const statItems = document.querySelectorAll('#insights-stats-grid .stat-item');
            
            statItems.forEach((item, index) => {
                let progressBar = item.querySelector('.progress-bar');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.className = 'progress-bar';
                    progressBar.style.cssText = `
                        width: 100%;
                        height: 3px;
                        background: #333;
                        border-radius: 2px;
                        margin-top: 4px;
                        overflow: hidden;
                    `;
                    
                    const progressFill = document.createElement('div');
                    progressFill.className = 'progress-fill';
                    progressFill.style.cssText = `
                        height: 100%;
                        background: #ffaa00;
                        transition: width 0.5s ease;
                        width: 0%;
                    `;
                    
                    progressBar.appendChild(progressFill);
                    item.appendChild(progressBar);
                }
                
                // Calculate progress based on session time and content type
                const maxTime = 240; // 4 hours max session
                const baseProgress = Math.min((sessionMinutes / maxTime) * 100, 100);
                const adjustedProgress = Math.min(baseProgress * contentMultiplier, 100);
                
                const progressFill = progressBar.querySelector('.progress-fill');
                progressFill.style.width = `${adjustedProgress}%`;
                
                // Change color based on progress
                if (adjustedProgress >= 80) {
                    progressFill.style.background = '#00ff41'; // Green when high
                } else if (adjustedProgress >= 50) {
                    progressFill.style.background = '#ffaa00'; // Orange when medium
                } else {
                    progressFill.style.background = '#666'; // Gray when low
                }
            });
        }
        
        function updateProgressDashboard() {
            if (!appState.isIndexing) return;
            
            const elapsedTime = TimeSystem.getElapsedTime();
            const sessionMinutes = Math.floor(elapsedTime / 60);
            
            // Get current clip information for context-aware activation
            const currentItem = appState.automodeContentItems && appState.automodeContentItems.length > 0 ? 
                appState.automodeContentItems[appState.currentContentIndex] : null;
            
            // Define progression stages based on session time and content type
            const stages = [
                { 
                    name: 'pattern-recognition', 
                    threshold: 0, 
                    contentTypes: ['movie', 'series', 'episode', 'documentary'], // Active for most content
                    description: 'Analyzing visual and audio patterns',
                    dynamicStates: ['Scanning patterns', 'Identifying features', 'Mapping structures', 'Correlating data']
                },
                { 
                    name: 'classification', 
                    threshold: 2, 
                    contentTypes: ['movie', 'series', 'episode', 'documentary', 'special'], // Active for structured content
                    description: 'Categorizing genre and content type',
                    dynamicStates: ['Analyzing genres', 'Classifying content', 'Tagging metadata', 'Refining categories']
                },
                { 
                    name: 'behavior-analysis', 
                    threshold: 5, 
                    contentTypes: ['series', 'episode'], // More active for episodic content
                    description: 'Understanding narrative patterns',
                    dynamicStates: ['Tracking narratives', 'Analyzing behaviors', 'Mapping relationships', 'Predicting outcomes']
                },
                { 
                    name: 'optimization', 
                    threshold: 10, 
                    contentTypes: ['movie', 'documentary'], // More active for longer content
                    description: 'Optimizing processing algorithms',
                    dynamicStates: ['Tuning algorithms', 'Optimizing models', 'Enhancing accuracy', 'Improving efficiency']
                }
            ];
            
            stages.forEach((stage, stageIndex) => {
                const item = document.getElementById(`${stage.name}-item`);
                const status = document.getElementById(`${stage.name}-status`);
                const stateText = document.getElementById(`${stage.name}-state`);
                
                if (!item || !status || !stateText) return;
                
                // Check if this stage should be active based on time and content type
                const timeThresholdMet = sessionMinutes >= stage.threshold;
                const contentTypeMatch = currentItem && stage.contentTypes.includes(currentItem.type?.toLowerCase());
                
                // Add progress bar to each dashboard item
                let progressBar = item.querySelector('.dashboard-progress');
                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.className = 'dashboard-progress';
                    progressBar.style.cssText = `
                        width: 100%;
                        height: 4px;
                        background: #333;
                        border-radius: 2px;
                        margin-top: 8px;
                        overflow: hidden;
                        position: relative;
                    `;
                    
                    const progressFill = document.createElement('div');
                    progressFill.className = 'dashboard-progress-fill';
                    progressFill.style.cssText = `
                        height: 100%;
                        background: #666;
                        transition: width 0.8s ease, background-color 0.3s ease;
                        width: 0%;
                    `;
                    
                    // Add animated glint effect for active stages
                    const glint = document.createElement('div');
                    glint.className = 'dashboard-progress-glint';
                    glint.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: -20px;
                        width: 20px;
                        height: 100%;
                        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
                        animation: glint 2s ease-in-out infinite;
                        opacity: 0;
                    `;
                    
                    progressBar.appendChild(progressFill);
                    progressBar.appendChild(glint);
                    item.appendChild(progressBar);
                }
                
                const progressFill = progressBar.querySelector('.dashboard-progress-fill');
                const glint = progressBar.querySelector('.dashboard-progress-glint');
                
                if (timeThresholdMet && (contentTypeMatch || !currentItem)) {
                    // Activate this stage
                    item.classList.add('active');
                    status.classList.remove('status-inactive', 'status-paused');
                    status.classList.add('status-active');
                    
                    // Dynamic state text that changes based on content and time
                    const stateIndex = Math.floor((elapsedTime / 3) % stage.dynamicStates.length); // Change every 3 seconds
                    const dynamicState = stage.dynamicStates[stateIndex];
                    
                    // Add content-specific context
                    let contextualState = dynamicState;
                    if (currentItem && currentItem.title) {
                        const contentType = currentItem.type || 'content';
                        contextualState = `${dynamicState} • ${contentType.toUpperCase()}`;
                    }
                    
                    stateText.textContent = contextualState;
                    
                    // Calculate progress within this stage with some randomness for liveliness
                    const timeSinceActivation = sessionMinutes - stage.threshold;
                    const maxActiveTime = 30; // 30 minutes to reach 100%
                    const baseProgress = Math.min((timeSinceActivation / maxActiveTime) * 100, 100);
                    const randomVariation = Math.sin(elapsedTime * 0.5 + stageIndex) * 5; // ±5% variation
                    const stageProgress = Math.max(0, Math.min(100, baseProgress + randomVariation));
                    
                    progressFill.style.width = `${stageProgress}%`;
                    
                    // Dynamic color based on progress and content type
                    let progressColor = '#ffaa00'; // Default orange
                    if (stageProgress > 80) {
                        progressColor = '#00ff41'; // Green when nearly complete
                    } else if (stageProgress > 50) {
                        progressColor = '#ffff00'; // Yellow when progressing well
                    }
                    
                    // Content-specific color adjustments
                    if (currentItem) {
                        switch (currentItem.type?.toLowerCase()) {
                            case 'movie':
                                progressColor = '#ff6b6b'; // Red tint for movies
                                break;
                            case 'documentary':
                                progressColor = '#4ecdc4'; // Teal for documentaries
                                break;
                            case 'series':
                            case 'episode':
                                progressColor = '#45b7d1'; // Blue for series
                                break;
                        }
                    }
                    
                    progressFill.style.background = progressColor;
                    
                    // Add pulsing effect for active stages
                    if (!item.classList.contains('pulsing')) {
                        item.classList.add('pulsing');
                        item.style.animation = 'pulse 2s ease-in-out infinite';
                    }
                    
                    // Activate glint animation
                    if (glint) {
                        glint.style.opacity = '1';
                        glint.style.animationDelay = `${stageIndex * 0.5}s`; // Stagger glint animations
                    }
                    
                    // Add subtle background color shift for active items
                    item.style.backgroundColor = `rgba(255, 170, 0, 0.05)`;
                    item.style.borderLeft = `3px solid ${progressColor}`;
                    
                    // Update description based on current content
                    const subtitle = item.querySelector('.dashboard-subtitle');
                    if (subtitle && currentItem) {
                        subtitle.textContent = `${stage.description} • ${currentItem.type?.toUpperCase() || 'CONTENT'}`;
                    }
                    
                } else if (timeThresholdMet && !contentTypeMatch) {
                    // Time threshold met but content type doesn't match - show as paused
                    item.classList.remove('active', 'pulsing');
                    item.style.animation = '';
                    status.classList.remove('status-active');
                    status.classList.add('status-paused');
                    stateText.textContent = 'Paused';
                    
                    // Show partial progress in orange
                    progressFill.style.width = '25%';
                    progressFill.style.background = '#ffaa00'; // Orange when paused
                    
                    // Deactivate glint animation
                    if (glint) {
                        glint.style.opacity = '0';
                    }
                    
                    // Remove background effects
                    item.style.backgroundColor = '';
                    item.style.borderLeft = '';
                    
                } else {
                    // Keep in queued state
                    item.classList.remove('active', 'pulsing');
                    item.style.animation = '';
                    status.classList.remove('status-active', 'status-paused');
                    status.classList.add('status-inactive');
                    stateText.textContent = 'Queued';
                    
                    // No progress when queued
                    progressFill.style.width = '0%';
                    progressFill.style.background = '#666'; // Gray when queued
                    
                    // Deactivate glint animation
                    if (glint) {
                        glint.style.opacity = '0';
                    }
                    
                    // Remove background effects
                    item.style.backgroundColor = '';
                    item.style.borderLeft = '';
                }
            });
            
            // Add CSS keyframes for animations if not already present
            if (!document.getElementById('dashboard-animations')) {
                const style = document.createElement('style');
                style.id = 'dashboard-animations';
                style.textContent = `
                    @keyframes pulse {
                        0%, 100% { transform: scale(1); opacity: 1; }
                        50% { transform: scale(1.02); opacity: 0.9; }
                    }
                    
                    @keyframes glint {
                        0% { left: -20px; }
                        100% { left: 100%; }
                    }
                    
                    .dashboard-item {
                        transition: all 0.3s ease;
                    }
                    
                    .dashboard-item.pulsing {
                        box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Show/hide learning sections based on entry point and indexing state
        function updateLearningUIVisibility() {
            const learningInsights = document.getElementById('realtime-learning-insights');
            const progressDashboard = document.getElementById('learning-progress-dashboard');
            
            if (appState.entryPoint === 'automode') {
                // Show learning insights in home view for automode
                if (learningInsights) {
                    learningInsights.style.display = 'block';
                }
                
                // Show progress dashboard in indexing view
                if (progressDashboard && appState.isIndexing) {
                    progressDashboard.style.display = 'block';
                    // Auto-expand dashboard when indexing starts
                    const dashboardGrid = document.getElementById('progress-dashboard-grid');
                    if (dashboardGrid && !dashboardGrid.classList.contains('expanded')) {
                        dashboardGrid.classList.add('expanded');
                        document.getElementById('dashboard-expand-icon').textContent = '▲';
                    }
                    updateProgressDashboard();
                }
            } else {
                // Hide both sections for non-automode entry points
                if (learningInsights) learningInsights.style.display = 'none';
                if (progressDashboard) progressDashboard.style.display = 'none';
            }
        }
        
        // NEW: Block progression and synchronization functions
        function updateBlockProgressionDisplay() {
            console.log('🔍 [DEBUG] updateBlockProgressionDisplay called');
            console.log('🔍 [DEBUG] currentBlockIndex:', appState.currentBlockIndex);
            console.log('🔍 [DEBUG] totalBlocks:', appState.totalBlocks);
            
            // Don't overwrite the rich HTML content in holistic-progress
            // The block progression info is now handled in updateAnimationPanel
            // Just send the update to the channel
            sendBlockProgressionToChannel();
        }
        
        function updateWatchingText(showData) {
            console.log('🔍 [DEBUG] updateWatchingText called with:', showData);
            
            if (!showData) {
                showData = appState.detectedShow;
            }
            
            if (!showData) {
                console.log('🔍 [DEBUG] No show data available for watching text update');
                return;
            }
            
            // Update the button text with current show
            updateButtonWithCurrentShow(showData);
            
            // Update the holistic show info with dropdown instead of grey text
            const showInfo = document.getElementById('holistic-show-info');
            if (showInfo) {
                // Replace grey text with dropdown
                showInfo.innerHTML = `
                    <div style="margin-bottom: 8px; font-size: 12px; color: #00ff41; font-weight: 600;">📺 CONTENT DETECTED</div>
                    <select id="detection-mode-dropdown-main" style="width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #333; background: #181818; color: #fff; font-size: 11px; margin-bottom: 4px;">
                        <option value="">Select Show/Movie...</option>
                    </select>
                    <div style="font-size: 10px; color: #888; text-align: center;">Content Detected Dropdown</div>
                `;
                
                // Populate the dropdown with the same data as the main dropdown
                const mainDropdown = document.getElementById('detection-mode-dropdown');
                const newDropdown = document.getElementById('detection-mode-dropdown-main');
                if (mainDropdown && newDropdown) {
                    newDropdown.innerHTML = mainDropdown.innerHTML;
                    
                    // Set current selected value
                    if (showData) {
                        newDropdown.value = showData.title;
                    }
                    
                    // Add event listener for changes
                    newDropdown.addEventListener('change', function() {
                        const selectedShow = this.value;
                        if (selectedShow && window.csvData) {
                            const showData = window.csvData.find(row => row.show_name === selectedShow);
                            if (showData) {
                                const detectedShowData = {
                                    title: showData.show_name,
                                    genre: showData.genre,
                                    service: showData.service || 'UNKNOWN',
                                    season: showData.season || 'N/A',
                                    episode: showData.episode || 'N/A',
                                    duration: parseInt(showData.duration_minutes) || 60,
                                    type: showData.type || 'show',
                                    year: showData.year || null,
                                    episode_title: showData.episode_title || null
                                };
                                
                                // Update global state
                                detectedShow = detectedShowData;
                                appState.detectedShow = detectedShowData;
                                
                                // Update button text
                                updateButtonWithCurrentShow(detectedShowData);
                                
                                // Send to genre channel
                                setTimeout(() => {
                                    sendShowDetection(detectedShowData);
                                }, 100);
                            }
                        }
                    });
                }
            }
            
            // Update the ASCII animation with current show context
            if (appState.isIndexing) {
                const elapsedTime = TimeSystem.getElapsedTime();
                updateAnimationPanel(elapsedTime);
            }
        }
        
        function sendBlockProgressionToChannel() {
            console.log('🔍 [DEBUG] sendBlockProgressionToChannel called');
            
            // For automode, prioritize sending to rumi-channel
            const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('🔍 [DEBUG] Channel frame not available for block progression sync');
                return;
            }
            
            console.log('🔍 [DEBUG] Sending block progression to channel:', channelFrame.src);
            
            const progressionData = {
                currentBlockIndex: appState.currentBlockIndex,
                totalBlocks: appState.totalBlocks,
                elapsedTime: TimeSystem.getElapsedTime(),
                currentMultiplier: appState.currentMultiplier,
                sessionProgress: TimeSystem.getProgress()
            };
            
            try {
                channelFrame.contentWindow.postMessage({
                    type: 'blockProgressionUpdate',
                    data: progressionData
                }, '*');
                console.log('📡 Sent block progression update to channel:', progressionData);
            } catch (error) {
                console.error('❌ Error sending block progression to channel:', error);
            }
        }
        
        function initializeBlockProgression() {
            console.log('🔍 [DEBUG] initializeBlockProgression called');
            
            // Reset block progression state
            appState.currentBlockIndex = 0;
            appState.totalBlocks = 0;
            
            // Calculate total blocks based on content
            if (appState.entryPoint === 'detection' && appState.detectedShow) {
                // For detection mode, get blocks from channel content
                requestChannelContentForBlocks();
            } else if (appState.entryPoint === 'automode' && appState.automodeContentItems) {
                // For automode, use content items
                appState.totalBlocks = appState.automodeContentItems.length;
                console.log('🔍 [DEBUG] Automode total blocks:', appState.totalBlocks);
            }
            
            // Update display
            updateBlockProgressionDisplay();
        }
        
        function requestChannelContentForBlocks() {
            console.log('🔍 [DEBUG] requestChannelContentForBlocks called');
            
            const channelFrame = document.getElementById('channel-frame-indexing') || document.getElementById('channel-frame');
            if (!channelFrame || !channelFrame.contentWindow) {
                console.log('🔍 [DEBUG] Channel frame not available for block count request');
                return;
            }
            
            try {
                channelFrame.contentWindow.postMessage({
                    type: 'requestCurrentContent'
                }, '*');
                console.log('📡 Requested current content for block count');
            } catch (error) {
                console.error('❌ Error requesting content for blocks:', error);
            }
        }
        
        function advanceBlockProgression() {
            console.log('🔍 [DEBUG] advanceBlockProgression called');
            
            if (appState.currentBlockIndex < appState.totalBlocks - 1) {
                // Check if we just completed the first block (index 0)
                if (appState.currentBlockIndex === 0 && !appState.firstBlockCompleted) {
                    appState.firstBlockCompleted = true;
                    console.log('🔍 [DEBUG] First block completed - triggering watch with us prompt');
                    
                    // Trigger watch with us prompt after a short delay
                    setTimeout(() => {
                        showWatchWithUsPrompt();
                    }, 1000); // 1 second delay to show completion
                }
                
                appState.currentBlockIndex++;
                console.log(`🔍 [DEBUG] Advanced to block ${appState.currentBlockIndex + 1}/${appState.totalBlocks}`);
                
                // Update display
                updateBlockProgressionDisplay();
                
                // Trigger content synchronization
                synchronizeContentWithBlocks();
                
                return true;
            } else {
                console.log('🔍 [DEBUG] Already at final block');
                return false;
            }
        }
        
        function synchronizeContentWithBlocks() {
            console.log('🔍 [DEBUG] synchronizeContentWithBlocks called');
            
            // Synchronize app state with current block
            if (appState.entryPoint === 'automode' && appState.automodeContentItems) {
                // Update current content index to match block index
                if (appState.currentBlockIndex < appState.automodeContentItems.length) {
                    appState.currentContentIndex = appState.currentBlockIndex;
                    
                    const currentItem = appState.automodeContentItems[appState.currentBlockIndex];
                    if (currentItem) {
                        // Update content timing
                        let cumulativeTime = 0;
                        for (let i = 0; i < appState.currentBlockIndex; i++) {
                            const prevItem = appState.automodeContentItems[i];
                            if (prevItem) {
                                                            const duration = prevItem.duration_seconds || 
                                (typeof prevItem.duration === 'string' && prevItem.duration.includes(':') ?
                                (parseInt(prevItem.duration.split(':')[0]) * 60 + parseInt(prevItem.duration.split(':')[1])) :
                                (prevItem.duration || 45 * 60));
                                cumulativeTime += duration;
                            }
                        }
                        
                        appState.contentItemStartTime = cumulativeTime;
                        appState.contentItemDuration = currentItem.duration_seconds || 
                            (typeof currentItem.duration === 'string' && currentItem.duration.includes(':') ?
                            (parseInt(currentItem.duration.split(':')[0]) * 60 + parseInt(currentItem.duration.split(':')[1])) :
                            (currentItem.duration || 45 * 60));
                        
                        console.log(`🔍 [DEBUG] Synchronized content: ${currentItem.title} (${appState.contentItemDuration}s)`);
                        
                        // Update UI with current content
                        updateWatchingText();
                    }
                }
            }
            
            // Update animation panel to reflect current content
            if (appState.isIndexing) {
                const elapsedTime = TimeSystem.getElapsedTime();
                updateAnimationPanel(elapsedTime);
            }
        }
        
        // Calculate how many blocks to advance based on time skipped
        function calculateBlocksToAdvance(skipSeconds) {
            console.log('🔍 [DEBUG] calculateBlocksToAdvance called with:', skipSeconds, 'seconds');
            
            if (!appState.totalBlocks || appState.totalBlocks === 0) {
                console.log('🔍 [DEBUG] No blocks to advance - totalBlocks is 0');
                return 0;
            }
            
            // Get current elapsed time
            const currentElapsedTime = TimeSystem.getElapsedTime();
            const newElapsedTime = currentElapsedTime + skipSeconds;
            
            // Calculate current and new block indices based on actual content timing
            const currentExpectedIndex = calculateExpectedBlockIndex(currentElapsedTime);
            const newExpectedIndex = calculateExpectedBlockIndex(newElapsedTime);
            
            const blocksToAdvance = Math.max(0, newExpectedIndex - appState.currentBlockIndex);
            
            console.log(`🔍 [DEBUG] Block advancement calculation:`);
            console.log(`   Current elapsed time: ${currentElapsedTime}s`);
            console.log(`   New elapsed time: ${newElapsedTime}s`);
            console.log(`   Current block index: ${appState.currentBlockIndex}`);
            console.log(`   Current expected index: ${currentExpectedIndex}`);
            console.log(`   New expected index: ${newExpectedIndex}`);
            console.log(`   Blocks to advance: ${blocksToAdvance}`);
            
            return blocksToAdvance;
        }
        
        // Calculate expected block index based on elapsed time and actual content durations
        function calculateExpectedBlockIndex(elapsedTime) {
            console.log('🔍 [DEBUG] calculateExpectedBlockIndex called with:', elapsedTime, 'seconds');
            
            // Use UnifiedTimeSync calculation if available
            if (UnifiedTimeSync.syncInterval) {
                const expectedIndex = UnifiedTimeSync.calculateExpectedBlockIndex(elapsedTime);
                console.log(`🔍 [DEBUG] Expected block index (UnifiedTimeSync): ${expectedIndex}`);
                return expectedIndex;
            }
            
            if (appState.entryPoint === 'automode' && appState.automodeContentItems) {
                // For automode, calculate based on actual content item durations
                let cumulativeTime = 0;
                
                for (let i = 0; i < appState.automodeContentItems.length; i++) {
                    const item = appState.automodeContentItems[i];
                    const duration = item.duration_seconds || 
                        (typeof item.duration === 'string' && item.duration.includes(':') ?
                        (parseInt(item.duration.split(':')[0]) * 60 + parseInt(item.duration.split(':')[1])) :
                        (item.duration || 45 * 60));
                    
                    if (elapsedTime < cumulativeTime + duration) {
                        console.log(`🔍 [DEBUG] Expected block index: ${i} (${item.title})`);
                        return i;
                    }
                    
                    cumulativeTime += duration;
                }
                
                // If we've exceeded all content, return the last index
                const lastIndex = appState.automodeContentItems.length - 1;
                console.log(`🔍 [DEBUG] Expected block index: ${lastIndex} (final block)`);
                return lastIndex;
            } else if (appState.entryPoint === 'detection') {
                // For detection mode, use synchronized timeline if available
                if (SynchronizedTimeline.isInitialized && SynchronizedTimeline.contentItems) {
                    let cumulativeTime = 0;
                    
                    for (let i = 0; i < SynchronizedTimeline.contentItems.length; i++) {
                        const item = SynchronizedTimeline.contentItems[i];
                        const duration = SynchronizedTimeline.parseContentDuration(item.duration);
                        
                        if (elapsedTime < cumulativeTime + duration) {
                            console.log(`🔍 [DEBUG] Expected block index: ${i} (${item.title})`);
                            return i;
                        }
                        cumulativeTime += duration;
                    }
                    
                    const lastIndex = SynchronizedTimeline.contentItems.length - 1;
                    console.log(`🔍 [DEBUG] Expected block index: ${lastIndex} (final block)`);
                    return lastIndex;
                } else {
                    // Fallback: use session duration divided by total blocks
                    const sessionDuration = TimeSystem.getSessionDuration();
                    const progress = Math.min(elapsedTime / sessionDuration, 1.0);
                    const expectedIndex = Math.floor(progress * appState.totalBlocks);
                    
                    console.log(`🔍 [DEBUG] Expected block index (estimated): ${expectedIndex}`);
                    return Math.min(expectedIndex, appState.totalBlocks - 1);
                }
            } else {
                // For other modes, use average duration estimation
                const sessionDuration = TimeSystem.getSessionDuration();
                const progress = Math.min(elapsedTime / sessionDuration, 1.0);
                const expectedIndex = Math.floor(progress * appState.totalBlocks);
                
                console.log(`🔍 [DEBUG] Expected block index (estimated): ${expectedIndex}`);
                return Math.min(expectedIndex, appState.totalBlocks - 1);
            }
        }
        

        
        // Update points display
    </script>
    <script>
        console.log('[RUMI] Dynamic dropdown script loaded');
        function parseCSV(text) {
            const lines = text.split(/\r?\n/).filter(Boolean);
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).map(line => {
                // Handle quoted fields with commas
                const values = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') inQuotes = !inQuotes;
                    else if (char === ',' && !inQuotes) {
                        values.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current);
                const obj = {};
                headers.forEach((h, i) => obj[h] = values[i] ? values[i].replace(/^"|"$/g, '') : '');
                return obj;
            });
        }
        
        // Initialize dropdown change handlers
        function initializeDropdownHandlers() {
            const detectionDropdown = document.getElementById('detection-mode-dropdown');
            const automodeDropdown = document.getElementById('automode-dropdown');
            
            // Detection mode dropdown change handler
            detectionDropdown.addEventListener('change', function() {
                const selectedShow = this.value;
                const streamDetectedButton = document.getElementById('stream-detected-button');
                
                if (selectedShow) {
                    console.log('[RUMI] Detection mode dropdown changed to:', selectedShow);
                    
                    // Enable the button
                    streamDetectedButton.disabled = false;
                    streamDetectedButton.classList.remove('disabled');
                    streamDetectedButton.style.background = 'rgba(0,0,0,0.2)';
                    streamDetectedButton.style.border = '1px solid rgba(0,0,0,0.3)';
                    streamDetectedButton.style.color = '#000';
                    streamDetectedButton.style.cursor = 'pointer';
                    streamDetectedButton.textContent = 'Launch Rumi & Get Points';
                    
                    // Find the show data from CSV
                    if (window.csvData) {
                        const showData = window.csvData.find(row => row.show_name === selectedShow);
                        if (showData) {
                            // Update the detected show
                            const detectedShowData = {
                                title: showData.show_name,
                                genre: showData.genre,
                                service: showData.service || 'UNKNOWN',
                                season: showData.season || 'N/A',
                                episode: showData.episode || 'N/A',
                                duration: parseInt(showData.duration_minutes) || 60,
                                type: showData.type || 'show',
                                year: showData.year || null,
                                episode_title: showData.episode_title || null
                            };
                            
                            // Update global state
                            detectedShow = detectedShowData;
                            appState.detectedShow = detectedShowData;
                            
                            // Update the "Watching ____" text
                            updateWatchingText(detectedShowData);
                            
                            // Send to genre channel
                            setTimeout(() => {
                                sendShowDetection(detectedShowData);
                            }, 100);
                            
                            console.log('[RUMI] Updated detected show from dropdown:', detectedShowData);
                        }
                    }
                } else {
                    // Disable the button when no selection
                    streamDetectedButton.disabled = true;
                    streamDetectedButton.classList.add('disabled');
                    streamDetectedButton.style.background = 'rgba(0,0,0,0.1)';
                    streamDetectedButton.style.border = '1px solid rgba(0,0,0,0.2)';
                    streamDetectedButton.style.color = '#666';
                    streamDetectedButton.style.cursor = 'not-allowed';
                    streamDetectedButton.textContent = 'Select Show to Launch';
                }
            });
            
            // Automode dropdown change handler
            automodeDropdown.addEventListener('change', function() {
                const selectedBucket = this.value;
                const automodeButton = document.getElementById('automode-button');
                
                if (selectedBucket) {
                    console.log('[RUMI] Automode dropdown changed to:', selectedBucket);
                    
                    // Enable the button
                    automodeButton.disabled = false;
                    automodeButton.classList.remove('disabled');
                    automodeButton.style.background = 'rgba(255,255,255,0.2)';
                    automodeButton.style.border = '1px solid rgba(255,255,255,0.3)';
                    automodeButton.style.color = '#fff';
                    automodeButton.style.cursor = 'pointer';
                    automodeButton.textContent = 'Launch Campaign';
                    
                    appState.currentBucket = selectedBucket;
                    updateChannelTitle();
                } else {
                    // Disable the button when no selection
                    automodeButton.disabled = true;
                    automodeButton.classList.add('disabled');
                    automodeButton.style.background = 'rgba(255,255,255,0.1)';
                    automodeButton.style.border = '1px solid rgba(255,255,255,0.2)';
                    automodeButton.style.color = '#666';
                    automodeButton.style.cursor = 'not-allowed';
                    automodeButton.textContent = 'Select Intelligence Bucket to Launch';
                }
            });
        }
        
        // Update watching text in the UI
        function updateWatchingText(showData) {
            // Update any "Watching ____" text elements
            const watchingElements = document.querySelectorAll('.watching-text, #watching-show-text');
            watchingElements.forEach(element => {
                element.textContent = `Watching ${showData.title}`;
            });
            
            // Format the show title properly
            let displayTitle = showData.title;
            if (showData.type === 'show' || showData.type === 'episode') {
                if (showData.season && showData.episode && showData.season !== 'N/A' && showData.episode !== 'N/A') {
                    // Extract numbers from season/episode strings
                    const seasonNum = showData.season.replace(/[^0-9]/g, '');
                    const episodeNum = showData.episode.replace(/[^0-9]/g, '');
                    displayTitle = `${showData.title} S${seasonNum}:E${episodeNum}`;
                }
            } else if (showData.type === 'movie' && showData.year) {
                displayTitle = `${showData.title} (${showData.year})`;
            }
            
            // Update the integrated detection dropdown to show current selection
            const detectionDropdown = document.getElementById('detection-mode-dropdown');
            if (detectionDropdown && showData.title) {
                detectionDropdown.value = showData.title;
            }
        }

        async function populateDropdownsFromCSV() {
            try {
                console.log('[RUMI] Attempting to fetch CSV for dropdowns...');
                // Load FULL-LENGTH content for detected mode dropdown
                const detectedResponse = await fetch('full-length-content-library.csv');
                if (!detectedResponse.ok) throw new Error('Detected CSV fetch failed: ' + detectedResponse.status);
                const detectedCSVText = await detectedResponse.text();
                const detectedData = parseCSV(detectedCSVText);
                
                // Load automode content for automode dropdown
                const automodeResponse = await fetch('content-library-expanded_LUDICROUS_WORKING.csv');
                if (!automodeResponse.ok) throw new Error('Automode CSV fetch failed: ' + automodeResponse.status);
                const automodeCSVText = await automodeResponse.text();
                const automodeData = parseCSV(automodeCSVText);
                
                // Store CSV data globally for dropdown handlers
                window.csvData = detectedData; // Use detected data for detection mode
                window.automodeCSVData = automodeData; // Store automode data separately
                
                // For detected mode: Use show_name from full-length content
                const uniqueShows = [];
                const addedShows = new Set();
                
                detectedData.forEach(row => {
                    if (row.show_name && !addedShows.has(row.show_name)) {
                        addedShows.add(row.show_name);
                        uniqueShows.push({
                            title: row.show_name,
                            displayTitle: row.type === 'episode' ? 
                                `${row.show_name} S${row.season}E${row.episode}` : 
                                row.show_name,
                            ...row
                        });
                    }
                });
                
                uniqueShows.sort((a, b) => a.title.localeCompare(b.title));
                
                // Populate Detection Mode dropdown with full-length content
                const detectionDropdown = document.getElementById('detection-mode-dropdown');
                detectionDropdown.innerHTML = '<option value="">Select Show/Movie...</option>' + 
                    uniqueShows.map(show => `<option value="${show.title}">${show.displayTitle}</option>`).join('');
                
                // Populate Automode dropdown with automode buckets (ensure unique values)
                const allBuckets = automodeData.map(row => row.intelligence_bucket).filter(Boolean);
                console.log('[RUMI] All buckets before deduplication:', allBuckets);
                
                // More robust deduplication: normalize strings and remove duplicates
                const normalizedBuckets = allBuckets.map(bucket => bucket.trim());
                const uniqueBuckets = Array.from(new Set(normalizedBuckets)).sort();
                console.log('[RUMI] Unique buckets after Set deduplication:', uniqueBuckets);
                
                // Additional case-insensitive deduplication as final safety measure
                const finalBuckets = uniqueBuckets.filter((bucket, index, array) => 
                    array.findIndex(b => b.toLowerCase().trim() === bucket.toLowerCase().trim()) === index
                );
                console.log('[RUMI] Final buckets after case-insensitive deduplication:', finalBuckets);
                
                const automodeDropdown = document.getElementById('automode-dropdown');
                automodeDropdown.innerHTML = '<option value="">Select Intelligence Bucket...</option>' + 
                    finalBuckets.map(b => `<option value="${b}">${b}</option>`).join('');
                
                // Initialize dropdown handlers after population
                initializeDropdownHandlers();
                
                // Ensure button starts in disabled state
                const streamDetectedButton = document.getElementById('stream-detected-button');
                if (streamDetectedButton) {
                    streamDetectedButton.disabled = true;
                    streamDetectedButton.classList.add('disabled');
                    streamDetectedButton.textContent = 'Select Show to Launch';
                }
                
                // Log for debugging
                console.log('[RUMI] Full-length shows loaded:', uniqueShows.length);
                console.log('[RUMI] Automode buckets loaded:', finalBuckets.length);
            } catch (err) {
                console.error('[RUMI] Error loading CSV for dropdowns:', err);
            }
        }
        
        document.addEventListener('DOMContentLoaded', populateDropdownsFromCSV);
    </script>
</body>
</html> 